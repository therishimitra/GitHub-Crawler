NAME,LOCATION,DESCRIPTION,PARAMETERS,RETURNS
,https://github.com//numpy/numpy/blob/master/numpy/_build_utils/apple_accelerate.py,,,
uses_accelerate_framework(info):,https://github.com//numpy/numpy/blob/master/numpy/_build_utils/apple_accelerate.py,"  Returns True if Accelerate framework is used for BLAS/LAPACK  # If we're not building on Darwin (macOS), don't use Accelerate if sys.platform != ""darwin"": return False # If we're building on macOS, but targeting a different platform, # don't use Accelerate. if os.getenv('_PYTHON_HOST_PLATFORM', None): return False    r_accelerate = re.compile(""Accelerate"")    extra_link_args = info.get('extra_link_args', '') for arg in extra_link_args: if r_accelerate.search(arg): return True return False
",,
,https://github.com//numpy/numpy/blob/master/numpy/compat/tests/test_compat.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py,,,
ismethod(object):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Return true if the object is an instance method.    Instance method objects provide these attributes:        __doc__         documentation string        __name__        name with which this method was defined        im_class        class object in which this method belongs        im_func         function object containing implementation of method        im_self         instance to which this method is bound, or None",,
isfunction(object):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py, Return true if the object is a user-defined function.    Function objects provide these attributes:        __doc__         documentation string        __name__        name with which this function was defined        func_code       code object containing compiled function bytecode        func_defaults   tuple of any default values for arguments        func_doc        (same as __doc__)        func_globals    global namespace in which this function was defined        func_name       (same as __name__),,
iscode(object):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py, Return true if the object is a code object.    Code objects provide these attributes:        co_argcount     number of arguments (not including * or ** args)        co_code         string of raw compiled bytecode        co_consts       tuple of constants used in the bytecode        co_filename     name of file in which this code object was created        co_firstlineno  number of first line in Python source code        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg        co_lnotab       encoded mapping of line numbers to bytecode indices        co_name         name with which this code object was defined        co_names        tuple of names of local variables        co_nlocals      number of local variables        co_stacksize    virtual machine stack space required        co_varnames     tuple of names of arguments and local variables ,,
getargs(co):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Get information about the arguments accepted by a code object.    Three things are returned: (args, varargs, varkw), where 'args' is    a list of argument names (possibly containing nested lists), and    'varargs' and 'varkw' are the names of the * and ** arguments or None.",,
getargspec(func):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Get the names and default values of a function's arguments.    A tuple of four things is returned: (args, varargs, varkw, defaults).    'args' is a list of the argument names (it may contain nested lists).    'varargs' and 'varkw' are the names of the * and ** arguments or None.    'defaults' is an n-tuple of the default values of the last n arguments.",,
getargvalues(frame):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Get information about arguments passed into a particular frame.    A tuple of four things is returned: (args, varargs, varkw, locals).    'args' is a list of the argument names (it may contain nested lists).    'varargs' and 'varkw' are the names of the * and ** arguments or None.    'locals' is the locals dictionary of the given frame. ",,
joinseq(seq):,https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py,,,
"strseq(object, convert, join=joinseq):",https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Recursively walk a sequence, stringifying each element.",,
"formatargspec(args, varargs=None, varkw=None, defaults=None,",https://github.com//numpy/numpy/blob/master/numpy/compat/_inspect.py," Format an argument spec from the 4 values returned by getargspec.    The first four arguments are (args, varargs, varkw, defaults).  The    other four arguments are the corresponding optional formatting functions    that are called to turn names and values into strings.  The ninth    argument is an optional function to format the sequence of arguments.",,
,https://github.com//numpy/numpy/blob/master/numpy/compat/py3k.py,,,
getexception():,https://github.com//numpy/numpy/blob/master/numpy/compat/py3k.py,,,
asbytes_nested(x):,https://github.com//numpy/numpy/blob/master/numpy/compat/py3k.py,,,
asunicode_nested(x):,https://github.com//numpy/numpy/blob/master/numpy/compat/py3k.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/compat/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,"Get API information encoded in C files.See ``find_function`` for how functions should be formatted, and``read_order`` for how the order of the functions should bespecified.",,
file_in_this_dir(filename):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
remove_whitespace(s):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
_repl(str):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
"skip_brackets(s, lbrac, rbrac):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
split_arguments(argstr):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
"find_functions(filename, tag='API'):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,"     Scan the file, looking for tagged functions.    Assuming ``tag=='API'``, a tagged function looks like::        /*API*/        static returntype*        function_name(argtype1 arg1, argtype2 arg2)        {        }    where the return type must be on a separate line, the function    name must start the line, and the opening ``{`` must start the line.    An optional documentation comment in ReST format may follow the tag,    as in::        /*API          This function does foo...         */",,
"should_rebuild(targets, source_files):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
"write_file(filename, data):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,     Write data to filename    Only write changed data to avoid updating timestamps unnecessarily,,
order_dict(d):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py," Order dict by its values.    o = list(d.items()) def _key(x): return x[1] + (x[0],) return sorted(o, key=_key)
",,
merge_api_dicts(dicts):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
check_api_dict(d):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py," Check that an api dict is valid (does not use the same index twice). # remove the extra value fields that aren't the index    index_d = {k: v[0] for k, v in d.items()}
 # We have if a same index is used twice: we 'revert' the dict so that index # become keys. If the length is different, it means one index has been used # at least twice    revert_dict = {v: k for k, v in index_d.items()} if not len(revert_dict) == len(index_d): # We compute a dict index -> list of associated items        doubled = {} for name, index in index_d.items(): try:                doubled[index].append(name) except KeyError:                doubled[index] = [name]        fmt = ""Same index has been used twice in api definition: {}""        val = ''.join( '\n\tindex {} -> {}'.format(index, names) for index, names in doubled.items() if len(names) != 1        ) raise ValueError(fmt.format(val))
 # No 'hole' in the indexes may be allowed, and it must starts at 0    indexes = set(index_d.values())    expected = set(range(len(indexes))) if indexes != expected:        diff = expected.symmetric_difference(indexes)        msg = ""There are some holes in the API indexing: "" \ ""(symmetric diff is %s)"" % diff raise ValueError(msg)
",,
"get_api_functions(tagname, api_dict):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py," Parse source files to get functions tagged by the given tag.    functions = [] for f in API_FILES:        functions.extend(find_functions(f, tagname))    dfunctions = [(api_dict[func.name][0], func) for func in functions]    dfunctions.sort() return [a[1] for a in dfunctions]
",,
fullapi_hash(api_dicts):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py," Given a list of api dicts defining the numpy C API, compute a checksum",,
get_versions_hash():,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/genapi.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_numpy_api.py,"h_template = r#if defined(_MULTIARRAYMODULE) || defined(WITH_CPYCHECKER_STEALS_REFERENCE_TO_ARG_ATTRIBUTE)typedef struct {        PyObject_HEAD        npy_bool obval;} PyBoolScalarObject;extern NPY_NO_EXPORT PyTypeObject PyArrayMapIter_Type;extern NPY_NO_EXPORT PyTypeObject PyArrayNeighborhoodIter_Type;extern NPY_NO_EXPORT PyBoolScalarObject _PyArrayScalar_BoolValues[2];%s#else#if defined(PY_ARRAY_UNIQUE_SYMBOL)#define PyArray_API PY_ARRAY_UNIQUE_SYMBOL#endif#if defined(NO_IMPORT) || defined(NO_IMPORT_ARRAY)extern void **PyArray_API;#else#if defined(PY_ARRAY_UNIQUE_SYMBOL)void **PyArray_API;#elsestatic void **PyArray_API=NULL;#endif#endif%s#if !defined(NO_IMPORT_ARRAY) && !defined(NO_IMPORT)static int_import_array(void){  int st;  PyObject *numpy = PyImport_ImportModule(""numpy.core._multiarray_umath"");  PyObject *c_api = NULL;  if (numpy == NULL) {      return -1;  }  c_api = PyObject_GetAttrString(numpy, ""_ARRAY_API"");  Py_DECREF(numpy);  if (c_api == NULL) {      PyErr_SetString(PyExc_AttributeError, ""_ARRAY_API not found"");      return -1;  }#if PY_VERSION_HEX >= 0x03000000  if (!PyCapsule_CheckExact(c_api)) {      PyErr_SetString(PyExc_RuntimeError, ""_ARRAY_API is not PyCapsule object"");      Py_DECREF(c_api);      return -1;  }  PyArray_API = (void **)PyCapsule_GetPointer(c_api, NULL);#else  if (!PyCObject_Check(c_api)) {      PyErr_SetString(PyExc_RuntimeError, ""_ARRAY_API is not PyCObject object"");      Py_DECREF(c_api);      return -1;  }  PyArray_API = (void **)PyCObject_AsVoidPtr(c_api);#endif  Py_DECREF(c_api);  if (PyArray_API == NULL) {      PyErr_SetString(PyExc_RuntimeError, ""_ARRAY_API is NULL pointer"");      return -1;  }  /* Perform runtime check of C API version */  if (NPY_VERSION != PyArray_GetNDArrayCVersion()) {      PyErr_Format(PyExc_RuntimeError, ""module compiled against ""\             ""ABI version 0x%%x but this version of numpy is 0x%%x"", \ (int) NPY_VERSION, (int) PyArray_GetNDArrayCVersion());      return -1;  }  if (NPY_FEATURE_VERSION > PyArray_GetNDArrayCFeatureVersion()) {      PyErr_Format(PyExc_RuntimeError, ""module compiled against ""\             ""API version 0x%%x but this version of numpy is 0x%%x"", \ (int) NPY_FEATURE_VERSION, (int) PyArray_GetNDArrayCFeatureVersion());      return -1;  }  /* * Perform runtime check of endianness and check it matches the one set by * the headers (npy_endian.h) as a safeguard */  st = PyArray_GetEndianness();  if (st == NPY_CPU_UNKNOWN_ENDIAN) {      PyErr_Format(PyExc_RuntimeError, ""FATAL: module compiled as unknown endian"");      return -1;  }#if NPY_BYTE_ORDER == NPY_BIG_ENDIAN  if (st != NPY_CPU_BIG) {      PyErr_Format(PyExc_RuntimeError, ""FATAL: module compiled as ""\             ""big endian, but detected different endianness at runtime"");      return -1;  }#elif NPY_BYTE_ORDER == NPY_LITTLE_ENDIAN  if (st != NPY_CPU_LITTLE) {      PyErr_Format(PyExc_RuntimeError, ""FATAL: module compiled as ""\             ""little endian, but detected different endianness at runtime"");      return -1;  }#endif  return 0;}#if PY_VERSION_HEX >= 0x03000000#define NUMPY_IMPORT_ARRAY_RETVAL NULL#else#define NUMPY_IMPORT_ARRAY_RETVAL#endif#define import_array() {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, ""numpy.core.multiarray failed to import""); return NUMPY_IMPORT_ARRAY_RETVAL; } }#define import_array1(ret) {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, ""numpy.core.multiarray failed to import""); return ret; } }#define import_array2(msg, ret) {if (_import_array() < 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, msg); return ret; } }#endif#endif",,
"generate_api(output_dir, force=False):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_numpy_api.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_ufunc_api.py,"h_template = r#ifdef _UMATHMODULEextern NPY_NO_EXPORT PyTypeObject PyUFunc_Type;%s#else#if defined(PY_UFUNC_UNIQUE_SYMBOL)#define PyUFunc_API PY_UFUNC_UNIQUE_SYMBOL#endif#if defined(NO_IMPORT) || defined(NO_IMPORT_UFUNC)extern void **PyUFunc_API;#else#if defined(PY_UFUNC_UNIQUE_SYMBOL)void **PyUFunc_API;#elsestatic void **PyUFunc_API=NULL;#endif#endif%sstatic NPY_INLINE int_import_umath(void){  PyObject *numpy = PyImport_ImportModule(""numpy.core._multiarray_umath"");  PyObject *c_api = NULL;  if (numpy == NULL) {      PyErr_SetString(PyExc_ImportError,                      ""numpy.core._multiarray_umath failed to import"");      return -1;  }  c_api = PyObject_GetAttrString(numpy, ""_UFUNC_API"");  Py_DECREF(numpy);  if (c_api == NULL) {      PyErr_SetString(PyExc_AttributeError, ""_UFUNC_API not found"");      return -1;  }#if PY_VERSION_HEX >= 0x03000000  if (!PyCapsule_CheckExact(c_api)) {      PyErr_SetString(PyExc_RuntimeError, ""_UFUNC_API is not PyCapsule object"");      Py_DECREF(c_api);      return -1;  }  PyUFunc_API = (void **)PyCapsule_GetPointer(c_api, NULL);#else  if (!PyCObject_Check(c_api)) {      PyErr_SetString(PyExc_RuntimeError, ""_UFUNC_API is not PyCObject object"");      Py_DECREF(c_api);      return -1;  }  PyUFunc_API = (void **)PyCObject_AsVoidPtr(c_api);#endif  Py_DECREF(c_api);  if (PyUFunc_API == NULL) {      PyErr_SetString(PyExc_RuntimeError, ""_UFUNC_API is NULL pointer"");      return -1;  }  return 0;}#if PY_VERSION_HEX >= 0x03000000#define NUMPY_IMPORT_UMATH_RETVAL NULL#else#define NUMPY_IMPORT_UMATH_RETVAL#endif#define import_umath() \    do {\        UFUNC_NOFPE\        if (_import_umath() < 0) {\            PyErr_Print();\            PyErr_SetString(PyExc_ImportError,\                    ""numpy.core.umath failed to import"");\            return NUMPY_IMPORT_UMATH_RETVAL;\        }\    } while(0)#define import_umath1(ret) \    do {\        UFUNC_NOFPE\        if (_import_umath() < 0) {\            PyErr_Print();\            PyErr_SetString(PyExc_ImportError,\                    ""numpy.core.umath failed to import"");\            return ret;\        }\    } while(0)#define import_umath2(ret, msg) \    do {\        UFUNC_NOFPE\        if (_import_umath() < 0) {\            PyErr_Print();\            PyErr_SetString(PyExc_ImportError, msg);\            return ret;\        }\    } while(0)#define import_ufunc() \    do {\        UFUNC_NOFPE\        if (_import_umath() < 0) {\            PyErr_Print();\            PyErr_SetString(PyExc_ImportError,\                    ""numpy.core.umath failed to import"");\        }\    } while(0)#endif",,
"generate_api(output_dir, force=False):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_ufunc_api.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py, Stores the suffix to append when generating functions names.,,
"build_func_data(types, f):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py,,,
"TD(types, f=None, astype=None, in_=None, out=None, simd=None):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py, Description of a ufunc.    Attributes    ----------    nin : number of input arguments    nout : number of output arguments    identity : identity element for a two-argument function    docstring : docstring for the ufunc    type_descriptions : list of TypeDescription objects,,
english_upper(s):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py,"  Apply English case rules to convert ASCII strings to all upper case.    This is an internal utility function to replace calls to str.upper() such    that we can avoid changing behavior with changing locales. In particular,    Turkish has distinct dotted and dotless variants of the Latin letter ""I"" in    both lowercase and uppercase. Thus, ""i"".upper() != ""I"" in a ""tr"" locale.",s : str,uppered : str
"indent(st, spaces):",https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py,,,
make_arrays(funcdict):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py,"                        code2list.append(textwrap.dedent(\                        #ifdef HAVE_ATTRIBUTE_TARGET_{ISA}                        if (npy_cpu_supports(""{isa}"")) {{ {fname}_functions[{idx}] = {type}_{fname}_{isa}; }}                        #endif",,
make_ufuncs(funcdict):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/generate_umath.py,"        fmt = textwrap.dedent(\            identity = {identity_expr};            if ({has_identity} && identity == NULL) {{                return -1; }}            f = PyUFunc_FromFuncAndDataAndSignatureAndIdentity( {name}_functions, {name}_data, {name}_signatures, {nloops}, {nin}, {nout}, {identity}, ""{name}"",                ""{doc}"", 0, {sig}, identity            );            if ({has_identity}) {{                Py_DECREF(identity); }}            if (f == NULL) {{                return -1; }}",,
,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/ufunc_docstrings.py,,,
get(name):,https://github.com//numpy/numpy/blob/master/numpy/core/code_generators/ufunc_docstrings.py," 'PARAMS': textwrap.dedent(        out : ndarray, None, or tuple of ndarray and None, optional            A location into which the result is stored. If provided, it must have            a shape that the inputs broadcast to. If not provided or `None`,            a freshly-allocated array is returned. A tuple (possible only as a            keyword argument) must have length equal to the number of outputs.        where : array_like, optional            This condition is broadcast over the input. At locations where the            condition is True, the `out` array will be set to the ufunc result.            Elsewhere, the `out` array will retain its original value.            Note that if an uninitialized `out` array is created via the default            ``out=None``, locations within it where the condition is False will            remain uninitialized.        **kwargs            For other keyword-only arguments, see the            :ref:`ufunc docs <ufuncs.kwargs>`.",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/_locales.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_array_array():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_fastCopyAndTranspose():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_array_astype():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_array_astype_warning(t):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_copyto_fromscalar():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_copyto():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_copyto_permut():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_copy_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
test_contiguous_flags():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_api.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_arrayprint.py," Basic test of array2string.        a = np.arange(3)        assert_(np.array2string(a) == '[0 1 2]')        assert_(np.array2string(a, max_line_width=4, legacy='1.13') == '[0 1\n 2]')        assert_(np.array2string(a, max_line_width=4) == '[0\n 1\n 2]')
 def test_unexpected_kwarg(self): # ensure than an appropriate TypeError # is raised when array2string receives # an unexpected kwarg
 with assert_raises_regex(TypeError, 'nonsense'):            np.array2string(np.array([1, 2, 3]), nonsense=None)
 def test_format_function(self):",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_defchararray.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py,,,
"assert_dtype_equal(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py,,,
"assert_dtype_not_equal(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py," Only test hash runs at all.        dt = np.dtype(t) hash(dt)
 @pytest.mark.parametrize('t', [int, float]) def test_dtype(self, t): # Make sure equivalent byte order char hash the same (e.g. < and = on # little endian)        dt = np.dtype(t)        dt2 = dt.newbyteorder(""<"")        dt3 = dt.newbyteorder("">"") if dt == dt2:            assert_(dt.byteorder != dt2.byteorder, ""bogus test"")            assert_dtype_equal(dt, dt2) else:            assert_(dt.byteorder != dt3.byteorder, ""bogus test"")            assert_dtype_equal(dt, dt3)
 def test_equivalent_dtype_hashing(self): # Make sure equivalent dtypes with different type num hash equal        uintp = np.dtype(np.uintp) if uintp.itemsize == 4:            left = uintp            right = np.dtype(np.uint32) else:            left = uintp            right = np.dtype(np.ulonglong)        assert_(left == right)        assert_(hash(left) == hash(right))
 def test_invalid_types(self): # Make sure invalid type strings raise an error
        assert_raises(TypeError, np.dtype, 'O3')        assert_raises(TypeError, np.dtype, 'O5')        assert_raises(TypeError, np.dtype, 'O7')        assert_raises(TypeError, np.dtype, 'b3')        assert_raises(TypeError, np.dtype, 'h4')        assert_raises(TypeError, np.dtype, 'I5')        assert_raises(TypeError, np.dtype, 'e3')        assert_raises(TypeError, np.dtype, 'f5')
 if np.dtype('g').itemsize == 8 or np.dtype('g').itemsize == 16:            assert_raises(TypeError, np.dtype, 'g12') elif np.dtype('g').itemsize == 12:            assert_raises(TypeError, np.dtype, 'g16')
 if np.dtype('l').itemsize == 8:            assert_raises(TypeError, np.dtype, 'l4')            assert_raises(TypeError, np.dtype, 'L4') else:            assert_raises(TypeError, np.dtype, 'l8')            assert_raises(TypeError, np.dtype, 'L8')
 if np.dtype('q').itemsize == 8:            assert_raises(TypeError, np.dtype, 'q4')            assert_raises(TypeError, np.dtype, 'Q4') else:            assert_raises(TypeError, np.dtype, 'q8')            assert_raises(TypeError, np.dtype, 'Q8')
 def test_bad_param(self): # Can't give a size that's too small        assert_raises(ValueError, np.dtype,                        {'names':['f0', 'f1'], 'formats':['i4', 'i1'], 'offsets':[0, 4], 'itemsize':4}) # If alignment is enabled, the alignment (4) must divide the itemsize        assert_raises(ValueError, np.dtype,                        {'names':['f0', 'f1'], 'formats':['i4', 'i1'], 'offsets':[0, 4], 'itemsize':9}, align=True) # If alignment is enabled, the individual fields must be aligned        assert_raises(ValueError, np.dtype,                        {'names':['f0', 'f1'], 'formats':['i1', 'f4'], 'offsets':[0, 2]}, align=True)
 def test_field_order_equality(self):        x = np.dtype({'names': ['A', 'B'],  'formats': ['i4', 'f4'],  'offsets': [0, 4]})        y = np.dtype({'names': ['B', 'A'],  'formats': ['f4', 'i4'],  'offsets': [4, 0]})        assert_equal(x == y, False)
class TestRecord(object): def test_equivalent_record(self):",,
iter_struct_object_dtypes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py,     Iterates over a few complex dtypes and object pattern which    fill the array with a given object (defaults to a singleton).    Yields    ------    dtype : dtype    pattern : tuple        Structured tuple for use with `np.array`.    count : int        Number of objects stored in the dtype.    singleton : object        A singleton object. The returned pattern is constructed so that        all objects inside the datatype are set to the singleton.,,
test_rational_dtype():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py,,,
test_dtypes_are_true():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_dtype.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_einsum.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
exc_iter(*args):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,"     Iterate over Cartesian product of *args, and if an exception is raised,    add information of the current iterate.",,
test_safe_binop():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_to_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_to_64():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_mul_64_64():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_add_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_sub_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_neg_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_shl_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_shr_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_gt_128():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_divmod_128_64():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
test_floordiv_128_64():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_extint128.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_getlimits.py,,,
test_instances():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_getlimits.py,,,
"assert_ma_equal(discovered, ma_like):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_getlimits.py,,,
test_known_types():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_getlimits.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_half.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_scalar_extraction():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py," Confirm that extracting a value doesn't convert to python float    o = 1 + LD_INFO.eps    a = np.array([o, o, o])    assert_equal(a[1], o)

# Conversions string -> long double
# 0.1 not exactly representable in base 2 floating point.repr_precision = len(repr(np.longdouble(0.1)))# +2 from macro block starting around line 842 in scalartypes.c.src.@pytest.mark.skipif(LD_INFO.precision + 2 >= repr_precision, reason=""repr precision not enough to show eps"")",,
test_repr_roundtrip():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_unicode():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_string():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_bytes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_repr_roundtrip_bytes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_bogus_string():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_fromstring():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_fromstring_bogus():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_fromstring_empty():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_fromstring_missing():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_repr_exact():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_format():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_percent():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_array_repr():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
test_longdouble_from_int(int_val):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_longdouble.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
_indices_for_nelems(nelems):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py," Returns slices of length nelems, from start onwards, in direction sign.
 if nelems == 0: return [size // 2]  # int index
    res = [] for step in (1, 2): for sign in (-1, 1):            start = size // 2 - nelems * step * sign // 2            stop = start + nelems * step * sign            res.append(slice(start, stop, step * sign))
 return res

",,
_indices_for_axis():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py," Returns (src, dst) pairs of indices.
    res = [] for nelems in (0, 2, 3):        ind = _indices_for_nelems(nelems)
 # no itertools.product available in Py2.4        res.extend([(a, b) for a in ind for b in ind])  # all assignments of size ""nelems""
 return res

",,
_indices(ndims):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py," Returns ((axis0_src, axis0_dst), (axis1_src, axis1_dst), ... ) index pairs.
    ind = _indices_for_axis()
 # no itertools.product available in Py2.4
    res = [[]] for i in range(ndims):        newres = [] for elem in ind: for others in res:                newres.append([elem] + others)        res = newres
 return res

",,
"_check_assignment(srcidx, dstidx):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py," Check assignment arr[dstidx] = arr[srcidx] works.
    arr = np.arange(np.product(shape)).reshape(shape)
    cpy = arr.copy()
    cpy[dstidx] = arr[srcidx]    arr[dstidx] = arr[srcidx]
    assert_(np.all(arr == cpy), 'assigning arr[%s] = arr[%s]' % (dstidx, srcidx))

",,
test_overlapping_assignments():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_diophantine_fuzz():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_diophantine_overflow():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
"check_may_share_memory_exact(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_may_share_memory_manual():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
"iter_random_view_pairs(x, same_steps=True, equal_size=False):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
"check_may_share_memory_easy_fuzz(get_max_work, same_steps, min_count):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_may_share_memory_easy_fuzz():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_may_share_memory_harder_fuzz():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_shares_memory_api():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_may_share_memory_bad_max_work():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_internal_overlap_diophantine():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_internal_overlap_slices():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
"check_internal_overlap(a, manual_expected=None):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_internal_overlap_manual():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_internal_overlap_fuzz():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
test_non_ndarray_inputs():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py,,,
view_element_first_byte(x):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_mem_overlap.py," Construct an array viewing the first byte of each element of `x` from numpy.lib.stride_tricks import DummyArray    interface = dict(x.__array_interface__)    interface['typestr'] = '|b1'    interface['descr'] = [('', '|b1')] return np.asarray(DummyArray(interface, x))

",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
"_aligned_zeros(shape, dtype=float, order=""C"", align=None):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,"     Allocate a new ndarray with aligned memory.    The ndarray is guaranteed *not* aligned to twice the requested alignment.    Eg, if align=4, guarantees it is not aligned to 8. If align=None uses",,
"_mean(a, **args):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
"_var(a, **args):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
"_std(a, **args):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py, Common tests for '@' operator and numpy.matmul.,,
test_interface_no_shape():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_array_interface_itemsize():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_array_interface_empty_shape():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_array_interface_offset():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_flat_element_deletion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_scalar_element_deletion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,"  Tests __array_finalize__ 
 def test_receives_base(self): # gh-11237 class SavesBase(np.ndarray): def __array_finalize__(self, obj): self.saved_base = self.base
        a = np.array(1).view(SavesBase)        assert_(a.saved_base is a.base)
 def test_lifetime_on_error(self): # gh-11237 class RaisesInFinalize(np.ndarray): def __array_finalize__(self, obj): # crash, but keep this object alive raise Exception(self)
 # a plain object can't be weakref'd class Dummy(object): pass
 # get a weak reference to an object within an array        obj_arr = np.array(Dummy())        obj_ref = weakref.ref(obj_arr[()])
 # get an array that crashed in __array_finalize__ with assert_raises(Exception) as e:            obj_arr.view(RaisesInFinalize) if sys.version_info.major == 2: # prevent an extra reference being kept            sys.exc_clear()
        obj_subarray = e.exception.args[0] del e        assert_(isinstance(obj_subarray, RaisesInFinalize))
 # reference should still be held by obj_arr        break_cycles()        assert_(obj_ref() is not None, ""object should not already be dead"")
 del obj_arr        break_cycles()        assert_(obj_ref() is not None, ""obj_arr should not hold the last reference"")
 del obj_subarray        break_cycles()        assert_(obj_ref() is None, ""no references should remain"")

",,
test_orderconverter_with_nonASCII_unicode_ordering():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_equal_override():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_npymath_complex():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_npymath_real():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
test_uintalignment_and_alignment():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_multiarray.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
iter_multi_index(i):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
iter_indices(i):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
iter_iterindices(i):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_refcount():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_c_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_f_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_c_or_f_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_multi_index_1d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_multi_index_2d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_multi_index_3d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_c_index_1d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_c_index_2d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_c_index_3d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_f_index_1d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_f_index_2d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_best_order_f_index_3d():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_no_inner_full_coalesce():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_no_inner_dim_coalescing():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_dim_coalescing():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_broadcasting():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_itershape():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_broadcasting_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_flags_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_slice():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_assign_mapping():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_nbo_align_contig():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_array_cast():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_array_cast_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_scalar_cast():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_scalar_cast_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_object_arrays_basic():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_object_arrays_conversions():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_common_dtype():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_copy_if_overlap():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_op_axes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_op_axes_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_copy():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_simple():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_buffered_readwrite():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_itorder():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_opaxes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_types_promotion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_types_byte_order():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_types_scalar():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_subtype():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocate_output_errors():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_remove_axis():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_remove_multi_index_inner_loop():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_iterindex():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_iterrange():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_write_buffering():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_delayed_alloc():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_cast_simple():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_cast_byteswapped():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_cast_byteswapped_complex():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_cast_structured_type():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_cast_subarray():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_badwriteback():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_string():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_growinner():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffered_reduce_reuse():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_no_broadcast():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_reduction_error():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_reduction():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_reduction():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_buffering_reduction_reuse_reduce_loops():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_writemasked_badinput():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_writemasked():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_non_writable_attribute_deletion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_writable_attribute_deletion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_element_deletion():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_allocated_array_dtypes():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_0d_iter():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_too_large():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_iter_too_large_with_multiindex():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_writebacks():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_close_equivalent():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
test_close_raises():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_nditer.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_numeric.py,,,
"assert_array_strict_equal(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_numeric.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_numerictypes.py,,,
normalize_descr(descr):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_numerictypes.py," Check the creation of heterogeneous arrays zero-valued
 def test_zeros0D(self):",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_overrides.py,,,
"_return_not_implemented(self, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_overrides.py,,,
dispatched_one_arg(array):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_overrides.py," Docstring. return 'original'

@array_function_dispatch(lambda array1, array2: (array1, array2))",,
"dispatched_two_arg(array1, array2):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_overrides.py," Docstring. return 'original'

class TestGetImplementingArgs(object):
 def test_ndarray(self):        array = np.array(1)
        args = _get_implementing_args([array])        assert_equal(list(args), [array])
        args = _get_implementing_args([array, array])        assert_equal(list(args), [array])
        args = _get_implementing_args([array, 1])        assert_equal(list(args), [array])
        args = _get_implementing_args([1, array])        assert_equal(list(args), [array])
 def test_ndarray_subclasses(self):
 class OverrideSub(np.ndarray):            __array_function__ = _return_not_implemented
 class NoOverrideSub(np.ndarray): pass
        array = np.array(1).view(np.ndarray)        override_sub = np.array(1).view(OverrideSub)        no_override_sub = np.array(1).view(NoOverrideSub)
        args = _get_implementing_args([array, override_sub])        assert_equal(list(args), [override_sub, array])
        args = _get_implementing_args([array, no_override_sub])        assert_equal(list(args), [no_override_sub, array])
        args = _get_implementing_args(            [override_sub, no_override_sub])        assert_equal(list(args), [override_sub, no_override_sub])
 def test_ndarray_and_duck_array(self):
 class Other(object):            __array_function__ = _return_not_implemented
        array = np.array(1)        other = Other()
        args = _get_implementing_args([other, array])        assert_equal(list(args), [other, array])
        args = _get_implementing_args([array, other])        assert_equal(list(args), [array, other])
 def test_ndarray_subclass_and_duck_array(self):
 class OverrideSub(np.ndarray):            __array_function__ = _return_not_implemented
 class Other(object):            __array_function__ = _return_not_implemented
        array = np.array(1)        subarray = np.array(1).view(OverrideSub)        other = Other()
        assert_equal(_get_implementing_args([array, subarray, other]),                     [subarray, array, other])        assert_equal(_get_implementing_args([array, other, subarray]),                     [subarray, array, other])
 def test_many_duck_arrays(self):
 class A(object):            __array_function__ = _return_not_implemented
 class B(A):            __array_function__ = _return_not_implemented
 class C(A):            __array_function__ = _return_not_implemented
 class D(object):            __array_function__ = _return_not_implemented
        a = A()        b = B()        c = C()        d = D()
        assert_equal(_get_implementing_args([1]), [])        assert_equal(_get_implementing_args([a]), [a])        assert_equal(_get_implementing_args([a, 1]), [a])        assert_equal(_get_implementing_args([a, a, a]), [a])        assert_equal(_get_implementing_args([a, d, a]), [a, d])        assert_equal(_get_implementing_args([a, b]), [b, a])        assert_equal(_get_implementing_args([b, a]), [b, a])        assert_equal(_get_implementing_args([a, b, c]), [b, c, a])        assert_equal(_get_implementing_args([a, c, b]), [c, b, a])
 def test_too_many_duck_arrays(self):        namespace = dict(__array_function__=_return_not_implemented)        types = [type('A' + str(i), (object,), namespace) for i in range(33)]        relevant_args = [t() for t in types]
        actual = _get_implementing_args(relevant_args[:32])        assert_equal(actual, relevant_args[:32])
 with assert_raises_regex(TypeError, 'distinct argument types'):            _get_implementing_args(relevant_args)

class TestNDArrayArrayFunction(object):
 @requires_array_function def test_method(self):
 class Other(object):            __array_function__ = _return_not_implemented
 class NoOverrideSub(np.ndarray): pass
 class OverrideSub(np.ndarray):            __array_function__ = _return_not_implemented
        array = np.array([1])        other = Other()        no_override_sub = array.view(NoOverrideSub)        override_sub = array.view(OverrideSub)
        result = array.__array_function__(func=dispatched_two_arg, types=(np.ndarray,), args=(array, 1.), kwargs={})        assert_equal(result, 'original')
        result = array.__array_function__(func=dispatched_two_arg, types=(np.ndarray, Other), args=(array, other), kwargs={})        assert_(result is NotImplemented)
        result = array.__array_function__(func=dispatched_two_arg, types=(np.ndarray, NoOverrideSub), args=(array, no_override_sub), kwargs={})        assert_equal(result, 'original')
        result = array.__array_function__(func=dispatched_two_arg, types=(np.ndarray, OverrideSub), args=(array, override_sub), kwargs={})        assert_equal(result, 'original')
 with assert_raises_regex(TypeError, 'no implementation found'):            np.concatenate((array, other))
        expected = np.concatenate((array, array))        result = np.concatenate((array, no_override_sub))        assert_equal(result, expected.view(NoOverrideSub))        result = np.concatenate((array, override_sub))        assert_equal(result, expected.view(OverrideSub))
 def test_no_wrapper(self): # This shouldn't happen unless a user intentionally calls # __array_function__ with invalid arguments, but check that we raise # an appropriate error all the same.        array = np.array(1)        func = lambda x: x with assert_raises_regex(AttributeError, '_implementation'):            array.__array_function__(func=func, types=(np.ndarray,), args=(array,), kwargs={})

@requires_array_functionclass TestArrayFunctionDispatch(object):
 def test_pickle(self): for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):            roundtripped = pickle.loads(                    pickle.dumps(dispatched_one_arg, protocol=proto))            assert_(roundtripped is dispatched_one_arg)
 def test_name_and_docstring(self):        assert_equal(dispatched_one_arg.__name__, 'dispatched_one_arg') if sys.flags.optimize < 2:            assert_equal(dispatched_one_arg.__doc__, 'Docstring.')
 def test_interface(self):
 class MyArray(object): def __array_function__(self, func, types, args, kwargs): return (self, func, types, args, kwargs)
        original = MyArray()        (obj, func, types, args, kwargs) = dispatched_one_arg(original)        assert_(obj is original)        assert_(func is dispatched_one_arg)        assert_equal(set(types), {MyArray}) # assert_equal uses the overloaded np.iscomplexobj() internally        assert_(args == (original,))        assert_equal(kwargs, {})
 def test_not_implemented(self):
 class MyArray(object): def __array_function__(self, func, types, args, kwargs): return NotImplemented
        array = MyArray() with assert_raises_regex(TypeError, 'no implementation found'):            dispatched_one_arg(array)

@requires_array_functionclass TestVerifyMatchingSignatures(object):
 def test_verify_matching_signatures(self):
        verify_matching_signatures(lambda x: 0, lambda x: 0)        verify_matching_signatures(lambda x=None: 0, lambda x=None: 0)        verify_matching_signatures(lambda x=1: 0, lambda x=None: 0)
 with assert_raises(RuntimeError):            verify_matching_signatures(lambda a: 0, lambda b: 0) with assert_raises(RuntimeError):            verify_matching_signatures(lambda x: 0, lambda x=None: 0) with assert_raises(RuntimeError):            verify_matching_signatures(lambda x=None: 0, lambda y=None: 0) with assert_raises(RuntimeError):            verify_matching_signatures(lambda x=1: 0, lambda y=1: 0)
 def test_array_function_dispatch(self):
 with assert_raises(RuntimeError): @array_function_dispatch(lambda x: (x,)) def f(y): pass
 # should not raise @array_function_dispatch(lambda x: (x,), verify=False) def f(y): pass

",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py,,,
test_float_types(tp):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py,"  Check formatting.        This is only for the str function, and only for simple types.        The precision of np.float32 and np.longdouble aren't the same as the        python float precision.",,
test_nan_inf_float(tp):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py,"  Check formatting of nan & inf.        This is only for the str function, and only for simple types.        The precision of np.float32 and np.longdouble aren't the same as the        python float precision.",,
test_complex_types(tp):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py," Check formatting of complex types.        This is only for the str function, and only for simple types.        The precision of np.float32 and np.longdouble aren't the same as the        python float precision.",,
test_complex_inf_nan(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py," Check inf/nan formatting of complex types. TESTS = { complex(np.inf, 0): ""(inf+0j)"", complex(0, np.inf): ""infj"", complex(-np.inf, 0): ""(-inf+0j)"", complex(0, -np.inf): ""-infj"", complex(np.inf, 1): ""(inf+1j)"", complex(1, np.inf): ""(1+infj)"", complex(-np.inf, 1): ""(-inf+1j)"", complex(1, -np.inf): ""(1-infj)"", complex(np.nan, 0): ""(nan+0j)"", complex(0, np.nan): ""nanj"", complex(-np.nan, 0): ""(nan+0j)"", complex(0, -np.nan): ""nanj"", complex(np.nan, 1): ""(nan+1j)"", complex(1, np.nan): ""(1+nanj)"", complex(-np.nan, 1): ""(nan+1j)"", complex(1, -np.nan): ""(1+nanj)"",    } for c, s in TESTS.items():        assert_equal(str(dtype(c)), s)

# print tests",,
"_test_redirected_print(x, tp, ref=None):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py,,,
test_float_type_print(tp):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py," Check formatting when using print  for x in [0, 1, -1, 1e20]:        _test_redirected_print(float(x), tp)
 for x in [np.inf, -np.inf, np.nan]:        _test_redirected_print(float(x), tp, _REF[x])
 if tp(1e16).itemsize > 4:        _test_redirected_print(float(1e16), tp) else:        ref = '1e+16'        _test_redirected_print(float(1e16), tp, ref)

@pytest.mark.parametrize('tp', [np.complex64, np.cdouble, np.clongdouble])",,
test_complex_type_print(tp):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_print.py," Check formatting when using print  # We do not create complex with inf/nan directly because the feature is # missing in python < 2.6 for x in [0, 1, -1, 1e20]:        _test_redirected_print(complex(x), tp)
 if tp(1e16).itemsize > 8:        _test_redirected_print(complex(1e16), tp) else:        ref = '(1e+16+0j)'        _test_redirected_print(complex(1e16), tp, ref)
    _test_redirected_print(complex(np.inf, 1), tp, '(inf+1j)')    _test_redirected_print(complex(-np.inf, 1), tp, '(-inf+1j)')    _test_redirected_print(complex(-np.nan, 1), tp, '(nan+1j)')

",,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_records.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_scalarmath.py,,,
"floordiv_and_mod(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_scalarmath.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_shape_base.py,,,
test_stack():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_shape_base.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_ufunc.py," Test generic loops.    The loops to be tested are:        PyUFunc_ff_f_As_dd_d        PyUFunc_ff_f        PyUFunc_dd_d        PyUFunc_gg_g        PyUFunc_FF_F_As_DD_D        PyUFunc_DD_D        PyUFunc_FF_F        PyUFunc_GG_G        PyUFunc_OO_O        PyUFunc_OO_O_method        PyUFunc_f_f_As_d_d        PyUFunc_d_d        PyUFunc_f_f        PyUFunc_g_g        PyUFunc_F_F_As_D_D        PyUFunc_F_F        PyUFunc_D_D        PyUFunc_G_G        PyUFunc_O_O        PyUFunc_O_O_method        PyUFunc_On_Om    Where:        f -- float        d -- double        g -- long double        F -- complex float        D -- complex double        G -- complex long double        O -- python object    It is difficult to assure that each of these loops is entered from the    Python level as the special cased loops are a moving target and the    corresponding types are architecture dependent. We probably need to    define C level testing ufuncs to get at them. For the time being, I've    just looked at the signatures registered in the build directory to find    relevant functions.",,
test_ufunc_types(ufunc):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_ufunc.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
on_powerpc():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,"  True if we are running on a Power PC platform. return platform.processor() == 'powerpc' or \           platform.machine().startswith('ppc')

class _FilterInvalids(object): def setup(self): self.olderr = np.seterr(invalid='ignore')
 def teardown(self):        np.seterr(**self.olderr)

class TestConstants(object): def test_pi(self):        assert_allclose(ncu.pi, 3.141592653589793, 1e-15)
 def test_e(self):        assert_allclose(ncu.e, 2.718281828459045, 1e-15)
 def test_euler_gamma(self):        assert_allclose(ncu.euler_gamma, 0.5772156649015329, 1e-15)

class TestOut(object): def test_out_subok(self): for subok in (True, False):            a = np.array(0.5)            o = np.empty(())
            r = np.add(a, 2, o, subok=subok)            assert_(r is o)            r = np.add(a, 2, out=o, subok=subok)            assert_(r is o)            r = np.add(a, 2, out=(o,), subok=subok)            assert_(r is o)
            d = np.array(5.7)            o1 = np.empty(())            o2 = np.empty((), dtype=np.int32)
            r1, r2 = np.frexp(d, o1, None, subok=subok)            assert_(r1 is o1)            r1, r2 = np.frexp(d, None, o2, subok=subok)            assert_(r2 is o2)            r1, r2 = np.frexp(d, o1, o2, subok=subok)            assert_(r1 is o1)            assert_(r2 is o2)
            r1, r2 = np.frexp(d, out=(o1, None), subok=subok)            assert_(r1 is o1)            r1, r2 = np.frexp(d, out=(None, o2), subok=subok)            assert_(r2 is o2)            r1, r2 = np.frexp(d, out=(o1, o2), subok=subok)            assert_(r1 is o1)            assert_(r2 is o2)
 with warnings.catch_warnings(record=True) as w:                warnings.filterwarnings('always', '', DeprecationWarning)                r1, r2 = np.frexp(d, out=o1, subok=subok)                assert_(r1 is o1)                assert_(w[0].category is DeprecationWarning)
            assert_raises(ValueError, np.add, a, 2, o, o, subok=subok)            assert_raises(ValueError, np.add, a, 2, o, out=o, subok=subok)            assert_raises(ValueError, np.add, a, 2, None, out=o, subok=subok)            assert_raises(ValueError, np.add, a, 2, out=(o, o), subok=subok)            assert_raises(ValueError, np.add, a, 2, out=(), subok=subok)            assert_raises(TypeError, np.add, a, 2, [], subok=subok)            assert_raises(TypeError, np.add, a, 2, out=[], subok=subok)            assert_raises(TypeError, np.add, a, 2, out=([],), subok=subok)            o.flags.writeable = False            assert_raises(ValueError, np.add, a, 2, o, subok=subok)            assert_raises(ValueError, np.add, a, 2, out=o, subok=subok)            assert_raises(ValueError, np.add, a, 2, out=(o,), subok=subok)
 def test_out_wrap_subok(self): class ArrayWrap(np.ndarray):            __array_priority__ = 10
 def __new__(cls, arr): return np.asarray(arr).view(cls).copy()
 def __array_wrap__(self, arr, context): return arr.view(type(self))
 for subok in (True, False):            a = ArrayWrap([0.5])
            r = np.add(a, 2, subok=subok) if subok:                assert_(isinstance(r, ArrayWrap)) else:                assert_(type(r) == np.ndarray)
            r = np.add(a, 2, None, subok=subok) if subok:                assert_(isinstance(r, ArrayWrap)) else:                assert_(type(r) == np.ndarray)
            r = np.add(a, 2, out=None, subok=subok) if subok:                assert_(isinstance(r, ArrayWrap)) else:                assert_(type(r) == np.ndarray)
            r = np.add(a, 2, out=(None,), subok=subok) if subok:                assert_(isinstance(r, ArrayWrap)) else:                assert_(type(r) == np.ndarray)
            d = ArrayWrap([5.7])            o1 = np.empty((1,))            o2 = np.empty((1,), dtype=np.int32)
            r1, r2 = np.frexp(d, o1, subok=subok) if subok:                assert_(isinstance(r2, ArrayWrap)) else:                assert_(type(r2) == np.ndarray)
            r1, r2 = np.frexp(d, o1, None, subok=subok) if subok:                assert_(isinstance(r2, ArrayWrap)) else:                assert_(type(r2) == np.ndarray)
            r1, r2 = np.frexp(d, None, o2, subok=subok) if subok:                assert_(isinstance(r1, ArrayWrap)) else:                assert_(type(r1) == np.ndarray)
            r1, r2 = np.frexp(d, out=(o1, None), subok=subok) if subok:                assert_(isinstance(r2, ArrayWrap)) else:                assert_(type(r2) == np.ndarray)
            r1, r2 = np.frexp(d, out=(None, o2), subok=subok) if subok:                assert_(isinstance(r1, ArrayWrap)) else:                assert_(type(r1) == np.ndarray)
 with warnings.catch_warnings(record=True) as w:                warnings.filterwarnings('always', '', DeprecationWarning)                r1, r2 = np.frexp(d, out=o1, subok=subok) if subok:                    assert_(isinstance(r2, ArrayWrap)) else:                    assert_(type(r2) == np.ndarray)                assert_(w[0].category is DeprecationWarning)

class TestComparisons(object): def test_ignore_object_identity_in_equal(self): # Check error raised when comparing identical objects whose comparison # is not a simple boolean, e.g., arrays that are compared elementwise.        a = np.array([np.array([1, 2, 3]), None], dtype=object)        assert_raises(ValueError, np.equal, a, a)
 # Check error raised when comparing identical non-comparable objects. class FunkyType(object): def __eq__(self, other): raise TypeError(""I won't compare"")
        a = np.array([FunkyType()])        assert_raises(TypeError, np.equal, a, a)
 # Check identity doesn't override comparison mismatch.        a = np.array([np.nan], dtype=object)        assert_equal(np.equal(a, a), [False])
 def test_ignore_object_identity_in_not_equal(self): # Check error raised when comparing identical objects whose comparison # is not a simple boolean, e.g., arrays that are compared elementwise.        a = np.array([np.array([1, 2, 3]), None], dtype=object)        assert_raises(ValueError, np.not_equal, a, a)
 # Check error raised when comparing identical non-comparable objects. class FunkyType(object): def __ne__(self, other): raise TypeError(""I won't compare"")
        a = np.array([FunkyType()])        assert_raises(TypeError, np.not_equal, a, a)
 # Check identity doesn't override comparison mismatch.        a = np.array([np.nan], dtype=object)        assert_equal(np.not_equal(a, a), [True])

class TestAdd(object): def test_reduce_alignment(self): # gh-9876 # make sure arrays with weird strides work with the optimizations in # pairwise_sum_@TYPE@. On x86, the 'b' field will count as aligned at a # 4 byte offset, even though its itemsize is 8.        a = np.zeros(2, dtype=[('a', np.int32), ('b', np.float64)])        a['a'] = -1        assert_equal(a['b'].sum(), 0)

class TestDivision(object): def test_division_int(self): # int division should follow Python        x = np.array([5, 10, 90, 100, -5, -10, -90, -100, -120]) if 5 / 10 == 0.5:            assert_equal(x / 100, [0.05, 0.1, 0.9, 1, -0.05, -0.1, -0.9, -1, -1.2]) else:            assert_equal(x / 100, [0, 0, 0, 1, -1, -1, -1, -1, -2])        assert_equal(x // 100, [0, 0, 0, 1, -1, -1, -1, -1, -2])        assert_equal(x % 100, [5, 10, 90, 0, 95, 90, 10, 0, 80])
 def test_division_complex(self): # check that implementation is correct        msg = ""Complex division implementation check""        x = np.array([1. + 1.*1j, 1. + .5*1j, 1. + 2.*1j], dtype=np.complex128)        assert_almost_equal(x**2/x, x, err_msg=msg) # check overflow, underflow        msg = ""Complex division overflow/underflow check""        x = np.array([1.e+110, 1.e-110], dtype=np.complex128)        y = x**2/x        assert_almost_equal(y/x, [1, 1], err_msg=msg)
 def test_zero_division_complex(self): with np.errstate(invalid=""ignore"", divide=""ignore""):            x = np.array([0.0], dtype=np.complex128)            y = 1.0/x            assert_(np.isinf(y)[0])            y = complex(np.inf, np.nan)/x            assert_(np.isinf(y)[0])            y = complex(np.nan, np.inf)/x            assert_(np.isinf(y)[0])            y = complex(np.inf, np.inf)/x            assert_(np.isinf(y)[0])            y = 0.0/x            assert_(np.isnan(y)[0])
 def test_floor_division_complex(self): # check that implementation is correct        msg = ""Complex floor division implementation check""        x = np.array([.9 + 1j, -.1 + 1j, .9 + .5*1j, .9 + 2.*1j], dtype=np.complex128)        y = np.array([0., -1., 0., 0.], dtype=np.complex128)        assert_equal(np.floor_divide(x**2, x), y, err_msg=msg) # check overflow, underflow        msg = ""Complex floor division overflow/underflow check""        x = np.array([1.e+110, 1.e-110], dtype=np.complex128)        y = np.floor_divide(x**2, x)        assert_equal(y, [1.e+110, 0], err_msg=msg)
 def test_floor_division_signed_zero(self): # Check that the sign bit is correctly set when dividing positive and # negative zero by one.        x = np.zeros(10)        assert_equal(np.signbit(x//1), 0)        assert_equal(np.signbit((-x)//1), 1)
",,
"floor_divide_and_remainder(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
_signs(dt):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_hypot_isnan(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_hypot_isinf(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_arctan2_isnan(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_arctan2_ispinf(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_arctan2_isninf(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_arctan2_ispzero(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
"assert_arctan2_isnzero(x, y):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,"  test direct implementation of these magic methods  class C: def __floor__(self): return 1 def __ceil__(self): return 2 def __trunc__(self): return 3
        arr = np.array([C(), C()])        assert_equal(np.floor(arr), [1, 1])        assert_equal(np.ceil(arr),  [2, 2])        assert_equal(np.trunc(arr), [3, 3])
 def test_object_indirect(self):",,
"_check_branch_cut(f, x0, dx, re_sign=1, im_sign=-1, sig_zero_ok=False,",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,     Check for a branch cut in a function.    Assert that `x0` lies on a branch cut of function `f` and `f` is    continuous from the direction `dx`.,"f : func        Function to check    x0 : array-like        Point on branch cut    dx : array-like        Direction to check continuity in    re_sign, im_sign : {1, -1}        Change of sign of the real or imaginary part expected    sig_zero_ok : bool        Whether to check if the branch cut respects signed zero (if applicable)    dtype : dtype        Dtype to check (should be complex)",
test_copysign():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
_test_nextafter(t):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_nextafter():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_nextafterf():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_nextafterl():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_nextafter_0():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
_test_spacing(t):,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_spacing():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_spacingf():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_spacingl():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_spacing_gfortran():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_nextafter_vs_spacing():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_pos_nan():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py," Check np.nan is a positive nan.    assert_(np.signbit(np.nan) == 0)
",,
test_reduceat():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py," Test bug in reduceat when structured arrays are not copied.    db = np.dtype([('name', 'S11'), ('time', np.int64), ('value', np.float32)])    a = np.empty([100], dtype=db)    a['name'] = 'Simple'    a['time'] = 10    a['value'] = 100    indx = [0, 7, 15, 25]
    h2 = []    val1 = indx[0] for val2 in indx[1:]:        h2.append(np.add.reduce(a['value'][val1:val2]))        val1 = val2    h2.append(np.add.reduce(a['value'][val1:]))    h2 = np.array(h2)
 # test buffered -- this should work    h1 = np.add.reduceat(a['value'], indx)    assert_array_almost_equal(h1, h2)
 # This is when the error occurs. # test no buffer    np.setbufsize(32)    h1 = np.add.reduceat(a['value'], indx)    np.setbufsize(np.UFUNC_BUFSIZE_DEFAULT)    assert_array_almost_equal(h1, h2)
",,
test_reduceat_empty():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py," Reduceat should work with empty arrays    indices = np.array([], 'i4')    x = np.array([], 'f8')    result = np.add.reduceat(x, indices)    assert_equal(result.dtype, x.dtype)    assert_equal(result.shape, (0,)) # Another case with a slightly different zero-sized shape    x = np.ones((5, 2))    result = np.add.reduceat(x, [], axis=0)    assert_equal(result.dtype, x.dtype)    assert_equal(result.shape, (0, 2))    result = np.add.reduceat(x, [], axis=1)    assert_equal(result.dtype, x.dtype)    assert_equal(result.shape, (5, 0))
",,
test_complex_nan_comparisons():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_rint_big_int():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
test_signaling_nan_exceptions():,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath_complex.py,,,
"check_real_value(f, x1, y1, x, exact=True):",https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_umath_complex.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/tests/test_unicode.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/__init__.py,,,
"_ufunc_reconstruct(module, name):",https://github.com//numpy/numpy/blob/master/numpy/core/__init__.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_add_newdocs.py,"This is only meant to add docs to objects defined in C-extension modules.The purpose is to allow easier editing of the docstrings withoutrequiring a re-compile.NOTE: Many of the methods of ndarray have corresponding functions.      If you update these docstrings, please keep also the ones in      core/fromnumeric.py, core/defmatrix.py up-to-date.","op : ndarray or sequence of array_like        The array(s) to iterate over.op : ndarray or sequence of array_like        The array(s) to iterate over.in1, in2, ... : array_like        Input parameters.Noneobject : array_like        An array, any object exposing the array interface, an object whose        __array__ method returns an array, or any (nested) sequence.    dtype : data-type, optional        The desired data-type for the array.  If not given, then the type will        be determined as the minimum type required to hold the objects in the        sequence.  This argument can only be used to 'upcast' the array.  For        downcasting, use the .astype(t) method.    copy : bool, optional        If true (default), then the object is copied.  Otherwise, a copy will        only be made if __array__ returns a copy, if obj is a nested sequence,        or if a copy is needed to satisfy any of the other requirements        (`dtype`, `order`, etc.).    order : {'K', 'A', 'C', 'F'}, optional        Specify the memory layout of the array. If object is not an array, the        newly created array will be in C order (row major) unless 'F' is        specified, in which case it will be in Fortran order (column major).        If object is an array the following holds.shape : int or tuple of int        Shape of the empty array, e.g., ``(2, 3)`` or ``2``.    dtype : data-type, optional        Desired output data-type for the array, e.g, `numpy.int8`. Default is        `numpy.float64`.    order : {'C', 'F'}, optional, default: 'C'        Whether to store multi-dimensional data in row-major        (C-style) or column-major (Fortran-style) order in        memory.shape : int or tuple of ints        Shape of the new array, e.g., ``(2, 3)`` or ``2``.    dtype : data-type, optional        The desired data-type for the array, e.g., `numpy.int8`.  Default is        `numpy.float64`.    order : {'C', 'F'}, optional, default: 'C'        Whether to store multi-dimensional data in row-major        (C-style) or column-major (Fortran-style) order in        memory.string : str        A string containing the data.    dtype : data-type, optional        The data type of the array; default: float.  For binary input data,        the data must be in exactly this format.    count : int, optional        Read this number of `dtype` elements from the data.  If this is        negative (the default), the count will be determined from the        length of the data.    sep : str, optional        The string separating numbers in the data; extra whitespace between        elements is also ignored.a, b : array_like        Arrays to be compared.    cmp_op : {""<"", ""<="", ""=="", "">="", "">"", ""!=""}        Type of comparison.    rstrip : Boolean        If True, the spaces at the end of Strings are removed before the comparison.iterable : iterable object        An iterable object providing data for the array.    dtype : data-type        The data-type of the returned array.    count : int, optional        The number of items to read from *iterable*.  The default is -1,        which means all data is read.file : file or str or Path        Open file object or filename.buffer : buffer_like        An object that exposes the buffer interface.    dtype : data-type, optional        Data-type of the returned array; default: float.    count : int, optional        Number of items to read. ``-1`` means all data in the buffer.    offset : int, optional        Start reading the buffer from this offset (in bytes); default: 0.start : number, optional        Start of interval.  The interval includes this value.  The default        start value is 0.    stop : number        End of interval.  The interval does not include this value, except        in some cases where `step` is not an integer and floating point        round-off affects the length of `out`.    step : number, optional        Spacing between values.  For any output `out`, this is the distance        between two adjacent values, ``out[i+1] - out[i]``.  The default        step size is 1.  If `step` is specified as a position argument,        `start` must also be given.    dtype : dtype        The type of the output array.  If `dtype` is not given, infer the data        type from the other input arguments.op1, op2, ... : callable        Each ``op = func`` pair describes an operator to be replaced.        For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace        addition by modulus 5 addition.type1 : dtype or dtype specifier        First data type.    type2 : dtype or dtype specifier        Second data type.size : int        Size in bytes of returned buffer object.obj : objectsubscripts : str        Specifies the subscripts for summation as comma separated list of        subscript labels. An implicit (classical Einstein summation)        calculation is performed unless the explicit indicator '->' is        included as well as subscript labels of the precise output form.    operands : list of array_like        These are the arrays for the operation.    out : ndarray, optional        If provided, the calculation is done into this array.    dtype : {data-type, None}, optional        If provided, forces the calculation to use the data type specified.        Note that you may have to also give a more liberal `casting`        parameter to allow the conversions. Default is None.    order : {'C', 'F', 'A', 'K'}, optional        Controls the memory layout of the output. 'C' means it should        be C contiguous. 'F' means it should be Fortran contiguous,        'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.        'K' means it should be as close to the layout as the inputs as        is possible, including arbitrarily permuted axes.        Default is 'K'.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        Controls what kind of data casting may occur.  Setting this to        'unsafe' is not recommended, as it can adversely affect accumulations.(for the __new__ method; see Notes below)NoneNoneversion : int        optional pickle version. If omitted defaults to 0.    shape : tuple    dtype : data-type    isFortran : bool    rawdata : string or list        a binary string with the data (or a list if 'a' is an object array)dtype : str or dtype        Typecode or data-type to which the array is cast.    order : {'C', 'F', 'A', 'K'}, optional        Controls the memory layout order of the result.        'C' means C order, 'F' means Fortran order, 'A'        means 'F' order if all the arrays are Fortran contiguous,        'C' order otherwise, and 'K' means as close to the        order the array elements appear in memory as possible.        Default is 'K'.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        Controls what kind of data casting may occur. Defaults to 'unsafe'        for backwards compatibility.inplace : bool, optional        If ``True``, swap bytes in-place, default is ``False``.order : {'C', 'F', 'A', 'K'}, optional        Controls the memory layout of the copy. 'C' means C-order,        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,        'C' otherwise. 'K' means match the layout of `a` as closely        as possible. (Note that this function and :func:`numpy.copy` are very        similar, but have different default values for their order=        arguments.)file : str or Path        A string naming the dump file.Nonevalue : scalar        All elements of `a` will be assigned this value.order : {'C', 'F', 'A', 'K'}, optional        'C' means to flatten in row-major (C-style) order.        'F' means to flatten in column-major (Fortran-        style) order. 'A' means to flatten in column-major        order if `a` is Fortran *contiguous* in memory,        row-major order otherwise. 'K' means to flatten        `a` in the order the elements occur in memory.        The default is 'C'.dtype : str or dtype        The data type of the view. The dtype size of the view can not be larger        than that of the array itself.    offset : int        Number of bytes to skip before beginning the element view.    Parameters    ---------- \\*args : Arguments (variable number and type)    Parameters    ---------- \\*args : Arguments        If one argument: a scalar, only used in case `a` is of size 1.        If two arguments: the last argument is the value to be set        and must be a scalar, the first argument specifies a single array        element location. It is either an int or a tuple.a, b : ndarray        Input arrays    max_work : int, optional        Effort to spend on solving the overlap problem (maximum number        of candidate solutions to consider). The following special        values are recognized:a, b : ndarray        Input arrays    max_work : int, optional        Effort to spend on solving the overlap problem.  See        `shares_memory` for details.  Default for ``may_share_memory``        is to do a bounds check.new_order : string, optional        Byte order to force; a value from the byte order specifications        below. `new_order` codes can be any of:dst : ndarray        The array into which values are copied.    src : array_like        The array from which values are copied.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        Controls what kind of data casting may occur when copying.a : array_like        Target array.    mask : array_like        Boolean mask array. It has to be the same shape as `a`.    values : array_like        Values to put into `a` where `mask` is True. If `values` is smaller        than `a` it will be repeated.new_shape : tuple of ints, or `n` ints        Shape of resized array.    refcheck : bool, optional        If False, reference count will not be checked. Default is True.val : object        Value to be placed in field.    dtype : dtype object        Data-type of the field in which to place `val`.    offset : int, optional        The number of bytes into the field at which to place `val`.write : bool, optional        Describes whether or not `a` can be written to.    align : bool, optional        Describes whether or not `a` is aligned properly for its type.    uic : bool, optional        Describes whether or not `a` is a copy of another ""base"" array.axis : int, optional        Axis along which to sort. Default is -1, which means sort along the        last axis.    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'        and 'mergesort' use timsort under the covers and, in general, the        actual implementation will vary with datatype. The 'mergesort' option        is retained for backwards compatibility.kth : int or sequence of ints        Element index to partition by. The kth element value will be in its        final sorted position and all smaller elements will be moved before it        and all equal or greater elements behind it.        The order of all elements in the partitions is undefined.        If provided with a sequence of kth it will partition all elements        indexed by kth of them into their sorted position at once.    axis : int, optional        Axis along which to sort. Default is -1, which means sort along the        last axis.    kind : {'introselect'}, optional        Selection algorithm. Default is 'introselect'.    order : str or list of str, optional        When `a` is an array with fields defined, this argument specifies        which fields to compare first, second, etc. A single field can        be specified as a string, and not all fields need to be specified,        but unspecified fields will still be used, in the order in which        they come up in the dtype, to break ties.fid : file or str or Path        An open file object, or a string containing a filename.noneorder : {{'C', 'F', None}}, optional        Order of the data for multidimensional arrays:        C, Fortran, or the same as for the original array.axes : None, tuple of ints, or `n` intsdtype : data-type or ndarray sub-class, optional        Data-type descriptor of the returned view, e.g., float32 or int16. The        default, None, results in the view having the same data-type as `a`.        This argument can also be specified as an ndarray sub-class, which        then specifies the type of the returned object (this is equivalent to        setting the ``type`` parameter).    type : Python type, optional        Type of the returned view, e.g., ndarray or matrix.  Again, the        default None results in type preservation.func : Python function object        An arbitrary Python function.    nin : int        The number of input arguments.    nout : int        The number of objects returned by `func`.errobj : list        The error object, a list containing three elements:        [internal numpy buffer size, error mask, error callback function].ufunc : numpy.ufunc        A ufunc whose current doc is NULL.    new_docstring : string        The new docstring for the ufunc.val : python float or numpy floating scalar        Value to format.*x : array_like        Input arrays.    out : ndarray, None, or tuple of ndarray and None, optional        Alternate array object(s) in which to put the result; if provided, it        must have a shape that the inputs broadcast to. A tuple of arrays        (possible only as a keyword argument) must have length equal to the        number of outputs; use `None` for uninitialized outputs to be        allocated by the ufunc.    where : array_like, optional        This condition is broadcast over the input. At locations where the        condition is True, the `out` array will be set to the ufunc result.        Elsewhere, the `out` array will retain its original value.        Note that if an uninitialized `out` array is created via the default        ``out=None``, locations within it where the condition is False will        remain uninitialized.    **kwargs        For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.a : array_like        The array to act on.    axis : None or int or tuple of ints, optional        Axis or axes along which a reduction is performed.        The default (`axis` = 0) is perform a reduction over the first        dimension of the input array. `axis` may be negative, in        which case it counts from the last to the first axis.array : array_like        The array to act on.    axis : int, optional        The axis along which to apply the accumulation; default is zero.    dtype : data-type code, optional        The data-type used to represent the intermediate results. Defaults        to the data-type of the output array if such is provided, or the        the data-type of the input array if no output array is provided.    out : ndarray, None, or tuple of ndarray and None, optional        A location into which the result is stored. If not provided or `None`,        a freshly-allocated array is returned. For consistency with        ``ufunc.__call__``, if given as a keyword, this may be wrapped in a        1-element tuple.a : array_like        The array to act on.    indices : array_like        Paired indices, comma separated (not colon), specifying slices to        reduce.    axis : int, optional        The axis along which to apply the reduceat.    dtype : data-type code, optional        The type used to represent the intermediate results. Defaults        to the data type of the output array if this is provided, or        the data type of the input array if no output array is provided.    out : ndarray, None, or tuple of ndarray and None, optional        A location into which the result is stored. If not provided or `None`,        a freshly-allocated array is returned. For consistency with        ``ufunc.__call__``, if given as a keyword, this may be wrapped in a        1-element tuple.A : array_like        First array    B : array_like        Second array    kwargs : any        Arguments to pass on to the ufunc. Typically `dtype` or `out`.a : array_like        The array to perform in place operation on.    indices : array_like or tuple        Array like index object or slice object for indexing into first        operand. If first operand has multiple dimensions, indices can be a        tuple of array like index objects or slice objects.    b : array_like        Second operand for ufuncs requiring two operands. Operand must be        broadcastable over first operand after indexing or slicing.obj        Object to be converted to a data type object.    align : bool, optional        Add padding to the fields to match what a C compiler would output        for a similar C-struct. Can be ``True`` only if `obj` is a dictionary        or a comma-separated string. If a struct dtype is being created,        this also sets a sticky alignment flag ``isalignedstruct``.    copy : bool, optional        Make a new copy of the data-type object. If ``False``, the result        may just be a reference to a built-in data-type object.new_order : string, optional        Byte order to force; a value from the byte order specifications        below.  The default value ('S') results in swapping the current        byte order.  `new_order` codes can be any of:weekmask : str or array_like of bool, optional        A seven-element array indicating which of Monday through Sunday are        valid days. May be specified as a length-seven list or array, like        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string        like ""Mon Tue Wed Thu Fri"", made up of 3-character abbreviations for        weekdays, optionally separated by white space. Valid abbreviations        are: Mon Tue Wed Thu Fri Sat Sun    holidays : array_like of datetime64[D], optional        An array of dates to consider as invalid dates, no matter which        weekday they fall upon.  Holiday dates may be specified in any        order, and NaT (not-a-time) dates are ignored.  This list is        saved in a normalized form that is suited for fast calculations        of valid days.axis : int        The un-normalized index of the axis. Can be negative    ndim : int        The number of dimensions of the array that `axis` should be normalized        against    msg_prefix : str        A prefix to put before the message, typically the name of the argumentdtype : dtype        The dtype object, which must be a `datetime64` or `timedelta64` type.new_order : str, optional        Byte order to force; a value from the byte order specifications        above.  The default value ('S') results in swapping the current        byte order. The code does a case-insensitive check on the first        letter of `new_order` for the alternatives above.  For example,        any of 'B' or 'b' or 'biggish' are valid to specify big-endian.","iternext : bool        Whether or not there are iterations left.iters : tuple of nditer        An nditer for each item in `axes`, outermost firstb : broadcast object        Broadcast the input parameters against one another, and        return an object that encapsulates the result.        Amongst others, it has ``shape`` and ``nd`` properties, and        may be used as an iterator.Noneout : ndarray        An array object satisfying the specified requirements.out : ndarray        Array of uninitialized (arbitrary) data of the given shape, dtype, and        order.  Object arrays will be initialized to None.out : ndarray        Array of zeros with the given shape, dtype, and order.arr : ndarray        The constructed array.out : ndarray        The output array of type Boolean with the same shape as a and b.out : ndarray        The output array.arange : ndarray        Array of evenly spaced values.saved_ops : list of callables        A list of all operators, stored before making replacements.out : dtype        The promoted data type.newbuffer : buffer object        Returned, uninitialized buffer object of `size` bytes.buffer_obj : bufferoutput : ndarray        The calculation based on the Einstein summation convention.c : Python object        Possessing attributes data, shape, strides, etc.d : numpy dtype objectarr_t : ndarray        Unless `copy` is False and the other conditions for returning the input        array are satisfied (see description for `copy` input parameter), `arr_t`        is a new array of the same shape as the input array, with dtype, order        given by `dtype`, `order`.out : ndarray        The byteswapped array. If `inplace` is ``True``, this is        a view to self.y : ndarray        A copy of the input array, flattened to one dimension.z : Standard Python scalar object        A copy of the specified element of the array as a suitable        Python scalarout : boolout : boolnew_arr : array        New array object with the dtype reflecting given change to the        byte order.NoneNoney : object, or list of object, or list of list of object, or ...        The possibly nested list of array elements.s : bytes        Python bytes exhibiting a copy of `a`'s raw data.out : ndarray        View of `a`, with axes suitably permuted.out : ufunc        Returns a NumPy universal function (``ufunc``) object.errobj : list        The error object, a list containing three elements:        [internal numpy buffer size, error mask, error callback function].rep : string        The string representation of the floating point valuer : ndarray or tuple of ndarray        `r` will have the shape that the arrays in `x` broadcast to; if `out` is        provided, it will be returned. If not, `r` will be allocated and        may contain uninitialized values. If the function has more than one        output, then the result will be a tuple of arrays.r : ndarray        The reduced array. If `out` was supplied, `r` is a reference to it.r : ndarray        The accumulated values. If `out` was supplied, `r` is a reference to        `out`.r : ndarray        The reduced values. If `out` was supplied, `r` is a reference to        `out`.r : ndarray        Output arraynew_dtype : dtype        New dtype object with the given change to the byte order.out : busdaycalendar        A business day calendar object containing the specified        weekmask and holidays values.normalized_axis : int        The normalized axis index, such that `0 <= normalized_axis < ndim`unit : str        The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype        is based.    count : int        The number of base units in a step.new_dtype : dtype        New `dtype` object with the given change to the byte order."
numeric_type_aliases(aliases):,https://github.com//numpy/numpy/blob/master/numpy/core/_add_newdocs.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_asarray.py,,,
"asarray(a, dtype=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_asarray.py, Convert the input to an array.,"a : array_like        Input data, in any form that can be converted to an array.  This        includes lists, lists of tuples, tuples, tuples of tuples, tuples        of lists and ndarrays.    dtype : data-type, optional        By default, the data-type is inferred from the input data.    order : {'C', 'F'}, optional        Whether to use row-major (C-style) or        column-major (Fortran-style) memory representation.        Defaults to 'C'.","out : ndarray        Array interpretation of `a`.  No copy is performed if the input        is already an ndarray with matching dtype and order.  If `a` is a        subclass of ndarray, a base class ndarray is returned."
"asanyarray(a, dtype=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_asarray.py," Convert the input to an ndarray, but pass ndarray subclasses through.","a : array_like        Input data, in any form that can be converted to an array.  This        includes scalars, lists, lists of tuples, tuples, tuples of tuples,        tuples of lists, and ndarrays.    dtype : data-type, optional        By default, the data-type is inferred from the input data.    order : {'C', 'F'}, optional        Whether to use row-major (C-style) or column-major        (Fortran-style) memory representation.  Defaults to 'C'.","out : ndarray or an ndarray subclass        Array interpretation of `a`.  If `a` is an ndarray or a subclass        of ndarray, it is returned as-is and no copy is performed."
"ascontiguousarray(a, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_asarray.py,     Return a contiguous array (ndim >= 1) in memory (C order).,"a : array_like        Input array.    dtype : str or dtype object, optional        Data-type of returned array.","out : ndarray        Contiguous array of same shape and content as `a`, with type `dtype`        if specified."
"asfortranarray(a, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_asarray.py,     Return an array (ndim >= 1) laid out in Fortran order in memory.,"a : array_like        Input array.    dtype : str or dtype object, optional        By default, the data-type is inferred from the input data.","out : ndarray        The input `a` in Fortran, or column-major, order."
,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
_kind_name(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
__str__(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
__repr__(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
"_unpack_field(dtype, offset, title=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,"     Helper function to normalize the items in dtype.fields.    Call as:    dtype, offset, title = _unpack_field(*dtype.fields[name])",,
_isunsized(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
"_construction_repr(dtype, include_align=False, short=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,"     Creates a string repr of the dtype, excluding the 'dtype()' part    surrounding the object. This object may be a string, a list, or    a dict depending on the nature of the dtype. This    is the object passed as the first parameter to the dtype    constructor, and if no additional constructor parameters are    given, will reproduce the exact memory layout.","short : bool        If true, this creates a shorter repr using 'kind' and 'itemsize', instead        of the longer type name.",
"_scalar_str(dtype, short):",https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
_byte_order_str(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,"  Normalize byteorder to '<' or '>'  # hack to obtain the native and swapped byte order characters    swapped = np.dtype(int).newbyteorder('s')    native = swapped.newbyteorder('s')
    byteorder = dtype.byteorder if byteorder == '=': return native.byteorder if byteorder == 's': # TODO: this path can never be reached return swapped.byteorder elif byteorder == '|': return '' else: return byteorder

",,
_datetime_metadata_str(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
"_struct_dict_str(dtype, includealignedflag):",https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
_is_packed(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,"     Checks whether the structured data type in 'dtype'    has a simple layout, where all the fields are in order,    and follow each other with no alignment padding.    When this returns true, the dtype can be reconstructed    from a list of the field names and dtypes with no additional    dtype parameters.    Duplicates the C `is_dtype_struct_simple_unaligned_layout` functio.",,
_struct_list_str(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
"_struct_str(dtype, include_align):",https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
_subarray_str(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype_ctypes.py,"Conversion from ctypes to dtype.In an ideal world, we could achieve this through the PEP3118 buffer protocol,something like::    def dtype_from_ctypes_type(t):        # needed to ensure that the shape of `t` is within memoryview.format        class DummyStruct(ctypes.Structure):            _fields_ = [('a', t)]        # empty to avoid memory allocation        ctype_0 = (DummyStruct * 0)()        mv = memoryview(ctype_0)        # convert the struct, and slice back out the field        return _dtype_from_pep3118(mv.format)['a']Unfortunately, this fails because:* ctypes cannot handle length-0 arrays with PEP3118 (bpo-32782)* PEP3118 cannot represent unions, but both numpy and ctypes can* ctypes cannot handle big-endian structs with PEP3118 (bpo-32780)",,
_from_ctypes_array(t):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype_ctypes.py,,,
_from_ctypes_structure(t):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype_ctypes.py,,,
_from_ctypes_scalar(t):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype_ctypes.py,     Return the dtype type with endianness included if it's the case,,
_from_ctypes_union(t):,https://github.com//numpy/numpy/blob/master/numpy/core/_dtype_ctypes.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_exceptions.py,,,
_unpack_tuple(tup):,https://github.com//numpy/numpy/blob/master/numpy/core/_exceptions.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"_makenames_list(adict, align):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"_usefields(adict, align):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
_array_descr(descriptor):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"_reconstruct(subtype, shape, dtype):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
_commastring(astr):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
_getintp_ctype():,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,     Helper to allow viewing an array as a ctypes pointer to the first element    This avoids:      * dealing with strides      * `.view` rejecting object-containing arrays      * `memoryview` not supporting overlapping fields,,
_get_void_ptr(arr):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"     Get a `ctypes.c_void_p` to arr.data, that keeps a reference to the array",,
"_newnames(datatype, order):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"     Given a datatype and an order object, return a new names tuple, with the    order indicated",,
_copy_fields(ary):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py, Return copy of structured array with padding between fields removed.,ary : ndarray       Structured array from which to remove padding bytes,"ary_copy : ndarray       Copy of ary with padding bytes removed """"""    dt = ary.dtype    copy_dtype = {'names': dt.names, 'formats': [dt.fields[name][0] for name in dt.names]} return array(ary, dtype=copy_dtype, copy=True)
"
"_getfield_is_safe(oldtype, newtype, offset):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"  Checks safety of getfield for object arrays.    As in _view_is_safe, we need to check that memory containing objects is not    reinterpreted as a non-object datatype and vice versa.",oldtype : data-type        Data type of the original ndarray.    newtype : data-type        Data type of the field being accessed by ndarray.getfield    offset : int        Offset of the field being accessed by ndarray.getfield,
"_view_is_safe(oldtype, newtype):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"  Checks safety of a view involving object arrays, for example when    doing::        np.zeros(10, dtype=oldtype).view(newtype)",oldtype : data-type        Data type of original ndarray    newtype : data-type        Data type of the view,
_dtype_from_pep3118(spec):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"__dtype_from_pep3118(stream, is_subdtype):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
_fix_names(field_spec):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"  Replace names which are None with the next unused f%d name     names = field_spec['names'] for i, name in enumerate(names): if name is not None: continue
        j = 0 while True:            name = 'f{}'.format(j) if name not in names: break            j = j + 1        names[i] = name
",,
"_add_trailing_padding(value, padding):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py," Inject the specified number of padding bytes at the end of a dtype if value.fields is None:        field_spec = dict( names=['f0'], formats=[value], offsets=[0], itemsize=value.itemsize        ) else:        fields = value.fields        names = value.names        field_spec = dict( names=names, formats=[fields[name][0] for name in names], offsets=[fields[name][1] for name in names], itemsize=value.itemsize        )
    field_spec['itemsize'] += padding return dtype(field_spec)
",,
_prod(a):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"_gcd(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py," Calculate the greatest common divisor of a and b while b:        a, b = b, a % b return a
",,
"_lcm(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,,,
"array_ufunc_errmsg_formatter(dummy, ufunc, method, *inputs, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"  Format the error message for when __array_ufunc__ gives up.     args_string = ', '.join(['{!r}'.format(arg) for arg in inputs] +                            ['{}={!r}'.format(k, v) for k, v in kwargs.items()])    args = inputs + kwargs.get('out', ())    types_string = ', '.join(repr(type(arg).__name__) for arg in args) return ('operand type(s) all returned NotImplemented from ' '__array_ufunc__({!r}, {!r}, {}): {}'            .format(ufunc, method, args_string, types_string))

",,
"array_function_errmsg_formatter(public_api, types):",https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,"  Format the error message for when __array_ufunc__ gives up.     func_name = '{}.{}'.format(public_api.__module__, public_api.__name__) return (""no implementation found for '{}' on types that implement "" '__array_function__: {}'.format(func_name, list(types)))

",,
_ufunc_doc_signature_formatter(ufunc):,https://github.com//numpy/numpy/blob/master/numpy/core/_internal.py,     Builds a signature string which resembles PEP 457    This is used to construct the first line of the docstring,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,Array methods which are called by both the C-code for the methodand the Python code for the NumPy-namespace function,,
"_amax(a, axis=None, out=None, keepdims=False,",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_amin(a, axis=None, out=None, keepdims=False,",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_sum(a, axis=None, dtype=None, out=None, keepdims=False,",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_prod(a, axis=None, dtype=None, out=None, keepdims=False,",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_any(a, axis=None, dtype=None, out=None, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_all(a, axis=None, dtype=None, out=None, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_count_reduce_items(arr, axis):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
_clip_dep_is_scalar_nan(a):,https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
_clip_dep_is_byte_swapped(a):,https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_clip_dep_invoke_with_casting(ufunc, *args, out=None, casting=None, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_clip(a, min=None, max=None, out=None, *, casting=None, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_mean(a, axis=None, dtype=None, out=None, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_ptp(a, axis=None, out=None, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
"_dump(self, file, protocol=2):",https://github.com//numpy/numpy/blob/master/numpy/core/_methods.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_string_helpers.py,String-handling utilities to avoid locale-dependence.Used primarily to generate type name aliases.,,
english_lower(s):,https://github.com//numpy/numpy/blob/master/numpy/core/_string_helpers.py,"  Apply English case rules to convert ASCII strings to all lower case.    This is an internal utility function to replace calls to str.lower() such    that we can avoid changing behavior with changing locales. In particular,    Turkish has distinct dotted and dotless variants of the Latin letter ""I"" in    both lowercase and uppercase. Thus, ""I"".lower() != ""i"" in a ""tr"" locale.",s : str,lowered : str
english_upper(s):,https://github.com//numpy/numpy/blob/master/numpy/core/_string_helpers.py,"  Apply English case rules to convert ASCII strings to all upper case.    This is an internal utility function to replace calls to str.upper() such    that we can avoid changing behavior with changing locales. In particular,    Turkish has distinct dotted and dotless variants of the Latin letter ""I"" in    both lowercase and uppercase. Thus, ""i"".upper() != ""I"" in a ""tr"" locale.",s : str,uppered : str
,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
_bits_of(obj):,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
bitname(obj):,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py," Return a bit-width name for a given type object    bits = _bits_of(obj)    dt = dtype(obj)    char = dt.kind    base = _kind_name(dt)
 if base == 'object':        bits = 0
 if bits != 0:        char = ""%s%d"" % (char, bits // 8)
 return base, bits, char

",,
_add_types():,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
_add_aliases():,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
_add_integer_aliases():,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
_set_up_aliases():,https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
"_add_array_type(typename, bits):",https://github.com//numpy/numpy/blob/master/numpy/core/_type_aliases.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,Functions for changing global ufunc configurationThis provides helpers which wrap `umath.geterrobj` and `umath.seterrobj`,,
"seterr(all=None, divide=None, over=None, under=None, invalid=None):",https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,"     Set how floating-point errors are handled.    Note that operations on integer scalar types (such as `int16`) are    handled like floating point, and are affected by these settings.","all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional        Set treatment for all types of floating-point errors at once:",old_settings : dict        Dictionary containing the old settings.
geterr():,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,     Get the current way of handling floating-point errors.,,"res : dict        A dictionary with keys ""divide"", ""over"", ""under"", and ""invalid"",        whose values are from the strings ""ignore"", ""print"", ""log"", ""warn"",        ""raise"", and ""call"". The keys represent possible floating-point        exceptions, and the values define how these exceptions are handled."
setbufsize(size):,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,     Set the size of the buffer used in ufuncs.,size : int        Size of buffer.,
getbufsize():,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,     Return the size of the buffer used in ufuncs.,,getbufsize : int        Size of ufunc buffer in bytes.
seterrcall(func):,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,"     Set the floating-point error callback function or log object.    There are two ways to capture floating-point error messages.  The first    is to set the error-handler to 'call', using `seterr`.  Then, set    the function to call using this function.    The second is to set the error-handler to 'log', using `seterr`.    Floating-point errors then trigger a call to the 'write' method of    the provided object.","func : callable f(err, flag) or object with write method        Function to call upon floating-point errors ('call'-mode) or        object whose 'write' method is used to log such message ('log'-mode).","h : callable, log instance or None        The old error handler."
geterrcall():,https://github.com//numpy/numpy/blob/master/numpy/core/_ufunc_config.py,"     Return the current callback function used on floating-point errors.    When the error handling for a floating-point error (one of ""divide"",    ""over"", ""under"", or ""invalid"") is set to 'call' or 'log', the function    that is called or the log instance that is written to is returned by    `geterrcall`. This function or log instance has been set with    `seterrcall`.","kwargs : {divide, over, under, invalid}        Keyword arguments. The valid keywords are the possible floating-point        exceptions. Each keyword should have a string value that defines the        treatment for the particular error. Possible values are        {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.","errobj : callable, log instance or None        The current error handler. If no handler was set through `seterrcall`,        ``None`` is returned."
,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"Array printing function$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $",,
"_make_options_dict(precision=None, threshold=None, edgeitems=None,",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"  make a dictionary out of the non-None arguments, plus sanity checks 
    options = {k: v for k, v in locals().items() if v is not None}
 if suppress is not None:        options['suppress'] = bool(suppress)
    modes = ['fixed', 'unique', 'maxprec', 'maxprec_equal'] if floatmode not in modes + [None]: raise ValueError(""floatmode option must be one of "" + "", "".join('""{}""'.format(m) for m in modes))
 if sign not in [None, '-', '+', ' ']: raise ValueError(""sign option must be one of ' ', '+', or '-'"")
 if legacy not in [None, False, '1.13']:        warnings.warn(""legacy printing option can currently only be '1.13' or "" ""`False`"", stacklevel=3) if threshold is not None: # forbid the bad threshold arg suggested by stack overflow, gh-12351 if not isinstance(threshold, numbers.Number) or np.isnan(threshold): raise ValueError(""threshold must be numeric and non-NAN, try "" ""sys.maxsize for untruncated representation"") return options

@set_module('numpy')",,
"set_printoptions(precision=None, threshold=None, edgeitems=None,",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Set printing options.    These options determine the way floating point numbers, arrays and    other NumPy objects are displayed.","precision : int or None, optional        Number of digits of precision for floating point output (default 8).        May be `None` if `floatmode` is not `fixed`, to print as many digits as        necessary to uniquely specify the value.    threshold : int, optional        Total number of array elements which trigger summarization        rather than full repr (default 1000).    edgeitems : int, optional        Number of array items in summary at beginning and end of        each dimension (default 3).    linewidth : int, optional        The number of characters per line for the purpose of inserting        line breaks (default 75).    suppress : bool, optional        If True, always print floating point numbers using fixed point        notation, in which case numbers equal to zero in the current precision        will print as zero.  If False, then scientific notation is used when        absolute value of the smallest number is < 1e-4 or the ratio of the        maximum absolute value to the minimum is > 1e3. The default is False.    nanstr : str, optional        String representation of floating point not-a-number (default nan).    infstr : str, optional        String representation of floating point infinity (default inf).    sign : string, either '-', '+', or ' ', optional        Controls printing of the sign of floating-point types. If '+', always        print the sign of positive values. If ' ', always prints a space        (whitespace character) in the sign position of positive values.  If        '-', omit the sign character of positive values. (default '-')    formatter : dict of callables, optional        If not None, the keys should indicate the type(s) that the respective        formatting function applies to.  Callables should return a string.        Types that are not specified (by their corresponding keys) are handled        by the default formatters.  Individual types for which a formatter        can be set are:",
get_printoptions():,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,     Return the current print options.,,print_opts : dict        Dictionary of current print options with keys
"printoptions(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py," Context manager for setting print options.    Set print options for the scope of the `with` block, and restore the old    options at the end. See `set_printoptions` for the full description of    available options.    Examples    -------- >>> from numpy.testing import assert_equal >>> with np.printoptions(precision=2): ...     np.array([2.0]) / 3    array([0.67])    The `as`-clause of the `with`-statement gives the current print options: >>> with np.printoptions(precision=2) as opts: ...      assert_equal(opts, np.get_printoptions())    See Also    --------    set_printoptions, get_printoptions",,
"_leading_trailing(a, edgeitems, index=()):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Keep only the N-D corners (leading and trailing edges) of an array.    Should be passed a base-class ndarray, since it makes no guarantees about    preserving subclasses.",,
_object_format(o):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"  Object arrays containing lists should be printed unambiguously  if type(o) is list:        fmt = 'list({!r})' else:        fmt = '{!r}' return fmt.format(o)
",,
repr_format(x):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
str_format(x):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"_get_formatdict(data, **opt):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"_get_format_function(data, **options):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,     find the right formatting function for the dtype_,,
_recursive_guard(fillvalue='...'):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs    Decorates a function such that if it calls itself with the same first    argument, it returns `fillvalue` instead of recursing.    Largely copied from reprlib.recursive_repr",,
"_array2string(a, options, separator=' ', prefix=""""):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
_array2string_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"array2string(a, max_line_width=None, precision=None,",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,     Return a string representation of an array.,"a : array_like        Input array.    max_line_width : int, optional        Inserts newlines if text is longer than `max_line_width`.        Defaults to ``numpy.get_printoptions()['linewidth']``.    precision : int or None, optional        Floating point precision.        Defaults to ``numpy.get_printoptions()['precision']``.    suppress_small : bool, optional        Represent numbers ""very close"" to zero as zero; default is False.        Very close is defined by precision: if the precision is 8, e.g.,        numbers smaller (in absolute value) than 5e-9 are represented as        zero.        Defaults to ``numpy.get_printoptions()['suppress']``.    separator : str, optional        Inserted between elements.    prefix : str, optional    suffix: str, optional        The length of the prefix and suffix strings are used to respectively        align and wrap the output. An array is typically printed as::",array_str : str        String representation of the array.
"_extendLine(s, line, word, line_width, next_line_prefix, legacy):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"_formatArray(a, format_function, line_width, next_line_prefix,",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py, formatArray is designed for two modes of operation:    1. Full output    2. Summarized output,,
"_none_or_positive_arg(x, name):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"  Formatter for subtypes of np.floating  def __init__(self, data, precision, floatmode, suppress_small, sign=False, **kwarg): # for backcompatibility, accept bools if isinstance(sign, bool):            sign = '+' if sign else '-'
 self._legacy = kwarg.get('legacy', False) if self._legacy == '1.13': # when not 0d, legacy does not support '-' if data.shape != () and sign == '-':                sign = ' '
 self.floatmode = floatmode if floatmode == 'unique': self.precision = None else: self.precision = precision
 self.precision = _none_or_positive_arg(self.precision, 'precision')
 self.suppress_small = suppress_small self.sign = sign self.exp_format = False self.large_exponent = False
 self.fillFormat(data)
 def fillFormat(self, data): # only the finite values are used to compute the number of digits        finite_vals = data[isfinite(data)]
 # choose exponential mode based on the non-zero finite values:        abs_non_zero = absolute(finite_vals[finite_vals != 0]) if len(abs_non_zero) != 0:            max_val = np.max(abs_non_zero)            min_val = np.min(abs_non_zero) with errstate(over='ignore'):  # division can overflow if max_val >= 1.e8 or (not self.suppress_small and                        (min_val < 0.0001 or max_val/min_val > 1000.)): self.exp_format = True
 # do a first pass of printing all the numbers, to determine sizes if len(finite_vals) == 0: self.pad_left = 0 self.pad_right = 0 self.trim = '.' self.exp_size = -1 self.unique = True elif self.exp_format:            trim, unique = '.', True if self.floatmode == 'fixed' or self._legacy == '1.13':                trim, unique = 'k', False            strs = (dragon4_scientific(x, precision=self.precision, unique=unique, trim=trim, sign=self.sign == '+') for x in finite_vals)            frac_strs, _, exp_strs = zip(*(s.partition('e') for s in strs))            int_part, frac_part = zip(*(s.split('.') for s in frac_strs)) self.exp_size = max(len(s) for s in exp_strs) - 1
 self.trim = 'k' self.precision = max(len(s) for s in frac_part)
 # for back-compat with np 1.13, use 2 spaces & sign and full prec if self._legacy == '1.13': self.pad_left = 3 else: # this should be only 1 or 2. Can be calculated from sign. self.pad_left = max(len(s) for s in int_part) # pad_right is only needed for nan length calculation self.pad_right = self.exp_size + 2 + self.precision
 self.unique = False else: # first pass printing to determine sizes            trim, unique = '.', True if self.floatmode == 'fixed':                trim, unique = 'k', False            strs = (dragon4_positional(x, precision=self.precision, fractional=True, unique=unique, trim=trim, sign=self.sign == '+') for x in finite_vals)            int_part, frac_part = zip(*(s.split('.') for s in strs)) if self._legacy == '1.13': self.pad_left = 1 + max(len(s.lstrip('-+')) for s in int_part) else: self.pad_left = max(len(s) for s in int_part) self.pad_right = max(len(s) for s in frac_part) self.exp_size = -1
 if self.floatmode in ['fixed', 'maxprec_equal']: self.precision = self.pad_right self.unique = False self.trim = 'k' else: self.unique = True self.trim = '.'
 if self._legacy != '1.13': # account for sign = ' ' by adding one to pad_left if self.sign == ' ' and not any(np.signbit(finite_vals)): self.pad_left += 1
 # if there are non-finite values, may need to increase pad_left if data.size != finite_vals.size:            neginf = self.sign != '-' or any(data[isinf(data)] < 0)            nanlen = len(_format_options['nanstr'])            inflen = len(_format_options['infstr']) + neginf            offset = self.pad_right + 1 # +1 for decimal pt self.pad_left = max(self.pad_left, nanlen - offset, inflen - offset)
 def __call__(self, x): if not np.isfinite(x): with errstate(invalid='ignore'): if np.isnan(x):                    sign = '+' if self.sign == '+' else ''                    ret = sign + _format_options['nanstr'] else:  # isinf                    sign = '-' if x < 0 else '+' if self.sign == '+' else ''                    ret = sign + _format_options['infstr'] return ' '*(self.pad_left + self.pad_right + 1 - len(ret)) + ret
 if self.exp_format: return dragon4_scientific(x, precision=self.precision, unique=self.unique, trim=self.trim, sign=self.sign == '+', pad_left=self.pad_left, exp_digits=self.exp_size) else: return dragon4_positional(x, precision=self.precision, unique=self.unique, fractional=True, trim=self.trim, sign=self.sign == '+', pad_left=self.pad_left, pad_right=self.pad_right)
# for back-compatibility, we keep the classes for each float type tooclass FloatFormat(FloatingFormat): def __init__(self, *args, **kwargs):        warnings.warn(""FloatFormat has been replaced by FloatingFormat"", DeprecationWarning, stacklevel=2) super(FloatFormat, self).__init__(*args, **kwargs)

class LongFloatFormat(FloatingFormat): def __init__(self, *args, **kwargs):        warnings.warn(""LongFloatFormat has been replaced by FloatingFormat"", DeprecationWarning, stacklevel=2) super(LongFloatFormat, self).__init__(*args, **kwargs)

@set_module('numpy')",,
"format_float_scientific(x, precision=None, unique=True, trim='k',",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Format a floating-point scalar as a decimal string in scientific notation.    Provides control over rounding, trimming and padding. Uses and assumes    IEEE unbiased rounding. Uses the ""Dragon4"" algorithm.","x : python float or numpy floating scalar        Value to format.    precision : non-negative integer or None, optional        Maximum number of digits to print. May be None if `unique` is        `True`, but must be an integer if unique is `False`.    unique : boolean, optional        If `True`, use a digit-generation strategy which gives the shortest        representation which uniquely identifies the floating-point number from        other values of the same type, by judicious rounding. If `precision`        was omitted, print all necessary digits, otherwise digit generation is        cut off after `precision` digits and the remaining value is rounded.        If `False`, digits are generated as if printing an infinite-precision        value and stopping after `precision` digits, rounding the remaining        value.    trim : one of 'k', '.', '0', '-', optional        Controls post-processing trimming of trailing digits, as follows:",rep : string        The string representation of the floating point value
"format_float_positional(x, precision=None, unique=True,",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Format a floating-point scalar as a decimal string in positional notation.    Provides control over rounding, trimming and padding. Uses and assumes    IEEE unbiased rounding. Uses the ""Dragon4"" algorithm.","x : python float or numpy floating scalar        Value to format.    precision : non-negative integer or None, optional        Maximum number of digits to print. May be None if `unique` is        `True`, but must be an integer if unique is `False`.    unique : boolean, optional        If `True`, use a digit-generation strategy which gives the shortest        representation which uniquely identifies the floating-point number from        other values of the same type, by judicious rounding. If `precision`        was omitted, print out all necessary digits, otherwise digit generation        is cut off after `precision` digits and the remaining value is rounded.        If `False`, digits are generated as if printing an infinite-precision        value and stopping after `precision` digits, rounding the remaining        value.    fractional : boolean, optional        If `True`, the cutoff of `precision` digits refers to the total number        of digits after the decimal point, including leading zeros.        If `False`, `precision` refers to the total number of significant        digits, before or after the decimal point, ignoring leading zeros.    trim : one of 'k', '.', '0', '-', optional        Controls post-processing trimming of trailing digits, as follows:",rep : string        The string representation of the floating point value
_void_scalar_repr(x):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Implements the repr for structured-void scalars. It is called from the    scalartypes.c.src code, and is placed here because it uses the elementwise    formatters defined above.",,
dtype_is_implied(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,     Determine if the given dtype is implied by the representation of its values.,dtype : dtype        Data type,implied : bool        True if the dtype is implied by the representation of its values.
dtype_short_repr(dtype):,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Convert a dtype to a short form which evaluates to the same dtype.    The intent is roughly that the following holds >>> from numpy import * >>> dt = np.int64([1, 2]).dtype >>> assert eval(dtype_short_repr(dt)) == dt",,
_array_repr_implementation(,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py," Internal version of array_repr() that allows overriding array2string. if max_line_width is None:        max_line_width = _format_options['linewidth']
 if type(arr) is not ndarray:        class_name = type(arr).__name__ else:        class_name = ""array""
    skipdtype = dtype_is_implied(arr.dtype) and arr.size > 0
    prefix = class_name + ""(""    suffix = "")"" if skipdtype else "",""
 if (_format_options['legacy'] == '1.13' and            arr.shape == () and not arr.dtype.names):        lst = repr(arr.item()) elif arr.size > 0 or arr.shape == (0,):        lst = array2string(arr, max_line_width, precision, suppress_small, ', ', prefix, suffix=suffix) else:  # show zero-length shape unless it is (0,)        lst = ""[], shape=%s"" % (repr(arr.shape),)
    arr_str = prefix + lst + suffix
 if skipdtype: return arr_str
    dtype_str = ""dtype={})"".format(dtype_short_repr(arr.dtype))
 # compute whether we should put dtype on a new line: Do so if adding the # dtype would extend the last line past max_line_width. # Note: This line gives the correct result even when rfind returns -1.    last_line_len = len(arr_str) - (arr_str.rfind('\n') + 1)    spacer = "" "" if _format_options['legacy'] == '1.13': if issubclass(arr.dtype.type, flexible):            spacer = '\n' + ' '*len(class_name + ""("") elif last_line_len + len(dtype_str) + 1 > max_line_width:        spacer = '\n' + ' '*len(class_name + ""("")
 return arr_str + spacer + dtype_str

",,
_array_repr_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"array_repr(arr, max_line_width=None, precision=None, suppress_small=None):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,     Return the string representation of an array.,"arr : ndarray        Input array.    max_line_width : int, optional        Inserts newlines if text is longer than `max_line_width`.        Defaults to ``numpy.get_printoptions()['linewidth']``.    precision : int, optional        Floating point precision.        Defaults to ``numpy.get_printoptions()['precision']``.    suppress_small : bool, optional        Represent numbers ""very close"" to zero as zero; default is False.        Very close is defined by precision: if the precision is 8, e.g.,        numbers smaller (in absolute value) than 5e-9 are represented as        zero.        Defaults to ``numpy.get_printoptions()['suppress']``.",string : str      The string representation of an array.
_array_str_implementation(,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py," Internal version of array_str() that allows overriding array2string. if (_format_options['legacy'] == '1.13' and            a.shape == () and not a.dtype.names): return str(a.item())
 # the str of 0d arrays is a special case: It should appear like a scalar, # so floats are not truncated by `precision`, and strings are not wrapped # in quotes. So we return the str of the scalar value. if a.shape == (): # obtain a scalar and call str on it, avoiding problems for subclasses # for which indexing with () returns a 0d instead of a scalar by using # ndarray's getindex. Also guard against recursive 0d object arrays. return _guarded_str(np.ndarray.__getitem__(a, ()))
 return array2string(a, max_line_width, precision, suppress_small, ' ', """")

",,
_array_str_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,,,
"array_str(a, max_line_width=None, precision=None, suppress_small=None):",https://github.com//numpy/numpy/blob/master/numpy/core/arrayprint.py,"     Return a string representation of the data in an array.    The data in the array is returned as a single string.  This function is    similar to `array_repr`, the difference being that `array_repr` also    returns information on the kind of array and its data type.","a : ndarray        Input array.    max_line_width : int, optional        Inserts newlines if text is longer than `max_line_width`.        Defaults to ``numpy.get_printoptions()['linewidth']``.    precision : int, optional        Floating point precision.        Defaults to ``numpy.get_printoptions()['precision']``.    suppress_small : bool, optional        Represent numbers ""very close"" to zero as zero; default is False.        Very close is defined by precision: if the precision is 8, e.g.,        numbers smaller (in absolute value) than 5e-9 are represented as        zero.        Defaults to ``numpy.get_printoptions()['suppress']``.",
,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
_use_unicode(*args):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Helper function for determining the output type of some string    operations.    For an operation on two ndarrays, if at least one is unicode, the    result should be unicode.",,
_to_string_or_unicode_array(result):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Helper function to cast a result back into a string or unicode array    if an object array must be used as an intermediary.,,
_clean_args(*args):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Helper function for delegating arguments to Python string    functions.    Many of the Python string operations that have optional arguments    do not use 'None' to indicate a default value.  In these cases,    we need to remove all `None` arguments, and those following them.",,
_get_num_chars(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Helper function that returns the number of characters per field in    a string or unicode array.  This is to abstract out the fact that    for a unicode array this is itemsize / 4.,,
"_binary_op_dispatcher(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"equal(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 == x2) element-wise.    Unlike `numpy.equal`, this comparison is performed by first    stripping whitespace characters from the end of the string.  This    behavior is provided for backward-compatibility with numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
"not_equal(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 != x2) element-wise.    Unlike `numpy.not_equal`, this comparison is performed by first    stripping whitespace characters from the end of the string.  This    behavior is provided for backward-compatibility with numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
"greater_equal(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 >= x2) element-wise.    Unlike `numpy.greater_equal`, this comparison is performed by    first stripping whitespace characters from the end of the string.    This behavior is provided for backward-compatibility with    numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
"less_equal(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 <= x2) element-wise.    Unlike `numpy.less_equal`, this comparison is performed by first    stripping whitespace characters from the end of the string.  This    behavior is provided for backward-compatibility with numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
"greater(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 > x2) element-wise.    Unlike `numpy.greater`, this comparison is performed by first    stripping whitespace characters from the end of the string.  This    behavior is provided for backward-compatibility with numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
"less(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (x1 < x2) element-wise.    Unlike `numpy.greater`, this comparison is performed by first    stripping whitespace characters from the end of the string.  This    behavior is provided for backward-compatibility with numarray.","x1, x2 : array_like of str or unicode        Input arrays of the same shape.","out : ndarray or bool        Output array of bools, or a single bool if x1 and x2 are scalars."
_unary_op_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
str_len(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return len(a) element-wise.,a : array_like of str or unicode,out : ndarray        Output array of integers
"add(x1, x2):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return element-wise string concatenation for two arrays of str or unicode.    Arrays `x1` and `x2` must have the same shape.,x1 : array_like of str or unicode        Input array.    x2 : array_like of str or unicode        Input array.,"add : ndarray        Output array of `string_` or `unicode_`, depending on input types        of the same shape as `x1` and `x2`."
"_multiply_dispatcher(a, i):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"multiply(a, i):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (a * i), that is string multiple concatenation,    element-wise.    Values in `i` of less than 0 are treated as 0 (which yields an    empty string).",a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input types"
"_mod_dispatcher(a, values):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"mod(a, values):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return (a % i), that is pre-Python 2.6 string formatting    (iterpolation), element-wise for a pair of array_likes of str    or unicode.",a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input types"
capitalize(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return a copy of `a` with only the first character of each element    capitalized.    Calls `str.capitalize` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode        Input array of strings to capitalize.,"out : ndarray        Output array of str or unicode, depending on input        types"
"_center_dispatcher(a, width, fillchar=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"center(a, width, fillchar=' '):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return a copy of `a` with its elements centered in a string of    length `width`.    Calls `str.center` element-wise.,a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input        types"
"_count_dispatcher(a, sub, start=None, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"count(a, sub, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns an array with the number of non-overlapping occurrences of    substring `sub` in the range [`start`, `end`].    Calls `str.count` element-wise.",a : array_like of str or unicode,out : ndarray        Output array of ints.
"_code_dispatcher(a, encoding=None, errors=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"decode(a, encoding=None, errors=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Calls `str.decode` element-wise.    The set of available codecs comes from the Python standard library,    and may be extended at runtime.  For more information, see the    :mod:`codecs` module.",a : array_like of str or unicode,out : ndarray
"encode(a, encoding=None, errors=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Calls `str.encode` element-wise.    The set of available codecs comes from the Python standard library,    and may be extended at runtime. For more information, see the codecs    module.",a : array_like of str or unicode,out : ndarray
"_endswith_dispatcher(a, suffix, start=None, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"endswith(a, suffix, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns a boolean array which is `True` where the string element    in `a` ends with `suffix`, otherwise `False`.    Calls `str.endswith` element-wise.",a : array_like of str or unicode,out : ndarray        Outputs an array of bools.
"_expandtabs_dispatcher(a, tabsize=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"expandtabs(a, tabsize=8):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return a copy of each string element where all tab characters are    replaced by one or more spaces.    Calls `str.expandtabs` element-wise.    Return a copy of each string element where all tab characters are    replaced by one or more spaces, depending on the current column    and the given `tabsize`. The column number is reset to zero after    each newline occurring in the string. This doesn't understand other    non-printing characters or escape sequences.","a : array_like of str or unicode        Input array    tabsize : int, optional        Replace tabs with `tabsize` number of spaces.  If not given defaults        to 8 spaces.","out : ndarray        Output array of str or unicode, depending on input type"
"find(a, sub, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element, return the lowest index in the string where    substring `sub` is found.    Calls `str.find` element-wise.    For each element, return the lowest index in the string where    substring `sub` is found, such that `sub` is contained in the    range [`start`, `end`].",a : array_like of str or unicode,out : ndarray or int        Output array of ints.  Returns -1 if `sub` is not found.
"index(a, sub, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Like `find`, but raises `ValueError` when the substring is not found.    Calls `str.index` element-wise.",a : array_like of str or unicode,out : ndarray        Output array of ints.  Returns -1 if `sub` is not found.
isalnum(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if all characters in the string are    alphanumeric and there is at least one character, false otherwise.    Calls `str.isalnum` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
isalpha(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if all characters in the string are    alphabetic and there is at least one character, false otherwise.    Calls `str.isalpha` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
isdigit(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if all characters in the string are    digits and there is at least one character, false otherwise.    Calls `str.isdigit` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
islower(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if all cased characters in the    string are lowercase and there is at least one cased character,    false otherwise.    Calls `str.islower` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
isspace(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if there are only whitespace    characters in the string and there is at least one character,    false otherwise.    Calls `str.isspace` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
istitle(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if the element is a titlecased    string and there is at least one character, false otherwise.    Call `str.istitle` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
isupper(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns true for each element if all cased characters in the    string are uppercase and there is at least one character, false    otherwise.    Call `str.isupper` element-wise.    For 8-bit strings, this method is locale-dependent.",a : array_like of str or unicode,out : ndarray        Output array of bools
"_join_dispatcher(sep, seq):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"join(sep, seq):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return a string which is the concatenation of the strings in the    sequence `seq`.    Calls `str.join` element-wise.,sep : array_like of str or unicode    seq : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input types"
"_just_dispatcher(a, width, fillchar=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"ljust(a, width, fillchar=' '):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return an array with the elements of `a` left-justified in a    string of length `width`.    Calls `str.ljust` element-wise.,a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
lower(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return an array with the elements converted to lowercase.    Call `str.lower` element-wise.    For 8-bit strings, this method is locale-dependent.","a : array_like, {str, unicode}        Input array.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type"
"_strip_dispatcher(a, chars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"lstrip(a, chars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a copy with the leading characters    removed.    Calls `str.lstrip` element-wise.","a : array-like, {str, unicode}        Input array.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type"
"_partition_dispatcher(a, sep):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"partition(a, sep):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Partition each element in `a` around `sep`.    Calls `str.partition` element-wise.    For each element in `a`, split the element as the first    occurrence of `sep`, and return 3 strings containing the part    before the separator, the separator itself, and the part after    the separator. If the separator is not found, return 3 strings    containing the string itself, followed by two empty strings.","a : array_like, {str, unicode}        Input array    sep : {str, unicode}        Separator to split each string element in `a`.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type.        The output array will have an extra dimension with 3        elements per input element."
"_replace_dispatcher(a, old, new, count=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"replace(a, old, new, count=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a copy of the string with all    occurrences of substring `old` replaced by `new`.    Calls `str.replace` element-wise.",a : array-like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
"rfind(a, sub, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return the highest index in the string    where substring `sub` is found, such that `sub` is contained    within [`start`, `end`].    Calls `str.rfind` element-wise.",a : array-like of str or unicode,out : ndarray       Output array of ints.  Return -1 on failure.
"rindex(a, sub, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Like `rfind`, but raises `ValueError` when the substring `sub` is    not found.    Calls `str.rindex` element-wise.",a : array-like of str or unicode,out : ndarray       Output array of ints.
"rjust(a, width, fillchar=' '):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return an array with the elements of `a` right-justified in a    string of length `width`.    Calls `str.rjust` element-wise.,a : array_like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
"rpartition(a, sep):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Partition (split) each element around the right-most separator.    Calls `str.rpartition` element-wise.    For each element in `a`, split the element as the last    occurrence of `sep`, and return 3 strings containing the part    before the separator, the separator itself, and the part after    the separator. If the separator is not found, return 3 strings    containing the string itself, followed by two empty strings.",a : array_like of str or unicode        Input array    sep : str or unicode        Right-most separator to split each element in array.,"out : ndarray        Output array of string or unicode, depending on input        type.  The output array will have an extra dimension with        3 elements per input element."
"_split_dispatcher(a, sep=None, maxsplit=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"rsplit(a, sep=None, maxsplit=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a list of the words in the    string, using `sep` as the delimiter string.    Calls `str.rsplit` element-wise.    Except for splitting from the right, `rsplit`    behaves like `split`.",a : array_like of str or unicode,out : ndarray       Array of list objects
"_strip_dispatcher(a, chars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"rstrip(a, chars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a copy with the trailing    characters removed.    Calls `str.rstrip` element-wise.",a : array-like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
"split(a, sep=None, maxsplit=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a list of the words in the    string, using `sep` as the delimiter string.    Calls `str.split` element-wise.",a : array_like of str or unicode,out : ndarray        Array of list objects
"_splitlines_dispatcher(a, keepends=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"splitlines(a, keepends=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a list of the lines in the    element, breaking at line boundaries.    Calls `str.splitlines` element-wise.",a : array_like of str or unicode,out : ndarray        Array of list objects
"_startswith_dispatcher(a, prefix, start=None, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"startswith(a, prefix, start=0, end=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Returns a boolean array which is `True` where the string element    in `a` starts with `prefix`, otherwise `False`.    Calls `str.startswith` element-wise.",a : array_like of str or unicode,out : ndarray        Array of booleans
"strip(a, chars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a copy with the leading and    trailing characters removed.    Calls `str.strip` element-wise.",a : array-like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
swapcase(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return element-wise a copy of the string with    uppercase characters converted to lowercase and vice versa.    Calls `str.swapcase` element-wise.    For 8-bit strings, this method is locale-dependent.","a : array_like, {str, unicode}        Input array.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type"
title(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return element-wise title cased version of string or unicode.    Title case words start with uppercase characters, all remaining cased    characters are lowercase.    Calls `str.title` element-wise.    For 8-bit strings, this method is locale-dependent.","a : array_like, {str, unicode}        Input array.","out : ndarray        Output array of str or unicode, depending on input type"
"_translate_dispatcher(a, table, deletechars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"translate(a, table, deletechars=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element in `a`, return a copy of the string where all    characters occurring in the optional argument `deletechars` are    removed, and the remaining characters have been mapped through the    given translation table.    Calls `str.translate` element-wise.",a : array-like of str or unicode,"out : ndarray        Output array of str or unicode, depending on input type"
upper(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Return an array with the elements converted to uppercase.    Calls `str.upper` element-wise.    For 8-bit strings, this method is locale-dependent.","a : array_like, {str, unicode}        Input array.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type"
"_zfill_dispatcher(a, width):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,,,
"zfill(a, width):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,     Return the numeric string left-filled with zeros    Calls `str.zfill` element-wise.,"a : array_like, {str, unicode}        Input array.    width : int        Width of string to left-fill elements in `a`.","out : ndarray, {str, unicode}        Output array of str or unicode, depending on input type"
isnumeric(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element, return True if there are only numeric    characters in the element.    Calls `unicode.isnumeric` element-wise.    Numeric characters include digit characters, and all characters    that have the Unicode numeric value property, e.g. ``U+2155,    VULGAR FRACTION ONE FIFTH``.","a : array_like, unicode        Input array.","out : ndarray, bool        Array of booleans of same shape as `a`."
isdecimal(a):,https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     For each element, return True if there are only decimal    characters in the element.    Calls `unicode.isdecimal` element-wise.    Decimal characters include digit characters, and all characters    that that can be used to form decimal-radix numbers,    e.g. ``U+0660, ARABIC-INDIC DIGIT ZERO``.","a : array_like, unicode        Input array.shape : tuple        Shape of the array.    itemsize : int, optional        Length of each array element, in number of characters. Default is 1.    unicode : bool, optional        Are the array elements of type unicode (True) or string (False).        Default is False.    buffer : int, optional        Memory address of the start of the array data.  Default is None,        in which case a new array is created.    offset : int, optional        Fixed stride displacement from the beginning of an axis?        Default is 0. Needs to be >=0.    strides : array_like of ints, optional        Strides for the array (see `ndarray.strides` for full description).        Default is None.    order : {'C', 'F'}, optional        The order in which the array data is stored in memory: 'C' ->        ""row major"" order (the default), 'F' -> ""column major""        (Fortran) order.","out : ndarray, bool        Array of booleans identical in shape to `a`."
"array(obj, itemsize=None, copy=True, unicode=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/defchararray.py,"     Create a `chararray`.    .. note::       This class is provided for numarray backward-compatibility.       New code (not concerned with numarray compatibility) should use       arrays of type `string_` or `unicode_` and use the free functions       in :mod:`numpy.char <numpy.core.defchararray>` for fast       vectorized string operations instead.    Versus a regular NumPy array of type `str` or `unicode`, this    class adds the following functionality:      1) values automatically have whitespace removed from the end         when indexed      2) comparison operators automatically remove whitespace from the         end when comparing values      3) vectorized string operations are provided as methods         (e.g. `str.endswith`) and infix operators (e.g. ``+, *, %``)",obj : array of str or unicode-like,
,https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,,,
"_flop_count(idx_contraction, inner, num_terms, size_dictionary):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,     Computes the number of FLOPS in the contraction.,idx_contraction : iterable        The indices involved in the contraction    inner : bool        Does this contraction require an inner product?    num_terms : int        The number of terms in a contraction    size_dictionary : dict        The size of each of the indices in idx_contraction,flop_count : int        The total number of FLOPS required for the contraction.
"_compute_size_by_dict(indices, idx_dict):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,     Computes the product of the elements in indices based on the dictionary    idx_dict.,indices : iterable        Indices to base the product on.    idx_dict : dictionary        Dictionary of index sizes,ret : int        The resulting product.
"_find_contraction(positions, input_sets, output_set):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,     Finds the contraction for a given set of input and output sets.,positions : iterable        Integer positions of terms used in the contraction.    input_sets : list        List of sets that represent the lhs side of the einsum subscript    output_set : set        Set that represents the rhs side of the overall einsum subscript,"new_result : set        The indices of the resulting contraction    remaining : list        List of sets that have not been contracted, the new set is appended to        the end of this list    idx_removed : set        Indices removed from the entire contraction    idx_contraction : set        The indices used in the current contraction"
"_optimal_path(input_sets, output_set, idx_dict, memory_limit):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,"     Computes all possible pair contractions, sieves the results based    on ``memory_limit`` and returns the lowest cost path. This algorithm    scales factorial with respect to the elements in the list ``input_sets``.",input_sets : list        List of sets that represent the lhs side of the einsum subscript    output_set : set        Set that represents the rhs side of the overall einsum subscript    idx_dict : dictionary        Dictionary of index sizes    memory_limit : int        The maximum number of elements in a temporary array,path : list        The optimal contraction order within the memory limit constraint.
"_parse_possible_contraction(positions, input_sets, output_set, idx_dict, memory_limit, path_cost, naive_cost):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py, Compute the cost (removed size + flops) and resultant indices for    performing the contraction specified by ``positions``.,positions : tuple of int        The locations of the proposed tensors to contract.    input_sets : list of sets        The indices found on each tensors.    output_set : set        The output indices of the expression.    idx_dict : dict        Mapping of each index to its size.    memory_limit : int        The total allowed size for an intermediary tensor.    path_cost : int        The contraction cost so far.    naive_cost : int        The cost of the unoptimized expression.,"cost : (int, int)        A tuple containing the size of any indices removed, and the flop cost.    positions : tuple of int        The locations of the proposed tensors to contract.    new_input_sets : list of sets        The resulting new list of indices if this proposed contraction is performed."
"_update_other_results(results, best):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py, Update the positions and provisional input_sets of ``results`` based on    performing the contraction result ``best``. Remove any involving the tensors    contracted.,results : list        List of contraction results produced by ``_parse_possible_contraction``.    best : list        The best contraction of ``results`` i.e. the one that will be performed.,"mod_results : list        The list of modified results, updated with outcome of ``best`` contraction. """"""
    best_con = best[1]    bx, by = best_con    mod_results = []
 for cost, (x, y), con_sets in results:
 # Ignore results involving tensors just contracted if x in best_con or y in best_con: continue
 # Update the input_sets del con_sets[by - int(by > x) - int(by > y)] del con_sets[bx - int(bx > x) - int(bx > y)]        con_sets.insert(-1, best[2][-1])
 # Update the position indices        mod_con = x - int(x > bx) - int(x > by), y - int(y > bx) - int(y > by)        mod_results.append((cost, mod_con, con_sets))
 return mod_results
"
"_greedy_path(input_sets, output_set, idx_dict, memory_limit):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,"     Finds the path by contracting the best pair until the input list is    exhausted. The best pair is found by minimizing the tuple    ``(-prod(indices_removed), cost)``.  What this amounts to is prioritizing    matrix multiplication or inner product operations, then Hadamard like    operations, and finally outer operations. Outer products are limited by    ``memory_limit``. This algorithm scales cubically with respect to the    number of elements in the list ``input_sets``.",input_sets : list        List of sets that represent the lhs side of the einsum subscript    output_set : set        Set that represents the rhs side of the overall einsum subscript    idx_dict : dictionary        Dictionary of index sizes    memory_limit_limit : int        The maximum number of elements in a temporary array,path : list        The greedy contraction order within the memory limit constraint.
"_can_dot(inputs, result, idx_removed):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,     Checks if we can use BLAS (np.tensordot) call and its beneficial to do so.,inputs : list of str        Specifies the subscripts for summation.    result : str        Resulting summation.    idx_removed : set        Indices that are removed in the summation,"type : bool        Returns true if BLAS should and can be used, else False"
_parse_einsum_input(operands):,https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,     A reproduction of einsum c side einsum parsing in python.,,input_strings : str        Parsed input strings    output_string : str        Parsed output string    operands : list of array_like        The operands to use in the numpy contraction
"_einsum_path_dispatcher(*operands, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,,,
"einsum_path(*operands, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,"     einsum_path(subscripts, *operands, optimize='greedy')    Evaluates the lowest cost contraction order for an einsum expression by    considering the creation of intermediate arrays.","subscripts : str        Specifies the subscripts for summation.    *operands : list of array_like        These are the arrays for the operation.    optimize : {bool, list, tuple, 'greedy', 'optimal'}        Choose the type of path. If a tuple is provided, the second argument is        assumed to be the maximum intermediate size created. If only a single        argument is provided the largest input or output array size is used        as a maximum intermediate size.",path : list of tuples        A list representation of the einsum path.    string_repr : str        A printable representation of the einsum path.
"_einsum_dispatcher(*operands, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/einsumfunc.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"_wrapit(obj, method, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"_wrapfunc(obj, method, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"_wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"_take_dispatcher(a, indices, axis=None, out=None, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"take(a, indices, axis=None, out=None, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Take elements from an array along an axis.    When axis is not None, this function does the same thing as ""fancy""    indexing (indexing arrays using arrays); however, it can be easier to use    if you need elements along a given axis. A call such as    ``np.take(arr, indices, axis=3)`` is equivalent to    ``arr[:,:,:,indices,...]``.    Explained without fancy indexing, this is equivalent to the following use    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of    indices::        Ni, Nk = a.shape[:axis], a.shape[axis+1:]        Nj = indices.shape        for ii in ndindex(Ni):            for jj in ndindex(Nj):                for kk in ndindex(Nk):                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]","a : array_like (Ni..., M, Nk...)        The source array.    indices : array_like (Nj...)        The indices of the values to extract.","out : ndarray (Ni..., Nj..., Nk...)        The returned array has the same type as `a`."
"_reshape_dispatcher(a, newshape, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"reshape(a, newshape, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Gives a new shape to an array without changing its data.,"a : array_like        Array to be reshaped.    newshape : int or tuple of ints        The new shape should be compatible with the original shape. If        an integer, then the result will be a 1-D array of that length.        One shape dimension can be -1. In this case, the value is        inferred from the length of the array and remaining dimensions.    order : {'C', 'F', 'A'}, optional        Read the elements of `a` using this index order, and place the        elements into the reshaped array using this index order.  'C'        means to read / write the elements using C-like index order,        with the last axis index changing fastest, back to the first        axis index changing slowest. 'F' means to read / write the        elements using Fortran-like index order, with the first index        changing fastest, and the last index changing slowest. Note that        the 'C' and 'F' options take no account of the memory layout of        the underlying array, and only refer to the order of indexing.        'A' means to read / write the elements in Fortran-like index        order if `a` is Fortran *contiguous* in memory, C-like order        otherwise.","reshaped_array : ndarray        This will be a new view object if possible; otherwise, it will        be a copy.  Note there is no guarantee of the *memory layout* (C- or        Fortran- contiguous) of the returned array."
"_choose_dispatcher(a, choices, out=None, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"choose(a, choices, out=None, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Construct an array from an index array and a set of arrays to choose from.    First of all, if confused or uncertain, definitely look at the Examples -    in its full generality, this function is less simple than it might    seem from the following code description (below ndi =    `numpy.lib.index_tricks`):    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.    But this omits some subtleties.  Here is a fully general summary:    Given an ""index"" array (`a`) of integers and a sequence of `n` arrays    (`choices`), `a` and each choice array are first broadcast, as necessary,    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as    follows:    * if ``mode=raise`` (the default), then, first of all, each element of      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position      in `Ba` - then the value at the same position in the new array is the      value in `Bchoices[i]` at that same position;    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)      integer; modular arithmetic is used to map integers outside the range      `[0, n-1]` back into that range; and then the new array is constructed      as above;    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)      integer; negative integers are mapped to 0; values greater than `n-1`      are mapped to `n-1`; and then the new array is constructed as above.","a : int array        This array must contain integers in `[0, n-1]`, where `n` is the number        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any        integers are permissible.    choices : sequence of arrays        Choice arrays. `a` and all of the choices must be broadcastable to the        same shape.  If `choices` is itself an array (not recommended), then        its outermost dimension (i.e., the one corresponding to        ``choices.shape[0]``) is taken as defining the ""sequence"".    out : array, optional        If provided, the result will be inserted into this array. It should        be of the appropriate shape and dtype. Note that `out` is always        buffered if `mode='raise'`; use other modes for better performance.    mode : {'raise' (default), 'wrap', 'clip'}, optional        Specifies how indices outside `[0, n-1]` will be treated:",merged_array : array        The merged result.
"_repeat_dispatcher(a, repeats, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"repeat(a, repeats, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Repeat elements of an array.,"a : array_like        Input array.    repeats : int or array of ints        The number of repetitions for each element.  `repeats` is broadcasted        to fit the shape of the given axis.    axis : int, optional        The axis along which to repeat values.  By default, use the        flattened input array, and return a flat output array.","repeated_array : ndarray        Output array which has the same shape as `a`, except along        the given axis."
"_put_dispatcher(a, ind, v, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"put(a, ind, v, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Replaces specified elements of an array with given values.    The indexing works on the flattened target array. `put` is roughly    equivalent to:    ::        a.flat[ind] = v,"a : ndarray        Target array.    ind : array_like        Target indices, interpreted as integers.    v : array_like        Values to place in `a` at target indices. If `v` is shorter than        `ind` it will be repeated as necessary.    mode : {'raise', 'wrap', 'clip'}, optional        Specifies how out-of-bounds indices will behave.",
"_swapaxes_dispatcher(a, axis1, axis2):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"swapaxes(a, axis1, axis2):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Interchange two axes of an array.,a : array_like        Input array.    axis1 : int        First axis.    axis2 : int        Second axis.,"a_swapped : ndarray        For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is        returned; otherwise a new array is created. For earlier NumPy        versions a view of `a` is returned only if the order of the        axes is changed, otherwise the input array is returned."
"_transpose_dispatcher(a, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"transpose(a, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Permute the dimensions of an array.,"a : array_like        Input array.    axes : list of ints, optional        By default, reverse the dimensions, otherwise permute the axes        according to the values given.",p : ndarray        `a` with its axes permuted.  A view is returned whenever        possible.
"_partition_dispatcher(a, kth, axis=None, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"partition(a, kth, axis=-1, kind='introselect', order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return a partitioned copy of an array.    Creates a copy of the array with its elements rearranged in such a    way that the value of the element in k-th position is in the    position it would be in a sorted array. All elements smaller than    the k-th element are moved before this element and all equal or    greater are moved behind it. The ordering of the elements in the two    partitions is undefined.    .. versionadded:: 1.8.0,"a : array_like        Array to be sorted.    kth : int or sequence of ints        Element index to partition by. The k-th value of the element        will be in its final sorted position and all smaller elements        will be moved before it and all equal or greater elements behind        it. The order of all elements in the partitions is undefined. If        provided with a sequence of k-th it will partition all elements        indexed by k-th  of them into their sorted position at once.    axis : int or None, optional        Axis along which to sort. If None, the array is flattened before        sorting. The default is -1, which sorts along the last axis.    kind : {'introselect'}, optional        Selection algorithm. Default is 'introselect'.    order : str or list of str, optional        When `a` is an array with fields defined, this argument        specifies which fields to compare first, second, etc.  A single        field can be specified as a string.  Not all fields need be        specified, but unspecified fields will still be used, in the        order in which they come up in the dtype, to break ties.",partitioned_array : ndarray        Array of the same type and shape as `a`.
"_argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"argpartition(a, kth, axis=-1, kind='introselect', order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Perform an indirect partition along the given axis using the    algorithm specified by the `kind` keyword. It returns an array of    indices of the same shape as `a` that index data along the given    axis in partitioned order.    .. versionadded:: 1.8.0,"a : array_like        Array to sort.    kth : int or sequence of ints        Element index to partition by. The k-th element will be in its        final sorted position and all smaller elements will be moved        before it and all larger elements behind it. The order all        elements in the partitions is undefined. If provided with a        sequence of k-th it will partition all of them into their sorted        position at once.    axis : int or None, optional        Axis along which to sort. The default is -1 (the last axis). If        None, the flattened array is used.    kind : {'introselect'}, optional        Selection algorithm. Default is 'introselect'    order : str or list of str, optional        When `a` is an array with fields defined, this argument        specifies which fields to compare first, second, etc. A single        field can be specified as a string, and not all fields need be        specified, but unspecified fields will still be used, in the        order in which they come up in the dtype, to break ties.","index_array : ndarray, int        Array of indices that partition `a` along the specified axis.        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.        More generally, ``np.take_along_axis(a, index_array, axis=a)`` always        yields the partitioned `a`, irrespective of dimensionality."
"_sort_dispatcher(a, axis=None, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"sort(a, axis=-1, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return a sorted copy of an array.,"a : array_like        Array to be sorted.    axis : int or None, optional        Axis along which to sort. If None, the array is flattened before        sorting. The default is -1, which sorts along the last axis.    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'        and 'mergesort' use timsort or radix sort under the covers and, in general,        the actual implementation will vary with data type. The 'mergesort' option        is retained for backwards compatibility.",sorted_array : ndarray        Array of the same type and shape as `a`.
"_argsort_dispatcher(a, axis=None, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"argsort(a, axis=-1, kind=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Returns the indices that would sort an array.    Perform an indirect sort along the given axis using the algorithm specified    by the `kind` keyword. It returns an array of indices of the same shape as    `a` that index data along the given axis in sorted order.,"a : array_like        Array to sort.    axis : int or None, optional        Axis along which to sort.  The default is -1 (the last axis). If None,        the flattened array is used.    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'        and 'mergesort' use timsort under the covers and, in general, the        actual implementation will vary with data type. The 'mergesort' option        is retained for backwards compatibility.","index_array : ndarray, int        Array of indices that sort `a` along the specified `axis`.        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.        More generally, ``np.take_along_axis(a, index_array, axis=axis)``        always yields the sorted `a`, irrespective of dimensionality."
"_argmax_dispatcher(a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"argmax(a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Returns the indices of the maximum values along an axis.,"a : array_like        Input array.    axis : int, optional        By default, the index is into the flattened array, otherwise        along the specified axis.    out : array, optional        If provided, the result will be inserted into this array. It should        be of the appropriate shape and dtype.",index_array : ndarray of ints        Array of indices into the array. It has the same shape as `a.shape`        with the dimension along `axis` removed.
"_argmin_dispatcher(a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"argmin(a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Returns the indices of the minimum values along an axis.,"a : array_like        Input array.    axis : int, optional        By default, the index is into the flattened array, otherwise        along the specified axis.    out : array, optional        If provided, the result will be inserted into this array. It should        be of the appropriate shape and dtype.",index_array : ndarray of ints        Array of indices into the array. It has the same shape as `a.shape`        with the dimension along `axis` removed.
"_searchsorted_dispatcher(a, v, side=None, sorter=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"searchsorted(a, v, side='left', sorter=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Find indices where elements should be inserted to maintain order.    Find the indices into a sorted array `a` such that, if the    corresponding elements in `v` were inserted before the indices, the    order of `a` would be preserved.    Assuming that `a` is sorted:    ======  ============================    `side`  returned index `i` satisfies    ======  ============================    left    ``a[i-1] < v <= a[i]``    right   ``a[i-1] <= v < a[i]``    ======  ============================","a : 1-D array_like        Input array. If `sorter` is None, then it must be sorted in        ascending order, otherwise `sorter` must be an array of indices        that sort it.    v : array_like        Values to insert into `a`.    side : {'left', 'right'}, optional        If 'left', the index of the first suitable location found is given.        If 'right', return the last such index.  If there is no suitable        index, return either 0 or N (where N is the length of `a`).    sorter : 1-D array_like, optional        Optional array of integer indices that sort array a into ascending        order. They are typically the result of argsort.",indices : array of ints        Array of insertion points with the same shape as `v`.
"_resize_dispatcher(a, new_shape):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"resize(a, new_shape):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Return a new array with the specified shape.    If the new array is larger than the original array, then the new    array is filled with repeated copies of `a`.  Note that this behavior    is different from a.resize(new_shape) which fills with zeros instead    of repeated copies of `a`.",a : array_like        Array to be resized.,"reshaped_array : ndarray        The new array is formed from the data in the old array, repeated        if necessary to fill out the required number of elements.  The        data are repeated in the order that they are stored in memory."
"_squeeze_dispatcher(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"squeeze(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Remove single-dimensional entries from the shape of an array.,"a : array_like        Input data.    axis : None or int or tuple of ints, optional        .. versionadded:: 1.7.0","squeezed : ndarray        The input array, but with all or a subset of the        dimensions of length 1 removed. This is always `a` itself        or a view into `a`."
"_diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"diagonal(a, offset=0, axis1=0, axis2=1):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Return specified diagonals.    If `a` is 2-D, returns the diagonal of `a` with the given offset,    i.e., the collection of elements of the form ``a[i, i+offset]``.  If    `a` has more than two dimensions, then the axes specified by `axis1`    and `axis2` are used to determine the 2-D sub-array whose diagonal is    returned.  The shape of the resulting array can be determined by    removing `axis1` and `axis2` and appending an index to the right equal    to the size of the resulting diagonals.    In versions of NumPy prior to 1.7, this function always returned a new,    independent array containing a copy of the values in the diagonal.    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,    but depending on this fact is deprecated. Writing to the resulting    array continues to work as it used to, but a FutureWarning is issued.    Starting in NumPy 1.9 it returns a read-only view on the original array.    Attempting to write to the resulting array will produce an error.    In some future release, it will return a read/write view and writing to    the returned array will alter your original array.  The returned array    will have the same type as the input array.    If you don't write to the array returned by this function, then you can    just ignore all of the above.    If you depend on the current behavior, then we suggest copying the    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead    of just ``np.diagonal(a)``. This will work with both past and future    versions of NumPy.","a : array_like        Array from which the diagonals are taken.    offset : int, optional        Offset of the diagonal from the main diagonal.  Can be positive or        negative.  Defaults to main diagonal (0).    axis1 : int, optional        Axis to be used as the first axis of the 2-D sub-arrays from which        the diagonals should be taken.  Defaults to first axis (0).    axis2 : int, optional        Axis to be used as the second axis of the 2-D sub-arrays from        which the diagonals should be taken. Defaults to second axis (1).","array_of_diagonals : ndarray        If `a` is 2-D, then a 1-D array containing the diagonal and of the        same type as `a` is returned unless `a` is a `matrix`, in which case        a 1-D array rather than a (2-D) `matrix` is returned in order to        maintain backward compatibility."
_trace_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Return the sum along diagonals of the array.    If `a` is 2-D, the sum along its diagonal with the given offset    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.    If `a` has more than two dimensions, then the axes specified by axis1 and    axis2 are used to determine the 2-D sub-arrays whose traces are returned.    The shape of the resulting array is the same as that of `a` with `axis1`    and `axis2` removed.","a : array_like        Input array, from which the diagonals are taken.    offset : int, optional        Offset of the diagonal from the main diagonal. Can be both positive        and negative. Defaults to 0.    axis1, axis2 : int, optional        Axes to be used as the first and second axis of the 2-D sub-arrays        from which the diagonals should be taken. Defaults are the first two        axes of `a`.    dtype : dtype, optional        Determines the data-type of the returned array and of the accumulator        where the elements are summed. If dtype has the value None and `a` is        of integer type of precision less than the default integer        precision, then the default integer precision is used. Otherwise,        the precision is the same as that of `a`.    out : ndarray, optional        Array into which the output is placed. Its type is preserved and        it must be of the right shape to hold the output.","sum_along_diagonals : ndarray        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has        larger dimensions, then an array of sums along diagonals is returned."
"_ravel_dispatcher(a, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"ravel(a, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py," Return a contiguous flattened array.    A 1-D array, containing the elements of the input, is returned.  A copy is    made only if needed.    As of NumPy 1.10, the returned array will have the same type as the input    array. (for example, a masked array will be returned for a masked array    input)","a : array_like        Input array.  The elements in `a` are read in the order specified by        `order`, and packed as a 1-D array.    order : {'C','F', 'A', 'K'}, optional","y : array_like        y is an array of the same subtype as `a`, with shape ``(a.size,)``.        Note that matrices are special cased for backward compatibility, if `a`        is a matrix, then y is a 1-D ndarray."
_nonzero_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
nonzero(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Return the indices of the elements that are non-zero.    Returns a tuple of arrays, one for each dimension of `a`,    containing the indices of the non-zero elements in that    dimension. The values in `a` are always tested and returned in    row-major, C-style order.    To group the indices by element, rather than dimension, use `argwhere`,    which returns a row for each non-zero element.    .. note::        When called on a zero-d array or scalar, ``nonzero(a)`` is treated        as ``nonzero(atleast1d(a))``.        ..deprecated:: 1.17.0            Use `atleast1d` explicitly if this behavior is deliberate.",a : array_like        Input array.,tuple_of_arrays : tuple        Indices of elements that are non-zero.
_shape_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
shape(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the shape of an array.,a : array_like        Input array.,shape : tuple of ints        The elements of the shape tuple give the lengths of the        corresponding array dimensions.
"_compress_dispatcher(condition, a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"compress(condition, a, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Return selected slices of an array along given axis.    When working along a given axis, a slice along that axis is returned in    `output` for each index where `condition` evaluates to True. When    working on a 1-D array, `compress` is equivalent to `extract`.","condition : 1-D array of bools        Array that selects which entries to return. If len(condition)        is less than the size of `a` along the given axis, then output is        truncated to the length of the condition array.    a : array_like        Array from which to extract a part.    axis : int, optional        Axis along which to take slices. If None (default), work on the        flattened array.    out : ndarray, optional        Output array.  Its type is preserved and it must be of the right        shape to hold the output.",compressed_array : ndarray        A copy of `a` without the slices along axis for which `condition`        is false.
"_clip_dispatcher(a, a_min, a_max, out=None, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"clip(a, a_min, a_max, out=None, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Clip (limit) the values in an array.    Given an interval, values outside the interval are clipped to    the interval edges.  For example, if an interval of ``[0, 1]``    is specified, values smaller than 0 become 0, and values larger    than 1 become 1.    Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.    No check is performed to ensure ``a_min < a_max``.","a : array_like        Array containing elements to clip.    a_min : scalar or array_like or `None`        Minimum value. If `None`, clipping is not performed on lower        interval edge. Not more than one of `a_min` and `a_max` may be        `None`.    a_max : scalar or array_like or `None`        Maximum value. If `None`, clipping is not performed on upper        interval edge. Not more than one of `a_min` and `a_max` may be        `None`. If `a_min` or `a_max` are array_like, then the three        arrays will be broadcasted to match their shapes.    out : ndarray, optional        The results will be placed in this array. It may be the input        array for in-place clipping.  `out` must be of the right shape        to hold the output.  Its type is preserved.    **kwargs        For other keyword-only arguments, see the        :ref:`ufunc docs <ufuncs.kwargs>`.","clipped_array : ndarray        An array with the elements of `a`, but where values        < `a_min` are replaced with `a_min`, and those > `a_max`        with `a_max`."
"_sum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Sum of array elements over a given axis.,"a : array_like        Elements to sum.    axis : None or int or tuple of ints, optional        Axis or axes along which a sum is performed.  The default,        axis=None, will sum all of the elements of the input array.  If        axis is negative it counts from the last to the first axis.","sum_along_axis : ndarray        An array with the same shape as `a`, with the specified        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar        is returned.  If an output array is specified, a reference to        `out` is returned."
"_any_dispatcher(a, axis=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"any(a, axis=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Test whether any array element along a given axis evaluates to True.    Returns single boolean unless `axis` is not ``None``,"a : array_like        Input array or object that can be converted to an array.    axis : None or int or tuple of ints, optional        Axis or axes along which a logical OR reduction is performed.        The default (`axis` = `None`) is to perform a logical OR over all        the dimensions of the input array. `axis` may be negative, in        which case it counts from the last to the first axis.","any : bool or ndarray        A new boolean or `ndarray` is returned unless `out` is specified,        in which case a reference to `out` is returned."
"_all_dispatcher(a, axis=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"all(a, axis=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Test whether all array elements along a given axis evaluate to True.,"a : array_like        Input array or object that can be converted to an array.    axis : None or int or tuple of ints, optional        Axis or axes along which a logical AND reduction is performed.        The default (`axis` = `None`) is to perform a logical AND over all        the dimensions of the input array. `axis` may be negative, in        which case it counts from the last to the first axis.","all : ndarray, bool        A new boolean or array is returned unless `out` is specified,        in which case a reference to `out` is returned."
"_cumsum_dispatcher(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"cumsum(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the cumulative sum of the elements along a given axis.,"a : array_like        Input array.    axis : int, optional        Axis along which the cumulative sum is computed. The default        (None) is to compute the cumsum over the flattened array.    dtype : dtype, optional        Type of the returned array and of the accumulator in which the        elements are summed.  If `dtype` is not specified, it defaults        to the dtype of `a`, unless `a` has an integer dtype with a        precision less than that of the default platform integer.  In        that case, the default platform integer is used.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output        but the type will be cast if necessary. See `doc.ufuncs`        (Section ""Output arguments"") for more details.","cumsum_along_axis : ndarray.        A new array holding the result is returned unless `out` is        specified, in which case a reference to `out` is returned. The        result has the same size as `a`, and the same shape as `a` if        `axis` is not None or `a` is a 1-d array."
"_ptp_dispatcher(a, axis=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"ptp(a, axis=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Range of values (maximum - minimum) along an axis.    The name of the function comes from the acronym for 'peak to peak'.,"a : array_like        Input values.    axis : None or int or tuple of ints, optional        Axis along which to find the peaks.  By default, flatten the        array.  `axis` may be negative, in        which case it counts from the last to the first axis.","ptp : ndarray        A new array holding the result, unless `out` was        specified, in which case a reference to `out` is returned."
"_amax_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the maximum of an array or maximum along an axis.,"a : array_like        Input data.    axis : None or int or tuple of ints, optional        Axis or axes along which to operate.  By default, flattened input is        used.","amax : ndarray or scalar        Maximum of `a`. If `axis` is None, the result is a scalar value.        If `axis` is given, the result is an array of dimension        ``a.ndim - 1``."
"_amin_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the minimum of an array or minimum along an axis.,"a : array_like        Input data.    axis : None or int or tuple of ints, optional        Axis or axes along which to operate.  By default, flattened input is        used.","amin : ndarray or scalar        Minimum of `a`. If `axis` is None, the result is a scalar value.        If `axis` is given, the result is an array of dimension        ``a.ndim - 1``."
_alen_dispathcer(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
alen(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the length of the first dimension of the input array.,a : array_like       Input array.,alen : int       Length of the first dimension of `a`.
"_prod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"prod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the product of array elements over a given axis.,"a : array_like        Input data.    axis : None or int or tuple of ints, optional        Axis or axes along which a product is performed.  The default,        axis=None, will calculate the product of all the elements in the        input array. If axis is negative it counts from the last to the        first axis.","product_along_axis : ndarray, see `dtype` parameter above.        An array shaped as `a` but with the specified axis removed.        Returns a reference to `out` if specified."
"_cumprod_dispatcher(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"cumprod(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the cumulative product of elements along a given axis.,"a : array_like        Input array.    axis : int, optional        Axis along which the cumulative product is computed.  By default        the input is flattened.    dtype : dtype, optional        Type of the returned array, as well as of the accumulator in which        the elements are multiplied.  If *dtype* is not specified, it        defaults to the dtype of `a`, unless `a` has an integer dtype with        a precision less than that of the default platform integer.  In        that case, the default platform integer is used instead.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output        but the type of the resulting values will be cast if necessary.","cumprod : ndarray        A new array holding the result is returned unless `out` is        specified, in which case a reference to out is returned."
_ndim_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
ndim(a):,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the number of dimensions of an array.,"a : array_like        Input array.  If it is not already an ndarray, a conversion is        attempted.",number_of_dimensions : int        The number of dimensions in `a`.  Scalars are zero-dimensional.
"_size_dispatcher(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"size(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the number of elements along a given axis.,"a : array_like        Input data.    axis : int, optional        Axis along which the elements are counted.  By default, give        the total number of elements.",element_count : int        Number of elements along the specified axis.
"_around_dispatcher(a, decimals=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"around(a, decimals=0, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Evenly round to the given number of decimals.,"a : array_like        Input data.    decimals : int, optional        Number of decimal places to round to (default: 0).  If        decimals is negative, it specifies the number of positions to        the left of the decimal point.    out : ndarray, optional        Alternative output array in which to place the result. It must have        the same shape as the expected output, but the type of the output        values will be cast if necessary. See `doc.ufuncs` (Section        ""Output arguments"") for details.","rounded_array : ndarray        An array of the same type as `a`, containing the rounded values.        Unless `out` was specified, a new array is created.  A reference to        the result is returned."
"_mean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Compute the arithmetic mean along the specified axis.    Returns the average of the array elements.  The average is taken over    the flattened array by default, otherwise over the specified axis.    `float64` intermediate and return values are used for integer inputs.","a : array_like        Array containing numbers whose mean is desired. If `a` is not an        array, a conversion is attempted.    axis : None or int or tuple of ints, optional        Axis or axes along which the means are computed. The default is to        compute the mean of the flattened array.","m : ndarray, see dtype parameter above        If `out=None`, returns a new array containing the mean values,        otherwise a reference to the output array is returned."
_std_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Compute the standard deviation along the specified axis.    Returns the standard deviation, a measure of the spread of a distribution,    of the array elements. The standard deviation is computed for the    flattened array by default, otherwise over the specified axis.","a : array_like        Calculate the standard deviation of these values.    axis : None or int or tuple of ints, optional        Axis or axes along which the standard deviation is computed. The        default is to compute the standard deviation of the flattened array.","standard_deviation : ndarray, see dtype parameter above.        If `out` is None, return a new array containing the standard deviation,        otherwise return a reference to the output array."
_var_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,,,
"var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,"     Compute the variance along the specified axis.    Returns the variance of the array elements, a measure of the spread of a    distribution.  The variance is computed for the flattened array by    default, otherwise over the specified axis.","a : array_like        Array containing numbers whose variance is desired.  If `a` is not an        array, a conversion is attempted.    axis : None or int or tuple of ints, optional        Axis or axes along which the variance is computed.  The default is to        compute the variance of the flattened array.","variance : ndarray, see dtype parameter above        If ``out=None``, returns a new array containing the variance;        otherwise, a reference to the output array is returned."
"round_(a, decimals=0, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Round an array to the given number of decimals.    See Also    --------    around : equivalent function; see for details.,,
"product(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the product of array elements over a given axis.    See Also    --------    prod : equivalent function; see for details.,,
"cumproduct(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Return the cumulative product over the given axis.    See Also    --------    cumprod : equivalent function; see for details.,,
"sometrue(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Check whether some values are true.    Refer to `any` for full documentation.    See Also    --------    any : equivalent function; see for details.,,
"alltrue(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/fromnumeric.py,     Check if all elements of input array are true.    See Also    --------    numpy.all : Equivalent function; see for details.,,
,https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,,,
"_index_deprecate(i, stacklevel=2):",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,,,
"_linspace_dispatcher(start, stop, num=None, endpoint=None, retstep=None,",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,,,
"linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,"     Return evenly spaced numbers over a specified interval.    Returns `num` evenly spaced samples, calculated over the    interval [`start`, `stop`].    The endpoint of the interval can optionally be excluded.    .. versionchanged:: 1.16.0        Non-scalar `start` and `stop` are now supported.","start : array_like        The starting value of the sequence.    stop : array_like        The end value of the sequence, unless `endpoint` is set to False.        In that case, the sequence consists of all but the last of ``num + 1``        evenly spaced samples, so that `stop` is excluded.  Note that the step        size changes when `endpoint` is False.    num : int, optional        Number of samples to generate. Default is 50. Must be non-negative.    endpoint : bool, optional        If True, `stop` is the last sample. Otherwise, it is not included.        Default is True.    retstep : bool, optional        If True, return (`samples`, `step`), where `step` is the spacing        between samples.    dtype : dtype, optional        The type of the output array.  If `dtype` is not given, infer the data        type from the other input arguments.","samples : ndarray        There are `num` equally spaced samples in the closed interval        ``[start, stop]`` or the half-open interval ``[start, stop)``        (depending on whether `endpoint` is True or False).    step : float, optional        Only returned if `retstep` is True"
"_logspace_dispatcher(start, stop, num=None, endpoint=None, base=None,",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,,,
"logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None,",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,"     Return numbers spaced evenly on a log scale.    In linear space, the sequence starts at ``base ** start``    (`base` to the power of `start`) and ends with ``base ** stop``    (see `endpoint` below).    .. versionchanged:: 1.16.0        Non-scalar `start` and `stop` are now supported.","start : array_like        ``base ** start`` is the starting value of the sequence.    stop : array_like        ``base ** stop`` is the final value of the sequence, unless `endpoint`        is False.  In that case, ``num + 1`` values are spaced over the        interval in log-space, of which all but the last (a sequence of        length `num`) are returned.    num : integer, optional        Number of samples to generate.  Default is 50.    endpoint : boolean, optional        If true, `stop` is the last sample. Otherwise, it is not included.        Default is True.    base : float, optional        The base of the log space. The step size between the elements in        ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.        Default is 10.0.    dtype : dtype        The type of the output array.  If `dtype` is not given, infer the data        type from the other input arguments.    axis : int, optional        The axis in the result to store the samples.  Relevant only if start        or stop are array-like.  By default (0), the samples will be along a        new axis inserted at the beginning. Use -1 to get an axis at the end.","samples : ndarray        `num` samples, equally spaced on a log scale."
"_geomspace_dispatcher(start, stop, num=None, endpoint=None, dtype=None,",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,,,
"geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/core/function_base.py,"     Return numbers spaced evenly on a log scale (a geometric progression).    This is similar to `logspace`, but with endpoints specified directly.    Each output sample is a constant multiple of the previous.    .. versionchanged:: 1.16.0        Non-scalar `start` and `stop` are now supported.","start : array_like        The starting value of the sequence.    stop : array_like        The final value of the sequence, unless `endpoint` is False.        In that case, ``num + 1`` values are spaced over the        interval in log-space, of which all but the last (a sequence of        length `num`) are returned.    num : integer, optional        Number of samples to generate.  Default is 50.    endpoint : boolean, optional        If true, `stop` is the last sample. Otherwise, it is not included.        Default is True.    dtype : dtype        The type of the output array.  If `dtype` is not given, infer the data        type from the other input arguments.    axis : int, optional        The axis in the result to store the samples.  Relevant only if start        or stop are array-like.  By default (0), the samples will be along a        new axis inserted at the beginning. Use -1 to get an axis at the end.","samples : ndarray        `num` samples, equally spaced on a log scale."
,https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py,,,
_fr0(a):,https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py," fix rank-0 --> rank-1 if a.ndim == 0:        a = a.copy()        a.shape = (1,) return a

",,
_fr1(a):,https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py," fix rank > 0 --> rank-0 if a.size == 1:        a = a.copy()        a.shape = () return a
class MachArLike(object):",,
"_register_type(machar, bytepat):",https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py,,,
_register_known_types():,https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py,,,
_get_machar(ftype):,https://github.com//numpy/numpy/blob/master/numpy/core/getlimits.py,"  Get MachAr instance or MachAr-like instance    Get parameters for floating point type, by first trying signatures of    various known floating point types, then, if none match, attempting to    identify parameters by analysis.",ftype : class        Numpy floating point type class (e.g. ``np.float64``),ma_like : instance of :class:`MachAr` or :class:`MachArLike`        Object giving floating point parameters for `ftype`.
,https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,,,
"empty_like(prototype, dtype=None, order=None, subok=None, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     empty_like(prototype, dtype=None, order='K', subok=True, shape=None)    Return a new array with the same shape and type as a given array.","prototype : array_like        The shape and data-type of `prototype` define these same attributes        of the returned array.    dtype : data-type, optional        Overrides the data type of the result.",out : ndarray        Array of uninitialized (arbitrary) data with the same        shape and type as `prototype`.
"concatenate(arrays, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     concatenate((a1, a2, ...), axis=0, out=None)    Join a sequence of arrays along an existing axis.","a1, a2, ... : sequence of array_like        The arrays must have the same shape, except in the dimension        corresponding to `axis` (the first, by default).    axis : int, optional        The axis along which the arrays will be joined.  If axis is None,        arrays are flattened before use.  Default is 0.    out : ndarray, optional        If provided, the destination to place the result. The shape must be        correct, matching that of what concatenate would have returned if no        out argument were specified.",res : ndarray        The concatenated array.
"inner(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     inner(a, b)    Inner product of two arrays.    Ordinary inner product of vectors for 1-D arrays (without complex    conjugation), in higher dimensions a sum product over the last axes.","a, b : array_like        If `a` and `b` are nonscalar, their last dimensions must match.",out : ndarray        `out.shape = a.shape[:-1] + b.shape[:-1]`
"where(condition, x=None, y=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     where(condition, [x, y])    Return elements chosen from `x` or `y` depending on `condition`.    .. note::        When only `condition` is provided, this function is a shorthand for        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be        preferred, as it behaves correctly for subclasses. The rest of this        documentation covers only the case where all three arguments are        provided.","condition : array_like, bool        Where True, yield `x`, otherwise yield `y`.    x, y : array_like        Values from which to choose. `x`, `y` and `condition` need to be        broadcastable to some shape.","out : ndarray        An array with elements from `x` where `condition` is True, and elements        from `y` elsewhere."
"lexsort(keys, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     lexsort(keys, axis=-1)    Perform an indirect stable sort using a sequence of keys.    Given multiple sorting keys, which can be interpreted as columns in a    spreadsheet, lexsort returns an array of integer indices that describes    the sort order by multiple columns. The last key in the sequence is used    for the primary sort order, the second-to-last key for the secondary sort    order, and so on. The keys argument must be a sequence of objects that    can be converted to arrays of the same shape. If a 2D array is provided    for the keys argument, it's rows are interpreted as the sorting keys and    sorting is according to the last row, second last row etc.","keys : (k, N) array or tuple containing k (N,)-shaped sequences        The `k` different ""columns"" to be sorted.  The last column (or row if        `keys` is a 2D array) is the primary sort key.    axis : int, optional        Axis to be indirectly sorted.  By default, sort over the last axis.","indices : (N,) ndarray of ints        Array of indices that sort the keys along the specified axis."
"can_cast(from_, to, casting=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     can_cast(from_, to, casting='safe')    Returns True if cast between data types can occur according to the    casting rule.  If from is a scalar or array scalar, also returns    True if the scalar value can be cast without overflow or truncation    to an integer.","from_ : dtype, dtype specifier, scalar, or array        Data type, scalar, or array to cast from.    to : dtype or dtype specifier        Data type to cast to.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        Controls what kind of data casting may occur.",out : bool        True if cast can occur according to the casting rule.
min_scalar_type(a):,https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     min_scalar_type(a)    For scalar ``a``, returns the data type with the smallest size    and smallest scalar kind which can hold its value.  For non-scalar    array ``a``, returns the vector's dtype unmodified.    Floating point values are not demoted to integers,    and complex values are not demoted to floats.",a : scalar or array_like        The value whose minimal data type is to be found.,out : dtype        The minimal data type.
result_type(*arrays_and_dtypes):,https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     result_type(*arrays_and_dtypes)    Returns the type that results from applying the NumPy    type promotion rules to the arguments.    Type promotion in NumPy works similarly to the rules in languages    like C++, with some slight differences.  When both scalars and    arrays are used, the array's type takes precedence and the actual value    of the scalar is taken into account.    For example, calculating 3*a, where a is an array of 32-bit floats,    intuitively should result in a 32-bit float output.  If the 3 is a    32-bit integer, the NumPy rules indicate it can't convert losslessly    into a 32-bit float, so a 64-bit float should be the result type.    By examining the value of the constant, '3', we see that it fits in    an 8-bit integer, which can be cast losslessly into the 32-bit float.",arrays_and_dtypes : list of arrays and dtypes        The operands of some operation whose result type is needed.,out : dtype        The result type.
"dot(a, b, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     dot(a, b, out=None)    Dot product of two arrays. Specifically,    - If both `a` and `b` are 1-D arrays, it is inner product of vectors      (without complex conjugation).    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,      but using :func:`matmul` or ``a @ b`` is preferred.    - If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`      and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over      the last axis of `a` and `b`.    - If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a      sum product over the last axis of `a` and the second-to-last axis of `b`::        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])","a : array_like        First argument.    b : array_like        Second argument.    out : ndarray, optional        Output argument. This must have the exact kind that would be returned        if it was not used. In particular, it must have the right type, must be        C-contiguous, and its dtype must be the dtype that would be returned        for `dot(a,b)`. This is a performance feature. Therefore, if these        conditions are not met, an exception is raised, instead of attempting        to be flexible.","output : ndarray        Returns the dot product of `a` and `b`.  If `a` and `b` are both        scalars or both 1-D arrays then a scalar is returned; otherwise        an array is returned.        If `out` is given, then it is returned."
"vdot(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     vdot(a, b)    Return the dot product of two vectors.    The vdot(`a`, `b`) function handles complex numbers differently than    dot(`a`, `b`).  If the first argument is complex the complex conjugate    of the first argument is used for the calculation of the dot product.    Note that `vdot` handles multidimensional arrays differently than `dot`:    it does *not* perform a matrix product, but flattens input arguments    to 1-D vectors first. Consequently, it should only be used for vectors.",a : array_like        If `a` is complex the complex conjugate is taken before calculation        of the dot product.    b : array_like        Second argument to the dot product.,"output : ndarray        Dot product of `a` and `b`.  Can be an int, float, or        complex depending on the types of `a` and `b`."
"bincount(x, weights=None, minlength=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     bincount(x, weights=None, minlength=0)    Count number of occurrences of each value in array of non-negative ints.    The number of bins (of size 1) is one larger than the largest value in    `x`. If `minlength` is specified, there will be at least this number    of bins in the output array (though it will be longer if necessary,    depending on the contents of `x`).    Each bin gives the number of occurrences of its index value in `x`.    If `weights` is specified the input array is weighted by it, i.e. if a    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead    of ``out[n] += 1``.","x : array_like, 1 dimension, nonnegative ints        Input array.    weights : array_like, optional        Weights, array of the same shape as `x`.    minlength : int, optional        A minimum number of bins for the output array.",out : ndarray of ints        The result of binning the input array.        The length of `out` is equal to ``np.amax(x)+1``.
"ravel_multi_index(multi_index, dims, mode=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     ravel_multi_index(multi_index, dims, mode='raise', order='C')    Converts a tuple of index arrays into an array of flat    indices, applying boundary modes to the multi-index.","multi_index : tuple of array_like        A tuple of integer arrays, one array for each dimension.    dims : tuple of ints        The shape of array into which the indices from ``multi_index`` apply.    mode : {'raise', 'wrap', 'clip'}, optional        Specifies how out-of-bounds indices are handled.  Can specify        either one mode or a tuple of modes, one mode per index.",raveled_indices : ndarray        An array of indices into the flattened version of an array        of dimensions ``dims``.
"unravel_index(indices, shape=None, order=None, dims=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     unravel_index(indices, shape, order='C')    Converts a flat index or array of flat indices into a tuple    of coordinate arrays.","indices : array_like        An integer array whose elements are indices into the flattened        version of an array of dimensions ``shape``. Before version 1.6.0,        this function accepted just one index value.    shape : tuple of ints        The shape of the array to use for unraveling ``indices``.",unraveled_coords : tuple of ndarray        Each array in the tuple has the same shape as the ``indices``        array.
"copyto(dst, src, casting=None, where=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     copyto(dst, src, casting='same_kind', where=True)    Copies values from one array to another, broadcasting as necessary.    Raises a TypeError if the `casting` rule is violated, and if    `where` is provided, it selects which elements to copy.    .. versionadded:: 1.7.0","dst : ndarray        The array into which values are copied.    src : array_like        The array from which values are copied.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        Controls what kind of data casting may occur when copying.",
"putmask(a, mask, values):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     putmask(a, mask, values)    Changes elements of an array based on conditional and input values.    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.    If `values` is not the same size as `a` and `mask` then it will repeat.    This gives behavior different from ``a[mask] = values``.",a : array_like        Target array.    mask : array_like        Boolean mask array. It has to be the same shape as `a`.    values : array_like        Values to put into `a` where `mask` is True. If `values` is smaller        than `a` it will be repeated.,
"packbits(a, axis=None, bitorder='big'):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     packbits(a, axis=None, bitorder='big')    Packs the elements of a binary-valued array into bits in a uint8 array.    The result is padded to full bytes by inserting zero bits at the end.","a : array_like        An array of integers or booleans whose elements should be packed to        bits.    axis : int, optional        The dimension over which bit-packing is done.        ``None`` implies packing the flattened array.    bitorder : {'big', 'little'}, optional        The order of the input bits. 'big' will mimic bin(val),        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011 => ``, 'little' will        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.        Defaults to 'big'.","packed : ndarray        Array of type uint8 whose elements represent bits corresponding to the        logical (0 or nonzero) value of the input elements. The shape of        `packed` has the same number of dimensions as the input (unless `axis`        is None, in which case the output is 1-D)."
"unpackbits(a, axis=None, count=None, bitorder='big'):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     unpackbits(a, axis=None, count=None, bitorder='big')    Unpacks elements of a uint8 array into a binary-valued output array.    Each element of `a` represents a bit-field that should be unpacked    into a binary-valued output array. The shape of the output array is    either 1-D (if `axis` is ``None``) or the same shape as the input    array with unpacking done along the axis specified.","a : ndarray, uint8 type       Input array.    axis : int, optional        The dimension over which bit-unpacking is done.        ``None`` implies unpacking the flattened array.    count : int or None, optional        The number of elements to unpack along `axis`, provided as a way        of undoing the effect of packing a size that is not a multiple        of eight. A non-negative number means to only unpack `count`        bits. A negative number means to trim off that many bits from        the end. ``None`` means to unpack the entire array (the        default). Counts larger than the available number of bits will        add zero padding to the output. Negative counts must not        exceed the available number of bits.","unpacked : ndarray, uint8 type       The elements are binary-valued (0 or 1)."
"shares_memory(a, b, max_work=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     shares_memory(a, b, max_work=None)    Determine if two arrays share memory","a, b : ndarray        Input arrays    max_work : int, optional        Effort to spend on solving the overlap problem (maximum number        of candidate solutions to consider). The following special        values are recognized:",out : bool
"may_share_memory(a, b, max_work=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     may_share_memory(a, b, max_work=None)    Determine if two arrays might share memory    A return of True does not necessarily mean that the two arrays    share any element.  It just means that they *might*.    Only the memory bounds of a and b are checked by default.","a, b : ndarray        Input arrays    max_work : int, optional        Effort to spend on solving the overlap problem.  See        `shares_memory` for details.  Default for ``may_share_memory``        is to do a bounds check.",out : bool
"is_busday(dates, weekmask=None, holidays=None, busdaycal=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)    Calculates which of the given dates are valid days, and which are not.    .. versionadded:: 1.7.0","dates : array_like of datetime64[D]        The array of dates to process.    weekmask : str or array_like of bool, optional        A seven-element array indicating which of Monday through Sunday are        valid days. May be specified as a length-seven list or array, like        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string        like ""Mon Tue Wed Thu Fri"", made up of 3-character abbreviations for        weekdays, optionally separated by white space. Valid abbreviations        are: Mon Tue Wed Thu Fri Sat Sun    holidays : array_like of datetime64[D], optional        An array of dates to consider as invalid dates.  They may be        specified in any order, and NaT (not-a-time) dates are ignored.        This list is saved in a normalized form that is suited for        fast calculations of valid days.    busdaycal : busdaycalendar, optional        A `busdaycalendar` object which specifies the valid days. If this        parameter is provided, neither weekmask nor holidays may be        provided.    out : array of bool, optional        If provided, this array is filled with the result.","out : array of bool        An array with the same shape as ``dates``, containing True for        each valid day, and False for each invalid day."
"busday_offset(dates, offsets, roll=None, weekmask=None, holidays=None,",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)    First adjusts the date to fall on a valid day according to    the ``roll`` rule, then applies offsets to the given dates    counted in valid days.    .. versionadded:: 1.7.0","dates : array_like of datetime64[D]        The array of dates to process.    offsets : array_like of int        The array of offsets, which is broadcast with ``dates``.    roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional        How to treat dates that do not fall on a valid day. The default        is 'raise'.","out : array of datetime64[D]        An array with a shape from broadcasting ``dates`` and ``offsets``        together, containing the dates with offsets applied."
"busday_count(begindates, enddates, weekmask=None, holidays=None,",https://github.com//numpy/numpy/blob/master/numpy/core/multiarray.py,"     busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)    Counts the number of valid days between `begindates` and    `enddates`, not including the day of `enddates`.    If ``enddates`` specifies a date value that is earlier than the    corresponding ``begindates`` date value, the count will be negative.    .. versionadded:: 1.7.0","begindates : array_like of datetime64[D]        The array of the first dates for counting.    enddates : array_like of datetime64[D]        The array of the end dates for counting, which are excluded        from the count themselves.    weekmask : str or array_like of bool, optional        A seven-element array indicating which of Monday through Sunday are        valid days. May be specified as a length-seven list or array, like        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string        like ""Mon Tue Wed Thu Fri"", made up of 3-character abbreviations for        weekdays, optionally separated by white space. Valid abbreviations        are: Mon Tue Wed Thu Fri Sat Sun    holidays : array_like of datetime64[D], optional        An array of dates to consider as invalid dates.  They may be        specified in any order, and NaT (not-a-time) dates are ignored.        This list is saved in a normalized form that is suited for        fast calculations of valid days.    busdaycal : busdaycalendar, optional        A `busdaycalendar` object which specifies the valid days. If this        parameter is provided, neither weekmask nor holidays may be        provided.    out : array of int, optional        If provided, this array is filled with the result.","out : array of int        An array with a shape from broadcasting ``begindates`` and ``enddates``        together, containing the number of valid days between        the begin and end dates."
,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"loads(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     The warning raised when casting a complex dtype to a real dtype.    As implemented, casting a complex number to a real discards its imaginary    part, but this behavior may not be what the user actually wants.",,
"_zeros_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"zeros_like(a, dtype=None, order='K', subok=True, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return an array of zeros with the same shape and type as a given array.,"a : array_like        The shape and data-type of `a` define these same attributes of        the returned array.    dtype : data-type, optional        Overrides the data type of the result.",out : ndarray        Array of zeros with the same shape and type as `a`.
"ones(shape, dtype=None, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Return a new array of given shape and type, filled with ones.","shape : int or sequence of ints        Shape of the new array, e.g., ``(2, 3)`` or ``2``.    dtype : data-type, optional        The desired data-type for the array, e.g., `numpy.int8`.  Default is        `numpy.float64`.    order : {'C', 'F'}, optional, default: C        Whether to store multi-dimensional data in row-major        (C-style) or column-major (Fortran-style) order in        memory.","out : ndarray        Array of ones with the given shape, dtype, and order."
"_ones_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"ones_like(a, dtype=None, order='K', subok=True, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return an array of ones with the same shape and type as a given array.,"a : array_like        The shape and data-type of `a` define these same attributes of        the returned array.    dtype : data-type, optional        Overrides the data type of the result.",out : ndarray        Array of ones with the same shape and type as `a`.
"full(shape, fill_value, dtype=None, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Return a new array of given shape and type, filled with `fill_value`.","shape : int or sequence of ints        Shape of the new array, e.g., ``(2, 3)`` or ``2``.    fill_value : scalar        Fill value.    dtype : data-type, optional        The desired data-type for the array  The default, `None`, means         `np.array(fill_value).dtype`.    order : {'C', 'F'}, optional        Whether to store multidimensional data in C- or Fortran-contiguous        (row- or column-wise) order in memory.","out : ndarray        Array of `fill_value` with the given shape, dtype, and order."
"_full_like_dispatcher(a, fill_value, dtype=None, order=None, subok=None, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return a full array with the same shape and type as a given array.,"a : array_like        The shape and data-type of `a` define these same attributes of        the returned array.    fill_value : scalar        Fill value.    dtype : data-type, optional        Overrides the data type of the result.    order : {'C', 'F', 'A', or 'K'}, optional        Overrides the memory layout of the result. 'C' means C-order,        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,        'C' otherwise. 'K' means match the layout of `a` as closely        as possible.    subok : bool, optional.        If True, then the newly created array will use the sub-class        type of 'a', otherwise it will be a base-class array. Defaults        to True.    shape : int or sequence of ints, optional.        Overrides the shape of the result. If order='K' and the number of        dimensions is unchanged, will try to keep order, otherwise,        order='C' is implied.",out : ndarray        Array of `fill_value` with the same shape and type as `a`.
"_count_nonzero_dispatcher(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"count_nonzero(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Counts the number of non-zero values in the array ``a``.    The word ""non-zero"" is in reference to the Python 2.x    built-in method ``__nonzero__()`` (renamed ``__bool__()``    in Python 3.x) of Python objects that tests an object's    ""truthfulness"". For example, any number is considered    truthful if it is nonzero, whereas any string is considered    truthful if it is not the empty string. Thus, this function    (recursively) counts how many elements in ``a`` (and in    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``    method evaluated to ``True``.","a : array_like        The array for which to count non-zeros.    axis : int or tuple, optional        Axis or tuple of axes along which to count non-zeros.        Default is None, meaning that non-zeros will be counted        along a flattened version of ``a``.","count : int or array of int        Number of non-zero values in the array along a given axis.        Otherwise, the total number of non-zero values in the array        is returned."
isfortran(a):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Check if the array is Fortran contiguous but *not* C contiguous.    This function is obsolete and, because of changes due to relaxed stride    checking, its return value for the same array may differ for versions    of NumPy >= 1.10.0 and previous versions. If you only want to check if an    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.",a : ndarray        Input array.,isfortran : bool        Returns True if the array is Fortran contiguous but *not* C contiguous.
_argwhere_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
argwhere(a):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Find the indices of array elements that are non-zero, grouped by element.",a : array_like        Input data.,index_array : ndarray        Indices of elements that are non-zero. Indices are grouped by element.
_flatnonzero_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
flatnonzero(a):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return indices that are non-zero in the flattened version of a.    This is equivalent to np.nonzero(np.ravel(a))[0].,a : array_like        Input data.,"res : ndarray        Output array, containing the indices of the elements of `a.ravel()`        that are non-zero."
_mode_from_name(mode):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"_correlate_dispatcher(a, v, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"correlate(a, v, mode='valid'):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Cross-correlation of two 1-dimensional sequences.    This function computes the correlation as generally defined in signal    processing texts::        c_{av}[k] = sum_n a[n+k] * conj(v[n])    with a and v sequences being zero-padded where necessary and conj being    the conjugate.,"a, v : array_like        Input sequences.    mode : {'valid', 'same', 'full'}, optional        Refer to the `convolve` docstring.  Note that the default        is 'valid', unlike `convolve`, which uses 'full'.    old_behavior : bool        `old_behavior` was removed in NumPy 1.10. If you need the old        behavior, use `multiarray.correlate`.",out : ndarray        Discrete cross-correlation of `a` and `v`.
"_convolve_dispatcher(a, v, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"convolve(a, v, mode='full'):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Returns the discrete, linear convolution of two one-dimensional sequences.    The convolution operator is often seen in signal processing, where it    models the effect of a linear time-invariant system on a signal [1]_.  In    probability theory, the sum of two independent random variables is    distributed according to the convolution of their individual    distributions.    If `v` is longer than `a`, the arrays are swapped before computation.","a : (N,) array_like        First one-dimensional input array.    v : (M,) array_like        Second one-dimensional input array.    mode : {'full', 'valid', 'same'}, optional        'full':          By default, mode is 'full'.  This returns the convolution          at each point of overlap, with an output shape of (N+M-1,). At          the end-points of the convolution, the signals do not overlap          completely, and boundary effects may be seen.","out : ndarray        Discrete, linear convolution of `a` and `v`."
"_outer_dispatcher(a, b, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"outer(a, b, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Compute the outer product of two vectors.    Given two vectors, ``a = [a0, a1, ..., aM]`` and    ``b = [b0, b1, ..., bN]``,    the outer product [1]_ is::      [[a0*b0  a0*b1 ... a0*bN ]       [a1*b0    .       [ ...          .       [aM*b0            aM*bN ]]","a : (M,) array_like        First input vector.  Input is flattened if        not already 1-dimensional.    b : (N,) array_like        Second input vector.  Input is flattened if        not already 1-dimensional.    out : (M, N) ndarray, optional        A location where the result is stored","out : (M, N) ndarray        ``out[i, j] = a[i] * b[j]``"
"_tensordot_dispatcher(a, b, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"tensordot(a, b, axes=2):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Compute tensor dot product along specified axes.    Given two tensors, `a` and `b`, and an array_like object containing    two array_like objects, ``(a_axes, b_axes)``, sum the products of    `a`'s and `b`'s elements (components) over the axes specified by    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions    of `a` and the first ``N`` dimensions of `b` are summed over.","a, b : array_like        Tensors to ""dot"".",output : ndarray        The tensor dot product of the input.  
"_roll_dispatcher(a, shift, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"roll(a, shift, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Roll array elements along a given axis.    Elements that roll beyond the last position are re-introduced at    the first.,"a : array_like        Input array.    shift : int or tuple of ints        The number of places by which elements are shifted.  If a tuple,        then `axis` must be a tuple of the same size, and each of the        given axes is shifted by the corresponding number.  If an int        while `axis` is a tuple of ints, then the same value is used for        all given axes.    axis : int or tuple of ints, optional        Axis or axes along which elements are shifted.  By default, the        array is flattened before shifting, after which the original        shape is restored.","res : ndarray        Output array, with the same shape as `a`."
"_rollaxis_dispatcher(a, axis, start=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"rollaxis(a, axis, start=0):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Roll the specified axis backwards, until it lies in a given position.    This function continues to be supported for backward compatibility, but you    should prefer `moveaxis`. The `moveaxis` function was added in NumPy    1.11.","a : ndarray        Input array.    axis : int        The axis to roll backwards.  The positions of the other axes do not        change relative to one another.    start : int, optional        The axis is rolled until it lies before this position.  The default,        0, results in a ""complete"" roll.","res : ndarray        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier        NumPy versions a view of `a` is returned only if the order of the        axes is changed, otherwise the input array is returned."
"normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Normalizes an axis argument into a tuple of non-negative integer axes.    This handles shorthands such as ``1`` and converts them to ``(1,)``,    as well as performing the handling of negative indices covered by    `normalize_axis_index`.    By default, this forbids axes from being specified multiple times.    Used internally by multi-axis-checking logic.    .. versionadded:: 1.13.0","axis : int, iterable of int        The un-normalized index or indices of the axis.    ndim : int        The number of dimensions of the array that `axis` should be normalized        against.    argname : str, optional        A prefix to put before the error message, typically the name of the        argument.    allow_duplicate : bool, optional        If False, the default, disallow an axis from being specified twice.","normalized_axes : tuple of int        The normalized axis index, such that `0 <= normalized_axis < ndim`"
"_moveaxis_dispatcher(a, source, destination):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"moveaxis(a, source, destination):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Move axes of an array to new positions.    Other axes remain in their original order.    .. versionadded:: 1.11.0,a : np.ndarray        The array whose axes should be reordered.    source : int or sequence of int        Original positions of the axes to move. These must be unique.    destination : int or sequence of int        Destination positions for each of the original axes. These must also be        unique.,result : np.ndarray        Array with moved axes. This array is a view of the input array.
"_move_axis_to_0(a, axis):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"_cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Return the cross product of two (arrays of) vectors.    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors    are defined by the last axis of `a` and `b` by default, and these axes    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is    2, the third component of the input vector is assumed to be zero and the    cross product calculated accordingly.  In cases where both input vectors    have dimension 2, the z-component of the cross product is returned.","a : array_like        Components of the first vector(s).    b : array_like        Components of the second vector(s).    axisa : int, optional        Axis of `a` that defines the vector(s).  By default, the last axis.    axisb : int, optional        Axis of `b` that defines the vector(s).  By default, the last axis.    axisc : int, optional        Axis of `c` containing the cross product vector(s).  Ignored if        both input vectors have dimension 2, as the return is scalar.        By default, the last axis.    axis : int, optional        If defined, the axis of `a`, `b` and `c` that defines the vector(s)        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.",c : ndarray        Vector cross product(s).
"indices(dimensions, dtype=int, sparse=False):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Return an array representing the indices of a grid.    Compute an array where the subarrays contain index values 0, 1, ...    varying only along the corresponding axis.","dimensions : sequence of ints        The shape of the grid.    dtype : dtype, optional        Data type of the result.    sparse : boolean, optional        Return a sparse representation of the grid instead of a dense        representation. Default is False.","grid : one ndarray or tuple of ndarrays        If sparse is False:            Returns one array of grid indices,            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.        If sparse is True:            Returns a tuple of arrays, with            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with            dimensions[i] in the ith place"
"fromfunction(function, shape, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Construct an array by executing a function over each coordinate.    The resulting array therefore has a value ``fn(x, y, z)`` at    coordinate ``(x, y, z)``.","function : callable        The function is called with N parameters, where N is the rank of        `shape`.  Each parameter represents the coordinates of the array        varying along a specific axis.  For example, if `shape`        were ``(2, 2)``, then the parameters would be        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``    shape : (N,) tuple of ints        Shape of the output array, which also determines the shape of        the coordinate arrays passed to `function`.    dtype : data-type, optional        Data-type of the coordinate arrays passed to `function`.        By default, `dtype` is float.","fromfunction : any        The result of the call to `function` is passed back directly.        Therefore the shape of `fromfunction` is completely determined by        `function`.  If `function` returns a scalar value, the shape of        `fromfunction` would not match the `shape` parameter."
"_frombuffer(buf, dtype, shape, order):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
isscalar(num):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Returns True if the type of `num` is a scalar type.,"num : any        Input argument, can be of any type and shape.","val : bool        True if `num` is a scalar type, False if it is not."
"binary_repr(num, width=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Return the binary representation of the input number as a string.    For negative numbers, if width is not given, a minus sign is added to the    front. If width is given, the two's complement of the number is    returned, with respect to that width.    In a two's-complement system negative numbers are represented by the two's    complement of the absolute value. This is the most common method of    representing signed integers on computers [1]_. A N-bit two's-complement    system can represent every integer in the range    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.","num : int        Only an integer decimal number can be used.    width : int, optional        The length of the returned string if `num` is positive, or the length        of the two's complement if `num` is negative, provided that `width` is        at least a sufficient number of bits for `num` to be represented in the        designated form.",bin : str        Binary representation of `num` or two's complement of `num`.
"base_repr(number, base=2, padding=0):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return a string representation of a number in the given base system.,"number : int        The value to convert. Positive and negative values are handled.    base : int, optional        Convert `number` to the `base` number system. The valid range is 2-36,        the default value is 2.    padding : int, optional        Number of zeros padded on the left. Default is 0 (no padding).",out : str        String representation of `number` in `base` system.
load(file):,https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Wrapper around cPickle.load which accepts either a file-like object or    a filename.    Note that the NumPy binary format is not based on pickle/cPickle anymore.    For details on the preferred way of loading and saving files, see `load`    and `save`.    See Also    --------    load, save",,
"_maketup(descr, val):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"identity(n, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,     Return the identity array.    The identity array is a square array with ones on    the main diagonal.,"n : int        Number of rows (and columns) in `n` x `n` output.    dtype : data-type, optional        Data-type of the output.  Defaults to ``float``.","out : ndarray        `n` x `n` array with its main diagonal set to one,        and all other elements 0."
"_allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Returns True if two arrays are element-wise equal within a tolerance.    The tolerance values are positive, typically very small numbers.  The    relative difference (`rtol` * abs(`b`)) and the absolute difference    `atol` are added together to compare against the absolute difference    between `a` and `b`.    If either array contains one or more NaNs, False is returned.    Infs are treated as equal if they are in the same place and of the same    sign in both arrays.","a, b : array_like        Input arrays to compare.    rtol : float        The relative tolerance parameter (see Notes).    atol : float        The absolute tolerance parameter (see Notes).    equal_nan : bool        Whether to compare NaN's as equal.  If True, NaN's in `a` will be        considered equal to NaN's in `b` in the output array.",allclose : bool        Returns True if the two arrays are equal within the given        tolerance; False otherwise.
"_isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Returns a boolean array where two arrays are element-wise equal within a    tolerance.    The tolerance values are positive, typically very small numbers.  The    relative difference (`rtol` * abs(`b`)) and the absolute difference    `atol` are added together to compare against the absolute difference    between `a` and `b`.    .. warning:: The default `atol` is not appropriate for comparing numbers                 that are much smaller than one (see Notes).","a, b : array_like        Input arrays to compare.    rtol : float        The relative tolerance parameter (see Notes).    atol : float        The absolute tolerance parameter (see Notes).    equal_nan : bool        Whether to compare NaN's as equal.  If True, NaN's in `a` will be        considered equal to NaN's in `b` in the output array.","y : array_like        Returns a boolean array of where `a` and `b` are equal within the        given tolerance. If both `a` and `b` are scalars, returns a single        boolean value."
"_array_equal_dispatcher(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"array_equal(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     True if two arrays have the same shape and elements, False otherwise.","a1, a2 : array_like        Input arrays.",b : bool        Returns True if the arrays are equal.
"_array_equiv_dispatcher(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,,,
"array_equiv(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/core/numeric.py,"     Returns True if input arrays are shape consistent and all elements equal.    Shape consistent means they are either the same shape, or one input array    can be broadcasted to create the same shape as the other one.","a1, a2 : array_like        Input arrays.","out : bool        True if equivalent, False otherwise."
,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,"numerictypes: Define the numeric type objectsThis module is designed so ""from numerictypes import \\*"" is safe.Exported symbols include:  Dictionary with all registered number types (including aliases):    typeDict  Type objects (not all will be available, depends on platform):      see variable sctypes for which ones you have    Bit-width names    int8 int16 int32 int64 int128    uint8 uint16 uint32 uint64 uint128    float16 float32 float64 float96 float128 float256    complex32 complex64 complex128 complex192 complex256 complex512    datetime64 timedelta64    c-based names    bool_    object_    void, str_, unicode_    byte, ubyte,    short, ushort    intc, uintc,    intp, uintp,    int_, uint,    longlong, ulonglong,    single, csingle,    float_, complex_,    longfloat, clongfloat,   As part of the type-hierarchy:    xx -- is bit-width   generic     +-> bool_                                  (kind=b)     +-> number     |   +-> integer     |   |   +-> signedinteger     (intxx)      (kind=i)     |   |   |     byte     |   |   |     short     |   |   |     intc     |   |   |     intp            int0     |   |   |     int_     |   |   |     longlong     |   |   \\-> unsignedinteger  (uintxx)     (kind=u)     |   |         ubyte     |   |         ushort     |   |         uintc     |   |         uintp           uint0     |   |         uint_     |   |         ulonglong     |   +-> inexact     |       +-> floating          (floatxx)    (kind=f)     |       |     half     |       |     single     |       |     float_          (double)     |       |     longfloat     |       \\-> complexfloating  (complexxx)  (kind=c)     |             csingle         (singlecomplex)     |             complex_        (cfloat, cdouble)     |             clongfloat      (longcomplex)     +-> flexible     |   +-> character     |   |     str_     (string_, bytes_)       (kind=S)    [Python 2]     |   |     unicode_                         (kind=U)    [Python 2]     |   |     |   |     bytes_   (string_)               (kind=S)    [Python 3]     |   |     str_     (unicode_)              (kind=U)    [Python 3]     |   |     |   \\-> void                              (kind=V) \\-> object_ (not used much)               (kind=O)",,
maximum_sctype(t):,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Return the scalar type of highest precision of the same kind as the input.,t : dtype or dtype specifier        The input data type. This can be a `dtype` object or an object that        is convertible to a `dtype`.,out : dtype        The highest precision data type of the same kind (`dtype.kind`) as `t`.
issctype(rep):,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Determines whether the given object represents a scalar data-type.,"rep : any        If `rep` is an instance of a scalar dtype, True is returned. If not,        False is returned.",out : bool        Boolean result of check whether `rep` is a scalar dtype.
"obj2sctype(rep, default=None):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Return the scalar dtype or NumPy equivalent of Python type of an object.,"rep : any        The object of which the type is returned.    default : any, optional        If given, this is returned for objects whose types can not be        determined. If not given, None is returned for those objects.",dtype : dtype or Python type        The data type of `rep`.
"issubclass_(arg1, arg2):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,"     Determine if a class is a subclass of a second class.    `issubclass_` is equivalent to the Python built-in ``issubclass``,    except that it returns False instead of raising a TypeError if one    of the arguments is not a class.","arg1 : class        Input class. True is returned if `arg1` is a subclass of `arg2`.    arg2 : class or tuple of classes.        Input class. If a tuple of classes, True is returned if `arg1` is a        subclass of any of the tuple elements.",out : bool        Whether `arg1` is a subclass of `arg2` or not.
"issubsctype(arg1, arg2):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Determine if the first argument is a subclass of the second argument.,"arg1, arg2 : dtype or dtype specifier        Data-types.",out : bool        The result.
"issubdtype(arg1, arg2):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Returns True if first argument is a typecode lower/equal in type hierarchy.,"arg1, arg2 : dtype_like        dtype or string representing a typecode.",out : bool
_construct_lookups():,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,,,
sctype2char(sctype):,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,     Return the string representation of a scalar dtype.,"sctype : scalar dtype or object        If a scalar dtype, the corresponding string character is        returned. If an object, `sctype2char` tries to infer its scalar type        and then return the corresponding string character.",typechar : str        The string character corresponding to the scalar type.
"_find_common_coerce(a, b):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,,,
"_can_coerce_all(dtypelist, start=0):",https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,,,
_register_types():,https://github.com//numpy/numpy/blob/master/numpy/core/numerictypes.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/core/overrides.py,,relevant_args : iterable of array-like        Iterable of possibly array-like arguments to check for        __array_function__ methods.,"Result from calling ``implementation()`` or an ``__array_function__``    method, as appropriate.Sequence of arguments with __array_function__ methods, in the order in    which they should be called. """""")

ArgSpec = collections.namedtuple('ArgSpec', 'args varargs keywords defaults')

"
"verify_matching_signatures(implementation, dispatcher):",https://github.com//numpy/numpy/blob/master/numpy/core/overrides.py," Verify that a dispatcher function has the right signature.    implementation_spec = ArgSpec(*getargspec(implementation))    dispatcher_spec = ArgSpec(*getargspec(dispatcher))
 if (implementation_spec.args != dispatcher_spec.args or            implementation_spec.varargs != dispatcher_spec.varargs or            implementation_spec.keywords != dispatcher_spec.keywords or            (bool(implementation_spec.defaults) != bool(dispatcher_spec.defaults)) or            (implementation_spec.defaults is not None and len(implementation_spec.defaults) != len(dispatcher_spec.defaults))): raise RuntimeError('implementation and dispatcher for %s have ' 'different function signatures' % implementation)
 if implementation_spec.defaults is not None: if dispatcher_spec.defaults != (None,) * len(dispatcher_spec.defaults): raise RuntimeError('dispatcher functions can only use None for ' 'default argument values')

",,
set_module(module):,https://github.com//numpy/numpy/blob/master/numpy/core/overrides.py, Decorator for overriding __module__ on a function or class.    Example usage::        @set_module('numpy')        def example():            pass        assert example.__module__ == 'numpy',,
"array_function_dispatch(dispatcher, module=None, verify=True,",https://github.com//numpy/numpy/blob/master/numpy/core/overrides.py, Decorator for adding dispatch with the __array_function__ protocol.    See NEP-18 for example usage.,"dispatcher : callable        Function that when called like ``dispatcher(*args, **kwargs)`` with        arguments from the NumPy function call returns an iterable of        array-like arguments to check for ``__array_function__``.    module : str, optional        __module__ attribute to set on new function, e.g., ``module='numpy'``.        By default, module is copied from the decorated function.    verify : bool, optional        If True, verify the that the signature of the dispatcher and decorated        function signatures match exactly: all required and optional arguments        should appear in order with the same names, but the default values for        all optional arguments should be ``None``. Only disable verification        if the dispatcher's signature needs to deviate for some particular        reason, e.g., because the function has a signature like        ``func(*args, **kwargs)``.    docs_from_dispatcher : bool, optional        If True, copy docs from the dispatcher function onto the dispatched        function, rather than from the implementation. This is useful for        functions defined in C, which otherwise don't have docstrings.","Function suitable for decorating the implementation of a NumPy function. """"""
 if not ARRAY_FUNCTION_ENABLED: def decorator(implementation): if docs_from_dispatcher:                add_docstring(implementation, dispatcher.__doc__) if module is not None:                implementation.__module__ = module return implementation return decorator
 def decorator(implementation): if verify:            verify_matching_signatures(implementation, dispatcher)
 if docs_from_dispatcher:            add_docstring(implementation, dispatcher.__doc__)
 # Equivalently, we could define this function directly instead of using # exec. This version has the advantage of giving the helper function a # more interpettable name. Otherwise, the original function does not # show up at all in many cases, e.g., if it's written in C or if the # dispatcher gets an invalid keyword argument.        source = textwrap.dedent(""""""        @functools.wraps(implementation)        def {name}(*args, **kwargs):            relevant_args = dispatcher(*args, **kwargs)            return implement_array_function(                implementation, {name}, relevant_args, args, kwargs) """""").format(name=implementation.__name__)
        source_object = compile(            source, filename='<__array_function__ internals>', mode='exec')        scope = { 'implementation': implementation, 'dispatcher': dispatcher, 'functools': functools, 'implement_array_function': implement_array_function,        } exec(source_object, scope)
        public_api = scope[implementation.__name__]
 if module is not None:            public_api.__module__ = module
        public_api._implementation = implementation
 return public_api
 return decorator

"
,https://github.com//numpy/numpy/blob/master/numpy/core/records.py,,,
find_duplicate(list):,https://github.com//numpy/numpy/blob/master/numpy/core/records.py," Find duplication in a list, return a list of duplicated elements return [        item for item, counts in _OrderedCounter(list).items() if counts > 1    ]

@set_module('numpy')class format_parser(object):","formats : str or list of str        The format description, either specified as a string with        comma-separated format descriptions in the form ``'f8, i4, a5'``, or        a list of format description strings  in the form        ``['f8', 'i4', 'a5']``.    names : str or list/tuple of str        The field names, either specified as a comma-separated string in the        form ``'col1, col2, col3'``, or as a list or tuple of strings in the        form ``['col1', 'col2', 'col3']``.        An empty list can be used, in that case default field names        ('f0', 'f1', ...) are used.    titles : sequence        Sequence of title strings. An empty list can be used to leave titles        out.    aligned : bool, optional        If True, align the fields by padding as the C-compiler would.        Default is False.    byteorder : str, optional        If specified, all the fields will be changed to the        provided byte-order.  Otherwise, the default byte-order is        used. For all available string specifiers, see `dtype.newbyteorder`.shape : tuple        Shape of output array.    dtype : data-type, optional        The desired data-type.  By default, the data-type is determined        from `formats`, `names`, `titles`, `aligned` and `byteorder`.    formats : list of data-types, optional        A list containing the data-types for the different columns, e.g.        ``['i4', 'f8', 'i4']``.  `formats` does *not* support the new        convention of using types directly, i.e. ``(int, float, int)``.        Note that `formats` must be a list, not a tuple.        Given that `formats` is somewhat limited, we recommend specifying        `dtype` instead.    names : tuple of str, optional        The name of each column, e.g. ``('x', 'y', 'z')``.    buf : buffer, optional        By default, a new array is created of the given shape and data-type.        If `buf` is specified and is an object exposing the buffer interface,        the array will use the memory from the existing buffer.  In this case,        the `offset` and `strides` keywords are available.",rec : recarray        Empty array of the given shape and type.
"fromarrays(arrayList, dtype=None, shape=None, formats=None,",https://github.com//numpy/numpy/blob/master/numpy/core/records.py,"  create a record array from a (flat) list of arrays >>> x1=np.array([1,2,3,4]) >>> x2=np.array(['a','dd','xyz','12']) >>> x3=np.array([1.1,2,3,4]) >>> r = np.core.records.fromarrays([x1,x2,x3],names='a,b,c') >>> print(r[1])    (2, 'dd', 2.0) # may vary >>> x1[1]=34 >>> r.a    array([1, 2, 3, 4])",,
"fromrecords(recList, dtype=None, shape=None, formats=None, names=None,",https://github.com//numpy/numpy/blob/master/numpy/core/records.py,"  create a recarray from a list of records in text form        The data in the same field can be heterogeneous, they will be promoted        to the highest data type.  This method is intended for creating        smaller record arrays.  If used to create large array without formats        defined        r=fromrecords([(2,3.,'abc')]*100000)        it can be slow.        If formats is None, then this will auto-detect formats. Use list of        tuples rather than list of lists for faster processing. >>> r=np.core.records.fromrecords([(456,'dbe',1.2),(2,'de',1.3)], ... names='col1,col2,col3') >>> print(r[0])    (456, 'dbe', 1.2) >>> r.col1    array([456,   2]) >>> r.col2    array(['dbe', 'de'], dtype='<U3') >>> import pickle >>> pickle.loads(pickle.dumps(r))    rec.array([(456, 'dbe', 1.2), (  2, 'de', 1.3)],              dtype=[('col1', '<i8'), ('col2', '<U3'), ('col3', '<f8')])",,
"fromstring(datastring, dtype=None, shape=None, offset=0, formats=None,",https://github.com//numpy/numpy/blob/master/numpy/core/records.py,  create a (read-only) record array from binary data contained in,,
get_remaining_size(fd):,https://github.com//numpy/numpy/blob/master/numpy/core/records.py,,,
"fromfile(fd, dtype=None, shape=None, offset=0, formats=None,",https://github.com//numpy/numpy/blob/master/numpy/core/records.py," Create an array from binary file data    If file is a string or a path-like object then that file is opened,    else it is assumed to be a file object. The file object must    support random access (i.e. it must have tell and seek methods). >>> from tempfile import TemporaryFile >>> a = np.empty(10,dtype='f8,i4,a5') >>> a[5] = (0.5,10,'abcde')    >>> >>> fd=TemporaryFile() >>> a = a.newbyteorder('<') >>> a.tofile(fd)    >>> >>> _ = fd.seek(0) >>> r=np.core.records.fromfile(fd, formats='f8,i4,a5', shape=10, ... byteorder='<') >>> print(r[5])    (0.5, 10, 'abcde') >>> r.shape    (10,)",,
,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
pythonlib_dir():,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py," return path where libpython* is. if sys.platform == 'win32': return os.path.join(sys.prefix, ""libs"") else: return get_config_var('LIBDIR')
",,
is_npy_no_signal():,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py, Return True if the NPY_NO_SIGNAL symbol must be defined in configuration,,
is_npy_no_smp():,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py, Return True if the NPY_NO_SMP symbol must be defined in public,,
win32_checks(deflist):,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
"check_math_capabilities(config, moredefs, mathlibs):",https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
"check_complex(config, mathlibs):",https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
check_ieee_macros(config):,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
"check_types(config_cmd, ext, build_dir):",https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
check_mathlib(config_cmd):,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py,,,
visibility_define(config):,https://github.com//numpy/numpy/blob/master/numpy/core/setup.py, Return the define value to use for NPY_VISIBILITY_HIDDEN (may be empty,,
,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,,,
is_released(config):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py," Return True if a released version of numpy is detected. from distutils.version import LooseVersion
    v = config.get_version('../version.py') if v is None: raise ValueError(""Could not get version"")    pv = LooseVersion(vstring=v).version if len(pv) > 3: return False return True
",,
"get_api_versions(apiversion, codegen_dir):",https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,     Return current C API checksum and the recorded checksum.    Return current C API checksum and the recorded checksum for the given    version of the C API version.,,
"check_api_version(apiversion, codegen_dir):",https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py," Emits a MismatchCAPIWarning if the C API version needs updating.    curapi_hash, api_hash = get_api_versions(apiversion, codegen_dir)
 # If different hash, it means that the api .txt files in # codegen_dir have been updated without the API version being # updated. Any modification in those .txt files should be reflected # in the api and eventually abi versions. # To compute the checksum of the current API, use # code_generators/cversions.py script if not curapi_hash == api_hash:        msg = (""API mismatch detected, the C API version "" ""numbers have to be updated. Current C api version is %d, "" ""with checksum %s, but recorded checksum for C API version %d in "" ""codegen_dir/cversions.txt is %s. If functions were added in the "" ""C API, you have to update C_API_VERSION  in %s.""               )        warnings.warn(msg % (apiversion, curapi_hash, apiversion, api_hash, __file__),                      MismatchCAPIWarning, stacklevel=2)# Mandatory functions: if not found, fail the buildMANDATORY_FUNCS = [""sin"", ""cos"", ""tan"", ""sinh"", ""cosh"", ""tanh"", ""fabs"", ""floor"", ""ceil"", ""sqrt"", ""log10"", ""log"", ""exp"", ""asin"", ""acos"", ""atan"", ""fmod"", 'modf', 'frexp', 'ldexp']
# Standard functions which may not be available and for which we have a# replacement implementation. Note that some of these are C99 functions.OPTIONAL_STDFUNCS = [""expm1"", ""log1p"", ""acosh"", ""asinh"", ""atanh"", ""rint"", ""trunc"", ""exp2"", ""log2"", ""hypot"", ""atan2"", ""pow"", ""copysign"", ""nextafter"", ""ftello"", ""fseeko"", ""strtoll"", ""strtoull"", ""cbrt"", ""strtold_l"", ""fallocate"", ""backtrace"", ""madvise""]

OPTIONAL_HEADERS = [# sse headers only enabled automatically on amd64/x32 builds ""xmmintrin.h"",  # SSE ""emmintrin.h"",  # SSE2 ""immintrin.h"",  # AVX ""features.h"",  # for glibc version linux ""xlocale.h"",  # see GH#8367 ""dlfcn.h"", # dladdr ""sys/mman.h"", #madvise]
# optional gcc compiler builtins and their call arguments and optional a# required header and definition name (HAVE_ prepended)# call arguments are required as the compiler will do strict signature checkingOPTIONAL_INTRINSICS = [(""__builtin_isnan"", '5.'),                       (""__builtin_isinf"", '5.'),                       (""__builtin_isfinite"", '5.'),                       (""__builtin_bswap32"", '5u'),                       (""__builtin_bswap64"", '5u'),                       (""__builtin_expect"", '5, 0'),                       (""__builtin_mul_overflow"", '5, 5, (int*)5'), # broken on OSX 10.11, make sure its not optimized away                       (""volatile int r = __builtin_cpu_supports"", '""sse""', ""stdio.h"", ""__BUILTIN_CPU_SUPPORTS""), # MMX only needed for icc, but some clangs don't have it                       (""_m_from_int64"", '0', ""emmintrin.h""),                       (""_mm_load_ps"", '(float*)0', ""xmmintrin.h""),  # SSE                       (""_mm_prefetch"", '(float*)0, _MM_HINT_NTA', ""xmmintrin.h""),  # SSE                       (""_mm_load_pd"", '(double*)0', ""emmintrin.h""),  # SSE2                       (""__builtin_prefetch"", ""(float*)0, 0, 3""), # check that the linker can handle avx                       (""__asm__ volatile"", '""vpand %xmm1, %xmm2, %xmm3""', ""stdio.h"", ""LINK_AVX""),                       (""__asm__ volatile"", '""vpand %ymm1, %ymm2, %ymm3""', ""stdio.h"", ""LINK_AVX2""),                       (""__asm__ volatile"", '""vpaddd %zmm1, %zmm2, %zmm3""', ""stdio.h"", ""LINK_AVX512F""),                       (""__asm__ volatile"", '""xgetbv""', ""stdio.h"", ""XGETBV""),                       ]
# function attributes# tested via ""int %s %s(void *);"" % (attribute, name)# function name will be converted to HAVE_<upper-case-name> preprocessor macroOPTIONAL_FUNCTION_ATTRIBUTES = [('__attribute__((optimize(""unroll-loops"")))', 'attribute_optimize_unroll_loops'),                                ('__attribute__((optimize(""O3"")))', 'attribute_optimize_opt_3'),                                ('__attribute__((nonnull (1)))', 'attribute_nonnull'),                                ('__attribute__((target (""avx"")))', 'attribute_target_avx'),                                ('__attribute__((target (""avx2"")))', 'attribute_target_avx2'),                                ('__attribute__((target (""avx512f"")))', 'attribute_target_avx512f'),                                ]
# function attributes with intrinsics# To ensure your compiler can compile avx intrinsics with just the attributes# gcc 4.8.4 support attributes but not with intrisics# tested via ""#include<%s> int %s %s(void *){code; return 0;};"" % (header, attribute, name, code)# function name will be converted to HAVE_<upper-case-name> preprocessor macroOPTIONAL_FUNCTION_ATTRIBUTES_WITH_INTRINSICS = [('__attribute__((target(""avx2"")))', 'attribute_target_avx2_with_intrinsics', '__m256 temp = _mm256_set1_ps(1.0)', 'immintrin.h'),                                ('__attribute__((target(""avx512f"")))', 'attribute_target_avx512f_with_intrinsics', '__m512 temp = _mm512_set1_ps(1.0)', 'immintrin.h'),                                ]
# variable attributes tested via ""int %s a"" % attributeOPTIONAL_VARIABLE_ATTRIBUTES = [""__thread"", ""__declspec(thread)""]
# Subset of OPTIONAL_STDFUNCS which may already have HAVE_* defined by Python.hOPTIONAL_STDFUNCS_MAYBE = [ ""expm1"", ""log1p"", ""acosh"", ""atanh"", ""asinh"", ""hypot"", ""copysign"", ""ftello"", ""fseeko""    ]
# C99 functions: float and long double versionsC99_FUNCS = [ ""sin"", ""cos"", ""tan"", ""sinh"", ""cosh"", ""tanh"", ""fabs"", ""floor"", ""ceil"", ""rint"", ""trunc"", ""sqrt"", ""log10"", ""log"", ""log1p"", ""exp"", ""expm1"", ""asin"", ""acos"", ""atan"", ""asinh"", ""acosh"", ""atanh"", ""hypot"", ""atan2"", ""pow"", ""fmod"", ""modf"", 'frexp', 'ldexp', ""exp2"", ""log2"", ""copysign"", ""nextafter"", ""cbrt""    ]C99_FUNCS_SINGLE = [f + 'f' for f in C99_FUNCS]C99_FUNCS_EXTENDED = [f + 'l' for f in C99_FUNCS]C99_COMPLEX_TYPES = [ 'complex double', 'complex float', 'complex long double'    ]C99_COMPLEX_FUNCS = [ ""cabs"", ""cacos"", ""cacosh"", ""carg"", ""casin"", ""casinh"", ""catan"", ""catanh"", ""ccos"", ""ccosh"", ""cexp"", ""cimag"", ""clog"", ""conj"", ""cpow"", ""cproj"", ""creal"", ""csin"", ""csinh"", ""csqrt"", ""ctan"", ""ctanh""    ]
",,
fname2def(name):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,,,
sym2def(symbol):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,,,
type2def(symbol):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,,,
check_long_double_representation(cmd):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py,"LONG_DOUBLE_REPRESENTATION_SRC = r/* ""before"" is 16 bytes to ensure there's no padding between it and ""x"". *    We're not expecting any ""long double"" bigger than 16 bytes or with *       alignment requirements stricter than 16 bytes. */typedef %(type)s test_type;struct {        char         before[16];        test_type    x;        char         after[8];} foo = {        { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',          '\001', '\043', '\105', '\147', '\211', '\253', '\315', '\357' },        -123456789.0,        { '\376', '\334', '\272', '\230', '\166', '\124', '\062', '\020' }};",,
pyod(filename):,https://github.com//numpy/numpy/blob/master/numpy/core/setup_common.py," Python implementation of the od UNIX utility (od -b, more exactly).",filename : str        name of the file to get the dump from.,out : seq        list of lines of od output
,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
_atleast_1d_dispatcher(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
atleast_1d(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Convert inputs to arrays with at least one dimension.    Scalar inputs are converted to 1-dimensional arrays, whilst    higher-dimensional inputs are preserved.","arys1, arys2, ... : array_like        One or more input arrays.","ret : ndarray        An array, or list of arrays, each with ``a.ndim >= 1``.        Copies are made only if necessary."
_atleast_2d_dispatcher(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
atleast_2d(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,     View inputs as arrays with at least two dimensions.,"arys1, arys2, ... : array_like        One or more array-like sequences.  Non-array inputs are converted        to arrays.  Arrays that already have two or more dimensions are        preserved.","res, res2, ... : ndarray        An array, or list of arrays, each with ``a.ndim >= 2``.        Copies are avoided where possible, and views with two or more        dimensions are returned."
_atleast_3d_dispatcher(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
atleast_3d(*arys):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,     View inputs as arrays with at least three dimensions.,"arys1, arys2, ... : array_like        One or more array-like sequences.  Non-array inputs are converted to        arrays.  Arrays that already have three or more dimensions are        preserved.","res1, res2, ... : ndarray        An array, or list of arrays, each with ``a.ndim >= 3``.  Copies are        avoided where possible, and views with three or more dimensions are        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a        view of shape ``(M, N, 1)``."
"_arrays_for_stack_dispatcher(arrays, stacklevel=4):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
_vhstack_dispatcher(tup):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
vstack(tup):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Stack arrays in sequence vertically (row wise).    This is equivalent to concatenation along the first axis after 1-D arrays    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by    `vsplit`.    This function makes most sense for arrays with up to 3 dimensions. For    instance, for pixel-data with a height (first axis), width (second axis),    and r/g/b channels (third axis). The functions `concatenate`, `stack` and    `block` provide more general stacking and concatenation operations.",tup : sequence of ndarrays        The arrays must have the same shape along all but the first axis.        1-D arrays must have the same length.,"stacked : ndarray        The array formed by stacking the given arrays, will be at least 2-D."
hstack(tup):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Stack arrays in sequence horizontally (column wise).    This is equivalent to concatenation along the second axis, except for 1-D    arrays where it concatenates along the first axis. Rebuilds arrays divided    by `hsplit`.    This function makes most sense for arrays with up to 3 dimensions. For    instance, for pixel-data with a height (first axis), width (second axis),    and r/g/b channels (third axis). The functions `concatenate`, `stack` and    `block` provide more general stacking and concatenation operations.","tup : sequence of ndarrays        The arrays must have the same shape along all but the second axis,        except 1-D arrays which can be any length.",stacked : ndarray        The array formed by stacking the given arrays.
"_stack_dispatcher(arrays, axis=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
"stack(arrays, axis=0, out=None):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Join a sequence of arrays along a new axis.    The ``axis`` parameter specifies the index of the new axis in the    dimensions of the result. For example, if ``axis=0`` it will be the first    dimension and if ``axis=-1`` it will be the last dimension.    .. versionadded:: 1.10.0",arrays : sequence of array_like        Each array must have the same shape.,stacked : ndarray        The stacked array has one more dimension than the input arrays.
_block_format_index(index):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Convert a list of indices ``[0, 1, 2]`` into ``""arrays[0][1][2]""``.",,
"_block_check_depths_match(arrays, parent_index=[]):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Recursive function checking that the depths of nested lists in `arrays`    all match. Mismatch raises a ValueError as described in the block    docstring below.    The entire index (rather than just the depth) needs to be calculated    for each innermost list, in case an error needs to be raised, so that    the index of the offending list can be printed as part of the error.",arrays : nested list of arrays        The arrays to check    parent_index : list of int        The full index of `arrays` within the nested lists passed to        `_block_check_depths_match` at the top of the recursion.,"first_index : list of int        The full index of an element from the bottom of the nesting in        `arrays`. If any element at the bottom is an empty list, this will        refer to it, and the last index along the empty axis will be `None`.    max_arr_ndim : int        The maximum of the ndims of the arrays nested in `arrays`.    final_size: int        The number of elements in the final array. This is used the motivate        the choice of algorithm used using benchmarking wisdom."
"_atleast_nd(a, ndim):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
_accumulate(values):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
"_concatenate_shapes(shapes, axis):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py," Given array shapes, return the resulting shape and slices prefixes.    These help in nested concatation.",,"shape: tuple of int        This tuple satisfies:        ```        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)        shape == concatenate(arrs, axis).shape        ```"
"_block_info_recursion(arrays, max_depth, result_ndim, depth=0):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Returns the shape of the final array, along with a list    of slices and a list of arrays that can be used for assignment inside the    new array",arrays : nested list of arrays        The arrays to check    max_depth : list of int        The number of nested lists    result_ndim: int        The number of dimensions in thefinal array.,"shape : tuple of int        The shape that the final array will take on.    slices: list of tuple of slices        The slices into the full array required for assignment. These are        required to be prepended with ``(Ellipsis, )`` to obtain to correct        final index.    arrays: list of ndarray        The data to assign to each slice of the full array"
"_block(arrays, max_depth, result_ndim, depth=0):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,     Internal implementation of block based on repeated concatenation.    `arrays` is the argument passed to    block. `max_depth` is the depth of nested lists within `arrays` and    `result_ndim` is the greatest of the dimensions of the arrays in    `arrays` and the depth of the lists in `arrays` (see block docstring    for details).,,
_block_dispatcher(arrays):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
block(arrays):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,"     Assemble an nd-array from nested lists of blocks.    Blocks in the innermost lists are concatenated (see `concatenate`) along    the last dimension (-1), then these are concatenated along the    second-last dimension (-2), and so on until the outermost list is reached.    Blocks can be of any dimension, but will not be broadcasted using the normal    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``    the same for all blocks. This is primarily useful for working with scalars,    and means that code like ``np.block([v, 1])`` is valid, where    ``v.ndim == 1``.    When the nested list is two levels deep, this allows block matrices to be    constructed from their components.    .. versionadded:: 1.13.0","arrays : nested list of array_like or scalars (but not tuples)        If passed a single ndarray or scalar (a nested list of depth 0), this        is returned unmodified (and not copied).",block_array : ndarray        The array assembled from the given blocks.
_block_setup(arrays):,https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py, ,,"    Returns    (`arrays`, list_ndim, result_ndim, final_size) """"""    bottom_index, arr_ndim, final_size = _block_check_depths_match(arrays)    list_ndim = len(bottom_index) if bottom_index and bottom_index[-1] is None: raise ValueError( 'List at {} cannot be empty'.format(                _block_format_index(bottom_index)            )        )    result_ndim = max(arr_ndim, list_ndim) return arrays, list_ndim, result_ndim, final_size

"
"_block_slicing(arrays, list_ndim, result_ndim):",https://github.com//numpy/numpy/blob/master/numpy/core/shape_base.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/__init__.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py,This module implements additional tests ala autoconf which can be useful.,,
check_inline(cmd):,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py, Return the inline identifier (may be empty).    cmd._check_compiler(),,
check_restrict(cmd):,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py, Return the restrict identifier (may be empty).    cmd._check_compiler(),,
check_compiler_gcc4(cmd):,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py, Return True if the C compiler is GCC 4.x.    cmd._check_compiler(),,
"check_gcc_function_attribute(cmd, attribute, name):",https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py, Return True if the given function attribute is supported.    cmd._check_compiler(),,
"check_gcc_function_attribute_with_intrinsics(cmd, attribute, name, code,",https://github.com//numpy/numpy/blob/master/numpy/distutils/command/autodist.py, Return True if the given function attribute is supported with,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/build_src.py,,,
"subst_vars(target, source, d):",https://github.com//numpy/numpy/blob/master/numpy/distutils/command/build_src.py, Substitute any occurrence of @foo@ by d['foo'] from source file into,,
get_swig_target(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/build_src.py,,,
get_swig_modulename(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/build_src.py,,,
"_find_swig_target(target_dir, name):",https://github.com//numpy/numpy/blob/master/numpy/distutils/command/build_src.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/command/config_compiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
flaglist(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
str2bool(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
is_sequence_of_strings(seq):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py," Abstract base class to define the interface that must be implemented    by real Fortran compiler classes.    Methods that subclasses may redefine:        update_executables(), find_executables(), get_version()        get_flags(), get_flags_opt(), get_flags_arch(), get_flags_debug()        get_flags_f77(), get_flags_opt_f77(), get_flags_arch_f77(),        get_flags_debug_f77(), get_flags_f90(), get_flags_opt_f90(),        get_flags_arch_f90(), get_flags_debug_f90(),        get_flags_fix(), get_flags_linker_so()    DON'T call these methods (except get_version) after    constructing a compiler instance or inside any other method.    All methods, except update_executables() and find_executables(),    may call the get_version() method.    After constructing a compiler instance, always call customize(dist=None)    method that finalizes compiler construction and makes the following    attributes available:      compiler_f77      compiler_f90      compiler_fix      linker_so      archiver      ranlib      libraries      library_dirs",,
load_all_fcompiler_classes():,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py, Cache all the FCompiler classes found in modules in the    numpy.distutils.fcompiler package.,,
"_find_existing_fcompiler(compiler_types,",https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
"available_fcompilers_for_platform(osname=None, platform=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
"get_default_fcompiler(osname=None, platform=None, requiref90=False,",https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py, Determine the default Fortran compiler to use for the given,,
"new_fcompiler(plat=None,",https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py, Generate an instance of some FCompiler subclass for the supplied    platform/compiler combination.,,
show_fcompilers(dist=None):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py," Print list of available compilers (used by the ""--help-fcompiler""    option to ""config_fc"").",,
dummy_fortran_file():,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
is_free_format(file):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py," Check if file is in free format Fortran. # f90 allows both fixed and free format, assuming fixed unless # signs of free format are detected.    result = 0    f = open_latin1(file, 'r')    line = f.readline()    n = 10000 # the number of non-comment lines to scan for hints if _has_f_header(line):        n = 0 elif _has_f90_header(line):        n = 0        result = 1 while n>0 and line:        line = line.rstrip() if line and line[0]!='!':            n -= 1 if (line[0]!='\t' and _free_f90_start(line[:5])) or line[-1:]=='&':                result = 1 break        line = f.readline()    f.close() return result
",,
has_f90_header(src):,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/__init__.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/gnu.py,,,
is_win64():,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/gnu.py," Handle the different versions of GNU fortran compilers # Strip warning(s) that may be emitted by gfortran while version_string.startswith('gfortran: warning'):            version_string = version_string[version_string.find('\n') + 1:]
 # Gfortran versions from after 2010 will output a simple string # (usually ""x.y"", ""x.y.z"" or ""x.y.z-q"") for ``-dumpversion``; older # gfortrans may still return long version strings (``-dumpversion`` was # an alias for ``--version``) if len(version_string) <= 20: # Try to find a valid version string            m = re.search(r'([0-9.]+)', version_string) if m: # g77 provides a longer version string that starts with GNU # Fortran if version_string.startswith('GNU Fortran'): return ('g77', m.group(1))
 # gfortran only outputs a version string such as #.#.#, so check # if the match is at the start of the string elif m.start() == 0: return ('gfortran', m.group(1)) else: # Output probably from --version, try harder:            m = re.search(r'GNU Fortran\s+95.*?([0-9-.]+)', version_string) if m: return ('gfortran', m.group(1))            m = re.search( r'GNU Fortran.*?\-?([0-9-.]+\.[0-9-.]+)', version_string) if m:                v = m.group(1) if v.startswith('0') or v.startswith('2') or v.startswith('3'): # the '0' is for early g77's return ('g77', v) else: # at some point in the 4.x series, the ' 95' was dropped # from the version string return ('gfortran', v)
 # If still nothing, raise an error to make the problem easy to find.        err = 'A valid Fortran version was not found in this string:\n' raise ValueError(err + version_string)
 def version_match(self, version_string):        v = self.gnu_version_match(version_string) if not v or v[0] != 'g77': return None return v[1]
    possible_executables = ['g77', 'f77']    executables = { 'version_cmd'  : [None, ""-dumpversion""], 'compiler_f77' : [None, ""-g"", ""-Wall"", ""-fno-second-underscore""], 'compiler_f90' : None,  # Use --fcompiler=gnu95 for f90 codes 'compiler_fix' : None, 'linker_so'    : [None, ""-g"", ""-Wall""], 'archiver'     : [""ar"", ""-cr""], 'ranlib'       : [""ranlib""], 'linker_exe'   : [None, ""-g"", ""-Wall""]    }    module_dir_switch = None    module_include_switch = None
 # Cygwin: f771: warning: -fPIC ignored for target (all code is # position independent) if os.name != 'nt' and sys.platform != 'cygwin':        pic_flags = ['-fPIC']
 # use -mno-cygwin for g77 when Python is not Cygwin-Python if sys.platform == 'win32': for key in ['version_cmd', 'compiler_f77', 'linker_so', 'linker_exe']:            executables[key].append('-mno-cygwin')
    g2c = 'g2c'    suggested_f90_compiler = 'gnu95'
 def get_flags_linker_so(self):        opt = self.linker_so[1:] if sys.platform == 'darwin':            target = os.environ.get('MACOSX_DEPLOYMENT_TARGET', None) # If MACOSX_DEPLOYMENT_TARGET is set, we simply trust the value # and leave it alone.  But, distutils will complain if the # environment's value is different from the one in the Python # Makefile used to build Python.  We let disutils handle this # error checking. if not target: # If MACOSX_DEPLOYMENT_TARGET is not set in the environment, # we try to get it first from the Python Makefile and then we # fall back to setting it to 10.3 to maximize the set of # versions we can work with.  This is a reasonable default # even when using the official Python dist and those derived # from it. import distutils.sysconfig as sc                g = {} try:                    get_makefile_filename = sc.get_makefile_filename except AttributeError: pass # i.e. PyPy else:                    filename = get_makefile_filename()                    sc.parse_makefile(filename, g)                target = g.get('MACOSX_DEPLOYMENT_TARGET', '10.3')                os.environ['MACOSX_DEPLOYMENT_TARGET'] = target if target == '10.3':                    s = 'Env. variable MACOSX_DEPLOYMENT_TARGET set to 10.3'                    warnings.warn(s, stacklevel=2)
            opt.extend(['-undefined', 'dynamic_lookup', '-bundle']) else:            opt.append(""-shared"") if sys.platform.startswith('sunos'): # SunOS often has dynamically loaded symbols defined in the # static library libg2c.a  The linker doesn't like this.  To # ignore the problem, use the -mimpure-text flag.  It isn't # the safest thing, but seems to work. 'man gcc' says: # "".. Instead of using -mimpure-text, you should compile all #  source code with -fpic or -fPIC.""            opt.append('-mimpure-text') return opt
 def get_libgcc_dir(self): try:            output = subprocess.check_output(self.compiler_f77 +                                            ['-print-libgcc-file-name']) except (OSError, subprocess.CalledProcessError): pass else:            output = filepath_from_subprocess_output(output) return os.path.dirname(output) return None
 def get_libgfortran_dir(self): if sys.platform[:5] == 'linux':            libgfortran_name = 'libgfortran.so' elif sys.platform == 'darwin':            libgfortran_name = 'libgfortran.dylib' else:            libgfortran_name = None
        libgfortran_dir = None if libgfortran_name:            find_lib_arg = ['-print-file-name={0}'.format(libgfortran_name)] try:                output = subprocess.check_output( self.compiler_f77 + find_lib_arg) except (OSError, subprocess.CalledProcessError): pass else:                output = filepath_from_subprocess_output(output)                libgfortran_dir = os.path.dirname(output) return libgfortran_dir
 def get_library_dirs(self):        opt = [] if sys.platform[:5] != 'linux':            d = self.get_libgcc_dir() if d: # if windows and not cygwin, libg2c lies in a different folder if sys.platform == 'win32' and not d.startswith('/usr/lib'):                    d = os.path.normpath(d)                    path = os.path.join(d, ""lib%s.a"" % self.g2c) if not os.path.exists(path):                        root = os.path.join(d, *((os.pardir, ) * 4))                        d2 = os.path.abspath(os.path.join(root, 'lib'))                        path = os.path.join(d2, ""lib%s.a"" % self.g2c) if os.path.exists(path):                            opt.append(d2)                opt.append(d) # For Macports / Linux, libgfortran and libgcc are not co-located        lib_gfortran_dir = self.get_libgfortran_dir() if lib_gfortran_dir:            opt.append(lib_gfortran_dir) return opt
 def get_libraries(self):        opt = []        d = self.get_libgcc_dir() if d is not None:            g2c = self.g2c + '-pic'            f = self.static_lib_format % (g2c, self.static_lib_extension) if not os.path.isfile(os.path.join(d, f)):                g2c = self.g2c else:            g2c = self.g2c
 if g2c is not None:            opt.append(g2c)        c_compiler = self.c_compiler if sys.platform == 'win32' and c_compiler and \                c_compiler.compiler_type == 'msvc':            opt.append('gcc') if sys.platform == 'darwin':            opt.append('cc_dynamic') return opt
 def get_flags_debug(self): return ['-g']
 def get_flags_opt(self):        v = self.get_version() if v and v <= '3.3.3': # With this compiler version building Fortran BLAS/LAPACK # with -O3 caused failures in lib.lapack heevr,syevr tests.            opt = ['-O2'] else:            opt = ['-O3']        opt.append('-funroll-loops') return opt
 def _c_arch_flags(self):",,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/fcompiler/intel.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_exec_command.py,,,
test_exec_command_stdout():,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_exec_command.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_fcompiler.py,,,
test_fcompiler_flags(monkeypatch):,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_fcompiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_from_template.py,"pyf_src = python module foo    <_rd=real,double precision>    interface        subroutine <s,d>foosub(tol)            <_rd>, intent(in,out) :: tol        end subroutine <s,d>foosub    end interfaceend python module foo",,
normalize_whitespace(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_from_template.py,"     Remove leading and trailing whitespace, and convert internal    stretches of whitespace to a single space.",,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_misc_util.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_shell_utils.py,,,
Parser(request):,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_shell_utils.py,,,
runner(Parser):,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_shell_utils.py,,,
"test_join_matches_subprocess(Parser, runner, argv):",https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_shell_utils.py,     Test that join produces strings understood by subprocess,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_system_info.py,,,
"get_class(name, notfound_action=1):",https://github.com//numpy/numpy/blob/master/numpy/distutils/tests/test_system_info.py,     notfound_action:      0 - do nothing      1 - display warning message      2 - raise error,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/__init__.py,,,
"customized_fcompiler(plat=None, compiler=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/__init__.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,,,
"_needs_build(obj, cc_args, extra_postargs, pp_opts):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Check if an objects needs to be rebuild based on its dependencies,obj : str        object file,"bool """""" # defined in unixcompiler.py    dep_file = obj + '.d' if not os.path.exists(dep_file): return True
 # dep_file is a makefile containing 'object: dependencies' # formatted like posix shell (spaces escaped, \ line continuations) # the last line contains the compiler commandline arguments as some # projects may compile an extension multiple times with different # arguments with open(dep_file, ""r"") as f:        lines = f.readlines()
    cmdline =_commandline_dep_string(cc_args, extra_postargs, pp_opts)    last_cmdline = lines[-1] if last_cmdline != cmdline: return True
    contents = ''.join(lines[:-1])    deps = [x for x in shlex.split(contents, posix=True) if x != ""\n"" and not x.endswith("":"")]
 try:        t_obj = os.stat(obj).st_mtime
 # check if any of the dependencies is newer than the object # the dependencies includes the source used to create the object for f in deps: if os.stat(f).st_mtime > t_obj: return True except OSError: # no object counts as newer (shouldn't happen if dep_file exists) return True
 return False

"
"replace_method(klass, method_name, func):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,,,
CCompiler_find_executables(self):,https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,"     Does nothing here, but is called by the get_version method and can be    overridden by subclasses. In particular it is redefined in the `FCompiler`    class where more documentation can be found.",,
"CCompiler_spawn(self, cmd, display=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Execute a command in a sub-process.,"cmd : str        The command to execute.    display : str or sequence of str, optional        The text to add to the log file kept by `numpy.distutils`.        If not given, `display` is equal to `cmd`.",None
"CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir=''):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Return the name of the object files for the given source files.,"source_filenames : list of str        The list of paths to source files. Paths can be either relative or        absolute, this is handled transparently.    strip_dir : bool, optional        Whether to strip the directory from the returned paths. If True,        the file name prepended by `output_dir` is returned. Default is False.    output_dir : str, optional        If given, this path is prepended to the returned paths to the        object files.",obj_names : list of str        The list of paths to the object files corresponding to the source        files in `source_filenames`.
"CCompiler_compile(self, sources, output_dir=None, macros=None,",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Compile one or more source files.    Please refer to the Python distutils API reference for more details.,"sources : list of str        A list of filenames    output_dir : str, optional        Path to the output directory.    macros : list of tuples        A list of macro definitions.    include_dirs : list of str, optional        The directories to add to the default include file search path for        this compilation only.    debug : bool, optional        Whether or not to output debug symbols in or alongside the object        file(s).    extra_preargs, extra_postargs : ?        Extra pre- and post-arguments.    depends : list of str, optional        A list of file names that all targets depend on.","objects : list of str        A list of object file names, one per source file `sources`."
"CCompiler_customize_cmd(self, cmd, ignore=()):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Customize compiler using distutils command.,"cmd : class instance        An instance inheriting from `distutils.cmd.Command`.    ignore : sequence of str, optional        List of `CCompiler` commands (without ``'set_'``) that should not be        altered. Strings that are checked for are:        ``('include_dirs', 'define', 'undef', 'libraries', 'library_dirs',        'rpath', 'link_objects')``.",None
_compiler_to_string(compiler):,https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,,,
CCompiler_show_customization(self):,https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Print the compiler customizations to stdout.,None,None
"CCompiler_customize(self, dist, need_cxx=0):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,"     Do any platform-specific customization of a compiler instance.    This method calls `distutils.sysconfig.customize_compiler` for    platform-specific customization, as well as optionally remove a flag    to suppress spurious warnings in case C++ code is being compiled.","dist : object        This parameter is not used for anything.    need_cxx : bool, optional        Whether or not C++ has to be compiled. If so (True), the        ``""-Wstrict-prototypes""`` option is removed to prevent spurious        warnings. Default is False.",None
"simple_version_match(pat=r'[-.\d]+', ignore='', start=''):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,"     Simple matching of version numbers, for use in CCompiler and FCompiler.","pat : str, optional        A regular expression matching version numbers.        Default is ``r'[-.\\d]+'``.    ignore : str, optional        A regular expression matching patterns to skip.        Default is ``''``, in which case nothing is skipped.    start : str, optional        A regular expression matching the start of where to start looking        for version numbers.        Default is ``''``, in which case searching is started at the        beginning of the version string given to `matcher`.","matcher : callable        A function that is appropriate to use as the ``.version_match``        attribute of a `CCompiler` class. `matcher` takes a single parameter,        a version string."
"CCompiler_get_version(self, force=False, ok_status=[0]):",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,"     Return compiler version, or None if compiler is not available.","force : bool, optional        If True, force a new determination of the version, even if the        compiler already has a version attribute. Default is False.    ok_status : list of int, optional        The list of status values returned by the version look-up process        for which a version string is returned. If the status value is not        in `ok_status`, None is returned. Default is ``[0]``.","version : str or None        Version string, in the format of `distutils.version.LooseVersion`."
CCompiler_cxx_compiler(self):,https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,     Return the C++ compiler.,None,"cxx : class instance        The C++ compiler, as a `CCompiler` instance."
"new_compiler (plat=None,",https://github.com//numpy/numpy/blob/master/numpy/distutils/ccompiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/compat.py,Small modules to cope with python 2 vs 3 incompatibilities insidenumpy.distutils,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,"takes templated file .xxx.src and produces .xxx file  where .xxx is.i or .c or .h, using the following template rules/**begin repeat  -- on a line by itself marks the start of a repeated code                    segment/**end repeat**/ -- on a line by itself marks it's endAfter the /**begin repeat and before the */, all the named templates are placedthese should all have the same number of replacementsRepeat blocks can be nested, with each nested block labeled with its depth,i.e./**begin repeat1 *.... *//**end repeat1**/When using nested loops, you can optionally exclude particularcombinations of the variables using (inside the comment portion of the inner loop): :exclude: var1=value1, var2=value2, ...This will exclude the pattern where var1 is value1 and var2 is value2 whenthe result is being generated.In the main body each replace will use one entry from the list of named replacements Note that all #..# forms in a block must have the same number of   comma-separated entries.Example:    An input file containing        /**begin repeat         * #a = 1,2,3#         * #b = 1,2,3#         */        /**begin repeat1         * #c = ted, jim#         */        @a@, @b@, @c@        /**end repeat1**/        /**end repeat**/    produces        line 1 ""template.c.src""        /*         *********************************************************************         **       This file was autogenerated from a template  DO NOT EDIT!!**         **       Changes should be made to the original source (.src) file **         *********************************************************************         */        #line 9        1, 1, ted        #line 9        1, 1, jim        #line 9        2, 2, ted        #line 9        2, 2, jim        #line 9        3, 3, ted        #line 9        3, 3, jim",,
"parse_structure(astr, level):",https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,"     The returned line number is from the beginning of the string, starting    at zero. Returns an empty list if no loops found.",,
paren_repl(obj):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
parse_values(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
parse_loop_header(loophead) :,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py," Find all named replacements in the header    Returns a list of dictionaries, one for each loop iteration,    where each key is a name to be substituted and the corresponding    value is the replacement string.    Also return a list of exclusions.  The exclusions are dictionaries     of key value pairs. There can be more than one exclusion.     [{'var1':'value1', 'var2', 'value2'[,...]}, ...]",,
"parse_string(astr, env, level, line) :",https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
process_str(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
resolve_includes(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
process_file(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
unique_key(adict):,https://github.com//numpy/numpy/blob/master/numpy/distutils/conv_template.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,,,
"_dict_append(d, **kws):",https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,,,
_command_line_ok(_cache=None):,https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,  Return True if command line does not contain any    help or display requests.,,
get_distribution(always=False):,https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,,,
setup(**attr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,,,
"_check_append_library(libraries, item):",https://github.com//numpy/numpy/blob/master/numpy/distutils/core.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/cpuinfo.py,"cpuinfoCopyright 2002 Pearu Peterson all rights reserved,Pearu Peterson <pearu@cens.ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy (BSD style) license.  See LICENSE.txt that came withthis distribution for specifics.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.Pearu Peterson",,
"getoutput(cmd, successful_status=(0,), stacklevel=1):",https://github.com//numpy/numpy/blob/master/numpy/distutils/cpuinfo.py,,,
"command_info(successful_status=(0,), stacklevel=1, **kw):",https://github.com//numpy/numpy/blob/master/numpy/distutils/cpuinfo.py,,,
"command_by_line(cmd, successful_status=(0,), stacklevel=1):",https://github.com//numpy/numpy/blob/master/numpy/distutils/cpuinfo.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,,,
filepath_from_subprocess_output(output):,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,"     Convert `bytes` in the encoding used by a subprocess into a filesystem-appropriate `str`.    Inherited from `exec_command`, and possibly incorrect.",,
forward_bytes_to_stdout(val):,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,"     Forward bytes from a subprocess call to the console, without attempting to    decode them.    The assumption is that the subprocess call already returned bytes in    a suitable encoding.",,
temp_file_name():,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,,,
get_pythonexe():,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,,,
"find_executable(exe, path=None, _cache={}):",https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py, Return full path of a executable or None.    Symbolic links are not followed.,,
_preserve_environment( names ):,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,,,
_update_environment( **env ):,https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,,,
"exec_command(command, execute_in='', use_shell=None, use_tee=None,",https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,"     Return (status,output) of executed command.    .. deprecated:: 1.17        Use subprocess.Popen instead","command : str        A concatenated string of executable and arguments.    execute_in : str        Before running command ``cd execute_in`` and after ``cd -``.    use_shell : {bool, None}, optional        If True, execute ``sh -c command``. Default None (True)    use_tee : {bool, None}, optional        If True use tee. Default None (True)",res : str        Both stdout and stderr messages.
"_exec_command(command, use_shell=None, use_tee = None, **env):",https://github.com//numpy/numpy/blob/master/numpy/distutils/exec_command.py,     Internal workhorse for exec_command().,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
parse_structure(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,  Return a list of tuples for each function or subroutine each    tuple is the start and end of a subroutine or function to be    expanded.,,
find_repl_patterns(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
find_and_remove_repl_patterns(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
conv(astr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
unique_key(adict):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,"  Obtain a unique key given a dictionary.    allkeys = list(adict.keys())    done = False    n = 1 while not done:        newkey = '__l%s' % (n) if newkey in allkeys:            n += 1 else:            done = True return newkey

template_name_re = re.compile(r'\A\s*(\w[\w\d]*)\s*\Z')",,
"expand_sub(substr, names):",https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
process_str(allstr):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
resolve_includes(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
process_file(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/from_template.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/lib2def.py,,,
parse_cmd():,https://github.com//numpy/numpy/blob/master/numpy/distutils/lib2def.py, Parses the command-line arguments.,,
"getnm(nm_cmd = ['nm', '-Cs', 'python%s.lib' % py_ver]):",https://github.com//numpy/numpy/blob/master/numpy/distutils/lib2def.py, Returns the output of nm_cmd via a pipe.,,
parse_nm(nm_output):,https://github.com//numpy/numpy/blob/master/numpy/distutils/lib2def.py, Returns a tuple of lists: dlist for the list of datasymbols and flist for the list of function symbols.,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
dos2unix(file):,https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
"dos2unix_one_dir(modified_files, dir_name, file_names):",https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
dos2unix_dir(dir_name):,https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
unix2dos(file):,https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
"unix2dos_one_dir(modified_files, dir_name, file_names):",https://github.com//numpy/numpy/blob/master/numpy/distutils/line_endings.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/log.py,,,
"_fix_args(args,flag=1):",https://github.com//numpy/numpy/blob/master/numpy/distutils/log.py,"         If we log WARN messages, log this message as a 'nice' anti-warn        message.",,
"set_threshold(level, force=False):",https://github.com//numpy/numpy/blob/master/numpy/distutils/log.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,"Support code for building Python extensions on Windows.    # NT stuff    # 1. Make sure libpython<version>.a exists for gcc.  If not, build it.    # 2. Force windows to use gcc (we're struggling with MSVC and g77 support)    # 3. Force windows to use g77",,
get_msvcr_replacement():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," Replacement for outdated version of get_msvcr from cygwinccompiler    msvcr = msvc_runtime_library() return [] if msvcr is None else [msvcr]
# monkey-patch cygwinccompiler with our updated version from misc_util# to avoid getting an exception raised on Python 3.5distutils.cygwinccompiler.get_msvcr = get_msvcr_replacement
# Useful to generate table of symbols from a dll_START = re.compile(r'\[Ordinal/Name Pointer\] Table')_TABLE = re.compile(r'^\s+\[([\s*[0-9]*)\] ([a-zA-Z0-9_]*)')
# the same as cygwin plus some additional parametersclass Mingw32CCompiler(distutils.cygwinccompiler.CygwinCCompiler):",,
find_python_dll():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
dump_table(dll):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
"generate_def(dll, dfile):",https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," Given a dll file location,  get all its exported symbols and dump them    into the given def file.",,
find_dll(dll_name):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
build_msvcr_library(debug=False):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
build_import_library():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
_check_for_import_lib():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," Check if an import library for the Python runtime already exists.    major_version, minor_version = tuple(sys.version_info[:2])
 # patterns for the file name of the library itself    patterns = ['libpython%d%d.a', 'libpython%d%d.dll.a', 'libpython%d.%d.dll.a']
 # directory trees that may contain the library    stems = [sys.prefix] if hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix:        stems.append(sys.base_prefix) elif hasattr(sys, 'real_prefix') and sys.real_prefix != sys.prefix:        stems.append(sys.real_prefix)
 # possible subdirectories within those trees where it is placed    sub_dirs = ['libs', 'lib']
 # generate a list of candidate locations    candidates = [] for pat in patterns:        filename = pat % (major_version, minor_version) for stem_dir in stems: for folder in sub_dirs:                candidates.append(os.path.join(stem_dir, folder, filename))
 # test the filesystem to see if we can find any of these for fullname in candidates: if os.path.isfile(fullname): # already exists, in location given return (True, fullname)
 # needs to be built, preferred location given first return (False, candidates[0])
",,
_build_import_library_amd64():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
_build_import_library_x86():,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,  Build the import libraries for Mingw32-gcc on Windows,,
"msvc_manifest_xml(maj, min):",https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," Given a major and minor version of the MSVCR, returns the",,
"manifest_rc(name, type='dll'):",https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," Return the rc file used to generate the res file which will be embedded    as manifest for given manifest file name, of given type ('dll' or    'exe').","name : str            name of the manifest file to embed    type : str {'dll', 'exe'}            type of the binary which will embed the manifest",
check_embedded_msvcr_match_linked(msver):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py," msver is the ms runtime version used for the MANIFEST. # check msvcr major version are the same for linking and # embedding    maj = msvc_runtime_major() if maj: if not maj == int(msver): raise ValueError( ""Discrepancy between linked msvcr "" \ ""(%d) and the one about to be embedded "" \ ""(%d)"" % (int(msver), maj))
",,
configtest_name(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
manifest_name(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
rc_name(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/mingw32ccompiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
clean_up_temporary_directory():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,     Container to hold information on an installable library.,name : str        Name of the installed library.    build_info : dict        Dictionary holding build information.    target_dir : str        Absolute path specifying where to install the library.,
get_num_build_jobs():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,"     Get number of parallel build jobs set by the --parallel command line    argument of setup.py    If the command did not receive a setting the environment variable    NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of    processors on the system, with a maximum of 8 (to prevent    overloading the system if there a lot of CPUs).",,out : int        number of parallel jobs that can be run
quote_args(args):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
allpath(name):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
"rel_path(path, parent_path):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return path relative to parent_path. # Use realpath to avoid issues with symlinked dirs (see gh-7707)    pd = os.path.realpath(os.path.abspath(parent_path))    apath = os.path.realpath(os.path.abspath(path)) if len(apath) < len(pd): return path if apath == pd: return '' if pd == apath[:len(pd)]: assert apath[len(pd)] in [os.sep], repr((path, apath[len(pd)]))        path = apath[len(pd)+1:] return path
",,
"get_path_from_frame(frame, parent_path=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return path of the module given a frame object from the call stack.    Returned path is relative to parent_path when given,    otherwise it is absolute path.",,
njoin(*path):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Join two or more pathname components +    - convert a /-separated pathname to one using the OS's path separator.    - resolve `..` and `.` from path.    Either passing n arguments as in njoin('a','b'), or a sequence    of n names as in njoin(['a','b']) is handled, or a mixture of such arguments.",,
get_mathlibs(path=None):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return the MATHLIB line from numpyconfig.h,,
minrelpath(path):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Resolve `..` and '.' from path.,,
sorted_glob(fileglob):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, sorts output of python glob for https://bugs.python.org/issue30461,,
"_fix_paths(paths, local_path, include_non_existing):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
"gpaths(paths, local_path='', include_non_existing=True):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Apply glob to paths and prepend local_path if needed.,,
"make_temp_file(suffix='', prefix='', text=True):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
terminal_has_colors():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
default_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
red_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
green_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
yellow_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
cyan_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
blue_text(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
cyg2win32(path):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
mingw32():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return true when using mingw32 environment.,,
msvc_runtime_version():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
msvc_runtime_library():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
msvc_runtime_major():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
_get_f90_modules(source):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return a list of Fortran f90 module names that    given source file defines.,,
is_string(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
all_strings(lst):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return True if all items in lst are string objects.  for item in lst: if not is_string(item): return False return True
",,
is_sequence(seq):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
is_glob_pattern(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
as_list(seq):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_language(sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Determine language value (c,f77,f90) from sources     language = None for source in sources: if isinstance(source, str): if f90_ext_match(source):                language = 'f90' break elif fortran_ext_match(source):                language = 'f77' return language
",,
has_f_sources(sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return True if sources contains Fortran files  for source in sources: if fortran_ext_match(source): return True return False
",,
has_cxx_sources(sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return True if sources contains C++ files  for source in sources: if cxx_ext_match(source): return True return False
",,
filter_sources(sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return four lists of filenames containing    C, C++, Fortran, and Fortran 90 module sources,    respectively.",,
_get_headers(directory_list):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
_get_directories(list_of_sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
"_commandline_dep_string(cc_args, extra_postargs, pp_opts):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,     Return commandline representation used to determine if a file needs    to be recompiled,,
get_dependencies(sources):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
is_local_src_dir(directory):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return true if directory is local directory.,,
general_source_files(top_path):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
general_source_directories_files(top_path):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return a directory name relative to top_path and    files contained.,,
get_ext_source_files(ext):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_script_files(scripts):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_lib_source_files(lib):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_shared_lib_extension(is_python_ext=False):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return the correct file extension for shared libraries.,"is_python_ext : bool, optional        Whether the shared library is a Python extension.  Default is False.",so_ext : str        The shared library extension.
get_data_files(data):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
dot_join(*args):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_frame(level=0):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return frame object from call stack with given level.,,
"get_cmd(cmdname, _cache={}):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_numpy_include_dirs():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
get_npy_pkg_dir():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Return the path where to find the npy-pkg-config directory. # XXX: import here for bootstrapping reasons import numpy    d = os.path.join(os.path.dirname(numpy.__file__), 'core', 'lib', 'npy-pkg-config') return d
",,
"get_pkg_info(pkgname, dirs=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,     Return library info for the given package.,"pkgname : str        Name of the package (should match the name of the .ini file, without        the extension, e.g. foo for the file foo.ini).    dirs : sequence, optional        If given, should be a sequence of additional directories where to look        for npy-pkg-config files. Those directories are searched prior to the        NumPy directory.",pkginfo : class instance        The `LibraryInfo` instance containing the build information.
"get_info(pkgname, dirs=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,     Return an info dict for a given C library.    The info dict contains the necessary options to use the C library.,"pkgname : str        Name of the package (should match the name of the .ini file, without        the extension, e.g. foo for the file foo.ini).    dirs : sequence, optional        If given, should be a sequence of additional directories where to look        for npy-pkg-config files. Those directories are searched prior to the        NumPy directory.",info : dict        The dictionary with build information.
is_bootstrapping():,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
"default_config_dict(name = None, parent_name = None, local_path=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return a configuration dictionary for usage in    configuration() function defined in file setup_<name>.py.,,
"dict_append(d, **kws):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
"appendpath(prefix, path):",https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py,,,
generate_config_py(target):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py," Generate config.py file containing system_info information    used during building the package.    Usage:        config['py_modules'].append((packagename, '__config__',generate_config_py))",,
msvc_version(compiler):,https://github.com//numpy/numpy/blob/master/numpy/distutils/misc_util.py, Return version major and minor of compiler instance if it is,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/msvc9compiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/msvccompiler.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
parse_flags(line):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,     Parse a line from a config file containing compile flags.,line : str        A single line containing one or more compile flags.,"d : dict        Dictionary of parsed flags, split into relevant categories.        These categories are the keys of `d`:"
_escape_backslash(val):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,     Object containing build information about a library.,"name : str        The library name.    description : str        Description of the library.    version : str        Version string.    sections : dict        The sections of the configuration file for the library. The keys are        the section headers, the values the text under each header.    vars : class instance        A `VariableSet` instance, which contains ``(name, value)`` pairs for        variables defined in the configuration file for the library.    requires : sequence, optional        The required libraries for the library to be installed.d : dict        Dict of items in the ""variables"" section of the configuration file.",
parse_meta(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
parse_variables(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
parse_sections(config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
pkg_to_filename(pkg_name):,https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
"parse_config(filename, dirs=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
"_read_config_imp(filenames, dirs=None):",https://github.com//numpy/numpy/blob/master/numpy/distutils/npy_pkg_config.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,"This file defines a set of system_info classes for gettinginformation about various resources (libraries, library directories,include directories, etc.) in the system. Currently, the followingclasses are available:  atlas_info  atlas_threads_info  atlas_blas_info  atlas_blas_threads_info  lapack_atlas_info  lapack_atlas_threads_info  atlas_3_10_info  atlas_3_10_threads_info  atlas_3_10_blas_info,  atlas_3_10_blas_threads_info,  lapack_atlas_3_10_info  lapack_atlas_3_10_threads_info  flame_info  blas_info  lapack_info  openblas_info  blis_info  blas_opt_info       # usage recommended  lapack_opt_info     # usage recommended  fftw_info,dfftw_info,sfftw_info  fftw_threads_info,dfftw_threads_info,sfftw_threads_info  djbfft_info  x11_info  lapack_src_info  blas_src_info  numpy_info  numarray_info  numpy_info  boost_python_info  agg2_info  wx_info  gdk_pixbuf_xlib_2_info  gdk_pixbuf_2_info  gdk_x11_2_info  gtkp_x11_2_info  gtkp_2_info  xft_info  freetype2_info  umfpack_infoUsage:    info_dict = get_info(<name>)  where <name> is a string 'atlas','x11','fftw','lapack','blas',  'lapack_src', 'blas_src', etc. For a complete list of allowed names,  see the definition of get_info() function below.  Returned info_dict is a dictionary which is compatible with  distutils.setup keyword arguments. If info_dict == {}, then the  asked resource is not available (system_info could not find it).  Several *_info classes specify an environment variable to specify  the locations of software. When setting the corresponding environment  variable to 'None' then the software will be ignored, even when it  is available in system.Global parameters:  system_info.search_static_first - search static libraries (.a)             in precedence to shared ones (.so, .sl) if enabled.  system_info.verbosity - output the results to stdout if enabled.The file 'site.cfg' is looked for in1) Directory of main setup.py file being run.2) Home directory of user running the setup.py file as ~/.numpy-site.cfg3) System wide directory (location of this file...)The first one found is used to get system configuration options Theformat is that used by ConfigParser (i.e., Windows .INI style). Thesection ALL has options that are the default for each section. Theavailable sections are fftw, atlas, and x11. Appropriate defaults areused if nothing is specified.The order of finding the locations of resources is the following: 1. environment variable 2. section in site.cfg 3. ALL section in site.cfgOnly the first complete match is returned.Example:----------[ALL]library_dirs = /usr/lib:/usr/local/lib:/opt/libinclude_dirs = /usr/include:/usr/local/include:/opt/includesrc_dirs = /usr/local/src:/opt/src# search static libraries (.a) in preference to shared ones (.so)search_static_first = 0[fftw]libraries = rfftw, fftw[atlas]library_dirs = /usr/lib/3dnow:/usr/lib/3dnow/atlas# for overriding the names of the atlas librarieslibraries = lapack, f77blas, cblas, atlas[x11]library_dirs = /usr/X11R6/libinclude_dirs = /usr/X11R6/include----------Note that the ``libraries`` key is the default setting for libraries.Authors:  Pearu Peterson <pearu@cens.ioc.ee>, February 2002  David M. Cooke <cookedm@physics.mcmaster.ca>, April 2002Copyright 2002 Pearu Peterson all rights reserved,Pearu Peterson <pearu@cens.ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy (BSD style) license.  See LICENSE.txt that came withthis distribution for specifics.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.",,
_c_string_literal(s):,https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,     Convert a python string into a literal suitable for inclusion into C code,,
"libpaths(paths, bits):",https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py," Return a list of library paths valid on 32 or 64 bit systems.    Inputs:      paths : sequence        A sequence of strings (typically paths)      bits : int        An integer, the only valid values are 32 or 64.  A ValueError exception      is raised otherwise.    Examples:    Consider a list of directories >>> paths = ['/usr/X11R6/lib','/usr/X11/lib','/usr/lib']    For a 32-bit platform, this is already valid: >>> np.distutils.system_info.libpaths(paths,32)    ['/usr/X11R6/lib', '/usr/X11/lib', '/usr/lib']    On 64 bits, we prepend the '64' postfix >>> np.distutils.system_info.libpaths(paths,64)    ['/usr/X11R6/lib64', '/usr/X11R6/lib', '/usr/X11/lib64', '/usr/X11/lib',    '/usr/lib64', '/usr/lib']",,
get_standard_file(fname):,https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py, Returns a list of files named 'fname' from    1) System-wide directory (directory-location of this module)    2) Users HOME directory (os.environ['HOME'])    3) Local directory,,
"get_info(name, notfound_action=0):",https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,     notfound_action:      0 - do nothing      1 - display warning message      2 - raise error,,
get_atlas_version(**config):,https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,                warnings.warn(textwrap.dedent(                    *****************************************************                    Linkage with ATLAS requires gfortran. Use                      python setup.py config_fc --fcompiler=gnu95 ...                    when building extension libraries that use ATLAS.                    Make sure that -lgfortran is used for C++ extensions.                    *****************************************************,,
"combine_paths(*args, **kws):",https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,  Return a list of existing paths composed by all combinations of        items from arguments.,,
"dict_append(d, **kws):",https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,,,
"parseCmdLine(argv=(None,)):",https://github.com//numpy/numpy/blob/master/numpy/distutils/system_info.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/distutils/unixccompiler.py,unixccompiler - can handle very long argument lists for ar.,,
"UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):",https://github.com//numpy/numpy/blob/master/numpy/distutils/unixccompiler.py," Compile a single source files with a Unix-style compiler. # HP ad-hoc fix, see ticket 1383    ccomp = self.compiler_so if ccomp[0] == 'aCC': # remove flags that will trigger ANSI-C mode for aCC if '-Ae' in ccomp:            ccomp.remove('-Ae') if '-Aa' in ccomp:            ccomp.remove('-Aa') # add flags for (almost) sane C++ handling        ccomp += ['-AA'] self.compiler_so = ccomp # ensure OPT environment variable is read if 'OPT' in os.environ: from distutils.sysconfig import get_config_vars        opt = "" "".join(os.environ['OPT'].split())        gcv_opt = "" "".join(get_config_vars('OPT')[0].split())        ccomp_s = "" "".join(self.compiler_so) if opt not in ccomp_s:            ccomp_s = ccomp_s.replace(gcv_opt, opt) self.compiler_so = ccomp_s.split()        llink_s = "" "".join(self.linker_so) if opt not in llink_s: self.linker_so = llink_s.split() + opt.split()
    display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)
 # gcc style automatic dependencies, outputs a makefile (-MF) that lists # all headers needed by a c file as a side effect of compilation (-MMD) if getattr(self, '_auto_depends', False):        deps = ['-MMD', '-MF', obj + '.d'] else:        deps = []
 try: self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +                   extra_postargs, display = display) except DistutilsExecError:        msg = str(get_exception()) raise CompileError(msg)
 # add commandline flags to dependency file if deps: with open(obj + '.d', 'a') as f:            f.write(_commandline_dep_string(cc_args, extra_postargs, pp_opts))
replace_method(UnixCCompiler, '_compile', UnixCCompiler__compile)

",,
,https://github.com//numpy/numpy/blob/master/numpy/doc/constants.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_array_from_pyobj.py,,,
setup_module():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_array_from_pyobj.py,     Build the required testing extension module,,
flags_info(arr):,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_array_from_pyobj.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_assumed_shape.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_common.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_compile_function.py,See https://github.com/numpy/numpy/pull/11937.,,
setup_module():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_compile_function.py,,,
test_f2py_init_compile(extra_args):,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_compile_function.py,    fsource =         integer function foo()        foo = 10 + 5        return        end,,
test_f2py_init_compile_failure():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_compile_function.py,,,
test_f2py_init_compile_bad_cmd():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_compile_function.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_kind.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_mixed.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_parameter.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_regression.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_size.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/test_string.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,"Utility functions for- building and importing modules on test time, using a temporary location- detecting if compilers are present",,
_cleanup():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
get_module_dir():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
get_temp_module_name():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
_memoize(func):,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
"build_module(source_files, options=[], skip=[], only=[], module_name=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,"     Compile and import a f2py module, built from the given files.",,
"build_code(source_code, options=[], skip=[], only=[], suffix=None,",https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,     Compile and import Fortran code using f2py.,,
_get_compiler_status():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,"    code = textwrap.dedent(\        import os        import sys        sys.path = %(syspath)s        def configuration(parent_name='',top_path=None):            global config            from numpy.distutils.misc_util import Configuration            config = Configuration('', parent_name, top_path)            return config        from numpy.distutils.core import setup        setup(configuration=configuration)        config_cmd = config.get_config_cmd()        have_c = config_cmd.try_compile('void foo() {}')        print('COMPILERS:%%d,%%d,%%d' %% (have_c,                                          config.have_f77c(),                                          config.have_f90c()))        sys.exit(99)",,
has_c_compiler():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
has_f77_compiler():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
has_f90_compiler():,https://github.com//numpy/numpy/blob/master/numpy/f2py/tests/util.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/__init__.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
outmess(t):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
debugcapi(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
_isstring(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isstring(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
ischaracter(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isstringarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isarrayofstrings(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isscalar(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
iscomplex(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islogical(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isinteger(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isreal(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
get_kind(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islong_long(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_char(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_short(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_long_long(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isdouble(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islong_double(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islong_complex(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
iscomplexarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isint1array(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_chararray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_shortarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsignedarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isunsigned_long_longarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issigned_chararray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issigned_shortarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issigned_array(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issigned_long_longarray(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isallocatable(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
ismutable(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
ismoduleroutine(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
ismodule(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isfunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isfunction_wrap(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issubroutine(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
issubroutine_wrap(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasassumedshape(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isroutine(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islogicalfunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islong_longfunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
islong_doublefunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
iscomplexfunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
iscomplexfunction_warn(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,"        outmess(\    **************************************************************        Warning: code with a function returning complex value        may not work correctly with your Fortran compiler.        Run the following test before using it in your applications:        $(f2py install dir)/test-site/{b/runme_scalar,e/runme}        When using GNU gcc/g77 compilers, codes should work correctly.",,
isstringfunction(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasexternals(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isthreadsafe(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasvariables(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isoptional(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isexternal(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isrequired(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_in(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_inout(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_out(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_hide(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_nothide(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_c(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_cache(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_copy(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_overwrite(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_callback(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_inplace(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_aux(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_aligned4(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_aligned8(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isintent_aligned16(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isprivate(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasinitvalue(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasinitvalueasstring(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasnote(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasresultnote(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hascommon(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
containscommon(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
containsmodule(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hasbody(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
hascallstatement(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
istrue(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isfalse(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
l_and(*f):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
l_or(*f):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
l_not(f):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
isdummyroutine(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getfortranname(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
"getmultilineblock(rout, blockname, comment=1, counter=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getcallstatement(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
"getcallprotoargument(rout, cb_map={}):",https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getusercode(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getusercode1(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getpymethoddef(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getargs(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getargs2(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
getrestdoc(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
gentitle(name):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
flatlist(l):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
stripcomma(s):,https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
"replace(str, d, defaultsep=''):",https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
"dictappend(rd, ar):",https://github.com//numpy/numpy/blob/master/numpy/f2py/auxfuncs.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,"Copyright 1999,2000 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/05/06 10:57:33 $Pearu Peterson",,
getctype(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,     Determines C type,,
getstrlength(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"getarrdims(a, var, verbose=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"getpydocsign(a, var):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"getarrdocsign(a, var):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"getinit(a, var):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"sign2map(a, var):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,"     varname,ctype,atype    init,init.r,init.i,pytype    vardebuginfo,vardebugshowvalue,varshowvalue    varrfromat    intent",,
routsign2map(rout):,https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,"     name,NAME,begintitle,endtitle    rname,ctype,rformat    routdebugshowvalue",,
modsign2map(m):,https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,     modulename,,
"cb_sign2map(a, var, index=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,,,
"cb_routsign2map(rout, um):",https://github.com//numpy/numpy/blob/master/numpy/f2py/capi_maps.py,"     name,begintitle,endtitle,argname    ctype,rctype,maxnofargs,nofoptargs,returncptr",,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/cb_rules.py,"Build call-back mechanism for f2py2e.Copyright 2000 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/07/20 11:27:58 $Pearu Peterson",,
buildcallbacks(m):,https://github.com//numpy/numpy/blob/master/numpy/f2py/cb_rules.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/cfuncs.py,,,
buildcfuncs():,https://github.com//numpy/numpy/blob/master/numpy/f2py/cfuncs.py,,,
"append_needs(need, flag=1):",https://github.com//numpy/numpy/blob/master/numpy/f2py/cfuncs.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/common_rules.py,"Build common block mechanism for f2py2e.Copyright 2000 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy LicenseNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/05/06 10:57:33 $Pearu Peterson",,
"findcommonblocks(block, top=1):",https://github.com//numpy/numpy/blob/master/numpy/f2py/common_rules.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,"crackfortran --- read fortran (77,90) code and extract declaration information.Copyright 1999-2004 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/09/27 07:13:49 $Pearu PetersonUsage of crackfortran:======================Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h <pyffilename>                   -m <module name for f77 routines>,--ignore-containsFunctions: crackfortran, crack2fortranThe following Fortran statements/constructions are supported(or will be if needed):   block data,byte,call,character,common,complex,contains,data,   dimension,double complex,double precision,end,external,function,   implicit,integer,intent,interface,intrinsic,   logical,module,optional,parameter,private,public,   program,real,(sequence?),subroutine,type,use,virtual,   include,pythonmoduleNote: 'virtual' is mapped to 'dimension'.Note: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug).Note: code after 'contains' will be ignored until its scope ends.Note: 'common' statement is extended: dimensions are moved to variable definitionsNote: f2py directive: <commentchar>f2py<line> is read as <line>Note: pythonmodule is introduced to represent Python moduleUsage:  `postlist=crackfortran(files)`  `postlist` contains declaration information read from the list of files `files`.  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file  `postlist` has the following structure: *** it is a list of dictionaries containing `blocks':     B = {'block','body','vars','parent_block'[,'name','prefix','args','result',          'implicit','externals','interfaced','common','sortvars',          'commonvars','note']}     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' |                  'program' | 'block data' | 'type' | 'pythonmodule'     B['body'] --- list containing `subblocks' with the same structure as `blocks'     B['parent_block'] --- dictionary of a parent block:                             C['body'][<index>]['parent_block'] is C     B['vars'] --- dictionary of variable definitions     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first)     B['name'] --- name of the block (not if B['block']=='interface')     B['prefix'] --- prefix string (only if B['block']=='function')     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine'     B['result'] --- name of the return value (only if B['block']=='function')     B['implicit'] --- dictionary {'a':<variable definition>,'b':...} | None     B['externals'] --- list of variables being external     B['interfaced'] --- list of variables being external and defined     B['common'] --- dictionary of common blocks (list of objects)     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions)     B['from'] --- string showing the 'parents' of the current block     B['use'] --- dictionary of modules used in current block:         {<modulename>:{['only':<0|1>],['map':{<local_name1>:<use_name1>,...}]}}     B['note'] --- list of LaTeX comments on the block     B['f2pyenhancements'] --- optional dictionary          {'threadsafe':'','fortranname':<name>,           'callstatement':<C-expr>|<multi-line block>,           'callprotoargument':<C-expr-list>,           'usercode':<multi-line block>|<list of multi-line blocks>,           'pymethoddef:<multi-line block>'           }     B['entry'] --- dictionary {entryname:argslist,..}     B['varnames'] --- list of variable names given in the order of reading the                       Fortran code, useful for derived types.     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface *** Variable definition is a dictionary     D = B['vars'][<variable name>] =     {'typespec'[,'attrspec','kindselector','charselector','=','typename']}     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' |                     'double precision' | 'integer' | 'logical' | 'real' | 'type'     D['attrspec'] --- list of attributes (e.g. 'dimension(<arrayspec>)',                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)',                       'optional','required', etc)     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] =                         'complex' | 'integer' | 'logical' | 'real' )     C = D['charselector'] = {['*','len','kind']}                             (only if D['typespec']=='character')     D['='] --- initialization expression string     D['typename'] --- name of the type if D['typespec']=='type'     D['dimension'] --- list of dimension bounds     D['intent'] --- list of intent specifications     D['depend'] --- list of variable names on which current variable depends on     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised     D['note'] --- list of LaTeX comments on the variable *** Meaning of kind/char selectors (few examples):     D['typespec>']*K['*']     D['typespec'](kind=K['kind'])     character*C['*']     character(len=C['len'],kind=C['kind'])     (see also fortran type declaration statement formats below)Fortran 90 type declaration statement format (F77 is subset of F90)====================================================================(Main source: IBM XL Fortran 5.1 Language Reference Manual)type declaration = <typespec> [[<attrspec>]::] <entitydecl><typespec> = byte                          |             character[<charselector>]     |             complex[<kindselector>]       |             double complex                |             double precision              |             integer[<kindselector>]       |             logical[<kindselector>]       |             real[<kindselector>]          |             type(<typename>)<charselector> = * <charlen>               |             ([len=]<len>[,[kind=]<kind>]) |             (kind=<kind>[,len=<len>])<kindselector> = * <intlen>                |             ([kind=]<kind>)<attrspec> = comma separated list of attributes.             Only the following attributes are used in             building up the interface:                external                (parameter --- affects '=' key)                optional                intent             Other attributes are ignored.<intentspec> = in | out | inout<arrayspec> = comma separated list of dimension bounds.<entitydecl> = <name> [[*<charlen>][(<arrayspec>)] | [(<arrayspec>)]*<charlen>]                      [/<init_expr>/ | =<init_expr>] [,<entitydecl>]In addition, the following attributes are used: check,depend,noteTODO:    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)'                                   -> 'real x(2)')    The above may be solved by creating appropriate preprocessor program, for example.",,
reset_global_f2py_vars():,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"outmess(line, flag=1):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
rmbadname1(name):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
rmbadname(names):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
undo_rmbadname1(name):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
undo_rmbadname(names):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
getextension(name):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
is_free_format(file):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py," Check if file is in free format Fortran. # f90 allows both fixed and free format, assuming fixed unless # signs of free format are detected.    result = 0 with open(file, 'r') as f:        line = f.readline()        n = 15 # the number of non-comment lines to scan for hints if _has_f_header(line):            n = 0 elif _has_f90_header(line):            n = 0            result = 1 while n > 0 and line: if line[0] != '!' and line.strip():                n -= 1 if (line[0] != '\t' and _free_f90_start(line[:5])) or line[-2:-1] == '&':                    result = 1 break            line = f.readline() return result

# Read fortran (77,90) code",,
"readfortrancode(ffile, dowithline=show, istop=1):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,"     Read fortran codes from files and     1) Get rid of comments, line continuations, and empty lines; lower cases.     2) Call dowithline(line) on every line.     3) Recursively call itself when statement \""include '<filename>'\"" is met.",,
"split_by_unquoted(line, characters):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,"     Splits the line into (line[:i], line[i:]),    where i is the index of first occurrence of one of the characters    not within quotes, or len(line) if no such index exists",,
_simplifyargs(argsline):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"crackline(line, reset=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,     reset=-1  --- initialize    reset=0   --- crack the line    reset=1   --- final check if mismatch of blocks occurred    Cracked data is saved in grouplist[0].,,
markouterparen(line):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"markoutercomma(line, comma=','):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
unmarkouterparen(line):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"appenddecl(decl, decl2, force=1):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
_is_intent_callback(vdecl):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
_resolvenameargspattern(line):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"analyzeline(m, case, line):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"appendmultiline(group, context_name, ml):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"cracktypespec0(typespec, ll):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
removespaces(expr):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
markinnerspaces(line):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"updatevars(typespec, selector, attrspec, entitydecl):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"cracktypespec(typespec, selector):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"setattrspec(decl, attr, force=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"setkindselector(decl, sel, force=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"setcharselector(decl, sel, force=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"getblockname(block, unknown='unknown'):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
setmesstext(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
get_usedict(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"get_useparameters(block, param_map=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"postcrack2(block, tab='', param_map=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"postcrack(block, args=None, tab=''):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,  TODO:          function return values          determine expression types if in argument list,,
sortvarnames(vars):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
analyzecommon(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"analyzebody(block, args, tab=''):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
buildimplicitrules(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"myeval(e, g=None, l=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"getlincoef(e, xset):  # e = a*x+b ; x in xset",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"getarrlen(dl, args, star='*'):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"_get_depend_dict(name, vars, deps):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
_calc_depend_dict(vars):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
get_sorted_names(vars):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py, ,,
_kind_func(string):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
_selected_int_kind_func(r):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"_selected_real_kind_func(p, r=0, radix=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"get_parameters(vars, global_params={}):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"_eval_length(length, params):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"_eval_scalar(value, params):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
analyzevars(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"expr2name(a, block, args=[]):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
analyzeargs(block):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
_ensure_exprdict(r):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"determineexprtype(expr, vars, rules={}):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"crack2fortrangen(block, tab='\n', as_interface=False):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"common2fortran(common, tab=''):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"use2fortran(use, tab=''):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
true_intent_list(var):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
"vars2fortran(block, vars, args, tab='', as_interface=False):",https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,  TODO:    public sub    ...,,
crackfortran(files):,https://github.com//numpy/numpy/blob/master/numpy/f2py/crackfortran.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/diagnose.py,,,
run_command(cmd):,https://github.com//numpy/numpy/blob/master/numpy/f2py/diagnose.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,"f2py2e - Fortran to Python C/API generator. 2nd Edition.         See __usage__ below.Copyright 1999--2011 Pearu Peterson all rights reserved,Pearu Peterson <pearu@cens.ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/05/06 08:31:19 $Pearu Peterson",,
scaninputline(inputline):,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,,,
"callcrackfortran(files, options):",https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,,,
buildmodules(lst):,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,,,
"dict_append(d_out, d_in):",https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,,,
run_main(comline_list):,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,"     Equivalent to running::        f2py <args>    where ``<args>=string.join(<list>,' ')``, but in Python.  Unless    ``-h`` is used, this function returns a dictionary containing    information on generated modules and their dependencies on source    files.  For example, the command ``f2py -m scalar scalar.f`` can be    executed from Python as follows    You cannot build extension modules with this function, that is,    using ``-c`` is not allowed. Use ``compile`` command instead    Examples    --------    .. include:: run_main_session.dat        :literal:",,
"filter_files(prefix, suffix, files, remove_prefix=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,     Filter files by prefix and suffix.,,
get_prefix(module):,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,,,
run_compile():,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py2e.py,     Do it all in one call!,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py_testing.py,,,
cmdline():,https://github.com//numpy/numpy/blob/master/numpy/f2py/f2py_testing.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/f90mod_rules.py,"Build F90 module support for f2py2e.Copyright 2000 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2005/02/03 19:30:23 $Pearu Peterson",,
findf90modules(m):,https://github.com//numpy/numpy/blob/master/numpy/f2py/f90mod_rules.py,"fgetdims1 = \      external f2pysetdata      logical ns      integer r,i      integer(%d) s(*)      ns = .FALSE.      if (allocated(d)) then         do i=1,r            if ((size(d,i).ne.s(i)).and.(s(i).ge.0)) then               ns = .TRUE.            end if         end do         if (ns) then            deallocate(d)         end if      end if",,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/func2subr.py,"Rules for building C/API module with f2py2e.Copyright 1999,2000 Pearu Peterson all rights reserved,Pearu Peterson <pearu@ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Date: 2004/11/26 11:13:06 $Pearu Peterson",,
"var2fixfortran(vars, a, fa=None, f90mode=None):",https://github.com//numpy/numpy/blob/master/numpy/f2py/func2subr.py,,,
"createfuncwrapper(rout, signature=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/func2subr.py,,,
"createsubrwrapper(rout, signature=0):",https://github.com//numpy/numpy/blob/master/numpy/f2py/func2subr.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/rules.py,,,
"buildmodule(m, um):",https://github.com//numpy/numpy/blob/master/numpy/f2py/rules.py,     Return,,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/setup.py,"setup.py for installing F2PYUsage:   python setup.py installCopyright 2001-2005 Pearu Peterson all rights reserved,Pearu Peterson <pearu@cens.ioc.ee>Permission to use, modify, and distribute this software is given under theterms of the NumPy License.NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.$Revision: 1.32 $$Date: 2005/01/30 17:22:14 $Pearu Peterson",,
,https://github.com//numpy/numpy/blob/master/numpy/f2py/use_rules.py,,,
"buildusevars(m, r):",https://github.com//numpy/numpy/blob/master/numpy/f2py/use_rules.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/fft/tests/test_pocketfft.py,,,
fft1(x):,https://github.com//numpy/numpy/blob/master/numpy/fft/tests/test_pocketfft.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/fft/helper.py,Discrete Fourier Transforms - helper.py,,
"_fftshift_dispatcher(x, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/helper.py,,,
"fftshift(x, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/helper.py,     Shift the zero-frequency component to the center of the spectrum.    This function swaps half-spaces for all axes listed (defaults to all).    Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even.,"x : array_like        Input array.    axes : int or shape tuple, optional        Axes over which to shift.  Default is None, which shifts all axes.",y : ndarray        The shifted array.
"ifftshift(x, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/helper.py,"     The inverse of `fftshift`. Although identical for even-length `x`, the    functions differ by one sample for odd-length `x`.","x : array_like        Input array.    axes : int or shape tuple, optional        Axes over which to calculate.  Defaults to None, which shifts all axes.",y : ndarray        The shifted array.
"fftfreq(n, d=1.0):",https://github.com//numpy/numpy/blob/master/numpy/fft/helper.py,"     Return the Discrete Fourier Transform sample frequencies.    The returned float array `f` contains the frequency bin centers in cycles    per unit of the sample spacing (with zero at the start).  For instance, if    the sample spacing is in seconds, then the frequency unit is cycles/second.    Given a window length `n` and a sample spacing `d`::      f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even      f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd","n : int        Window length.    d : scalar, optional        Sample spacing (inverse of the sampling rate). Defaults to 1.",f : ndarray        Array of length `n` containing the sample frequencies.
,https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"_raw_fft(a, n, axis, is_real, is_forward, fct):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
_unitary(norm):,https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"_fft_dispatcher(a, n=None, axis=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"fft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,     Compute the one-dimensional discrete Fourier Transform.    This function computes the one-dimensional *n*-point discrete Fourier    Transform (DFT) with the efficient Fast Fourier Transform (FFT)    algorithm [CT].,"a : array_like        Input array, can be complex.    n : int, optional        Length of the transformed axis of the output.        If `n` is smaller than the length of the input, the input is cropped.        If it is larger, the input is padded with zeros.  If `n` is not given,        the length of the input along the axis specified by `axis` is used.    axis : int, optional        Axis over which to compute the FFT.  If not given, the last axis is        used.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified."
"ifft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the one-dimensional inverse discrete Fourier Transform.    This function computes the inverse of the one-dimensional *n*-point    discrete Fourier transform computed by `fft`.  In other words,    ``ifft(fft(a)) == a`` to within numerical accuracy.    For a general description of the algorithm and definitions,    see `numpy.fft`.    The input should be ordered in the same way as is returned by `fft`,    i.e.,    * ``a[0]`` should contain the zero frequency term,    * ``a[1:n//2]`` should contain the positive-frequency terms,    * ``a[n//2 + 1:]`` should contain the negative-frequency terms, in      increasing order starting from the most negative frequency.    For an even number of input points, ``A[n//2]`` represents the sum of    the values at the positive and negative Nyquist frequencies, as the two    are aliased together. See `numpy.fft` for details.","a : array_like        Input array, can be complex.    n : int, optional        Length of the transformed axis of the output.        If `n` is smaller than the length of the input, the input is cropped.        If it is larger, the input is padded with zeros.  If `n` is not given,        the length of the input along the axis specified by `axis` is used.        See notes about padding issues.    axis : int, optional        Axis over which to compute the inverse DFT.  If not given, the last        axis is used.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified."
"rfft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,     Compute the one-dimensional discrete Fourier Transform for real input.    This function computes the one-dimensional *n*-point discrete Fourier    Transform (DFT) of a real-valued array by means of an efficient algorithm    called the Fast Fourier Transform (FFT).,"a : array_like        Input array    n : int, optional        Number of points along transformation axis in the input to use.        If `n` is smaller than the length of the input, the input is cropped.        If it is larger, the input is padded with zeros. If `n` is not given,        the length of the input along the axis specified by `axis` is used.    axis : int, optional        Axis over which to compute the FFT. If not given, the last axis is        used.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified.        If `n` is even, the length of the transformed axis is ``(n/2)+1``.        If `n` is odd, the length is ``(n+1)/2``."
"irfft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the inverse of the n-point DFT for real input.    This function computes the inverse of the one-dimensional *n*-point    discrete Fourier Transform of real input computed by `rfft`.    In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical    accuracy. (See Notes below for why ``len(a)`` is necessary here.)    The input is expected to be in the form returned by `rfft`, i.e. the    real zero-frequency term followed by the complex positive frequency terms    in order of increasing frequency.  Since the discrete Fourier Transform of    real input is Hermitian-symmetric, the negative frequency terms are taken    to be the complex conjugates of the corresponding positive frequency terms.","a : array_like        The input array.    n : int, optional        Length of the transformed axis of the output.        For `n` output points, ``n//2+1`` input points are necessary.  If the        input is longer than this, it is cropped.  If it is shorter than this,        it is padded with zeros.  If `n` is not given, it is determined from        the length of the input along the axis specified by `axis`.    axis : int, optional        Axis over which to compute the inverse FFT. If not given, the last        axis is used.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified.        The length of the transformed axis is `n`, or, if `n` is not given,        ``2*(m-1)`` where ``m`` is the length of the transformed axis of the        input. To get an odd number of output points, `n` must be specified."
"hfft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the FFT of a signal that has Hermitian symmetry, i.e., a real    spectrum.","a : array_like        The input array.    n : int, optional        Length of the transformed axis of the output. For `n` output        points, ``n//2 + 1`` input points are necessary.  If the input is        longer than this, it is cropped.  If it is shorter than this, it is        padded with zeros.  If `n` is not given, it is determined from the        length of the input along the axis specified by `axis`.    axis : int, optional        Axis over which to compute the FFT. If not given, the last        axis is used.    norm : {None, ""ortho""}, optional        Normalization mode (see `numpy.fft`). Default is None.","out : ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified.        The length of the transformed axis is `n`, or, if `n` is not given,        ``2*m - 2`` where ``m`` is the length of the transformed axis of        the input. To get an odd number of output points, `n` must be        specified, for instance as ``2*m - 1`` in the typical case,"
"ihfft(a, n=None, axis=-1, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,     Compute the inverse FFT of a signal that has Hermitian symmetry.,"a : array_like        Input array.    n : int, optional        Length of the inverse FFT, the number of points along        transformation axis in the input to use.  If `n` is smaller than        the length of the input, the input is cropped.  If it is larger,        the input is padded with zeros. If `n` is not given, the length of        the input along the axis specified by `axis` is used.    axis : int, optional        Axis over which to compute the inverse FFT. If not given, the last        axis is used.    norm : {None, ""ortho""}, optional        Normalization mode (see `numpy.fft`). Default is None.","out : complex ndarray        The truncated or zero-padded input, transformed along the axis        indicated by `axis`, or the last one if `axis` is not specified.        The length of the transformed axis is ``n//2 + 1``."
"_cook_nd_args(a, s=None, axes=None, invreal=0):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"_raw_fftnd(a, s=None, axes=None, function=fft, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"_fftn_dispatcher(a, s=None, axes=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,,,
"fftn(a, s=None, axes=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,     Compute the N-dimensional discrete Fourier Transform.    This function computes the *N*-dimensional discrete Fourier Transform over    any number of axes in an *M*-dimensional array by means of the Fast Fourier    Transform (FFT).,"a : array_like        Input array, can be complex.    s : sequence of ints, optional        Shape (length of each transformed axis) of the output        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).        This corresponds to ``n`` for ``fft(x, n)``.        Along any axis, if the given shape is smaller than that of the input,        the input is cropped.  If it is larger, the input is padded with zeros.        if `s` is not given, the shape of the input along the axes specified        by `axes` is used.    axes : sequence of ints, optional        Axes over which to compute the FFT.  If not given, the last ``len(s)``        axes are used, or all axes if `s` is also not specified.        Repeated indices in `axes` means that the transform over that axis is        performed multiple times.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or by a combination of `s` and `a`,        as explained in the parameters section above."
"ifftn(a, s=None, axes=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the N-dimensional inverse discrete Fourier Transform.    This function computes the inverse of the N-dimensional discrete    Fourier Transform over any number of axes in an M-dimensional array by    means of the Fast Fourier Transform (FFT).  In other words,    ``ifftn(fftn(a)) == a`` to within numerical accuracy.    For a description of the definitions and conventions used, see `numpy.fft`.    The input, analogously to `ifft`, should be ordered in the same way as is    returned by `fftn`, i.e. it should have the term for zero frequency    in all axes in the low-order corner, the positive frequency terms in the    first half of all axes, the term for the Nyquist frequency in the middle    of all axes and the negative frequency terms in the second half of all    axes, in order of decreasingly negative frequency.","a : array_like        Input array, can be complex.    s : sequence of ints, optional        Shape (length of each transformed axis) of the output        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).        This corresponds to ``n`` for ``ifft(x, n)``.        Along any axis, if the given shape is smaller than that of the input,        the input is cropped.  If it is larger, the input is padded with zeros.        if `s` is not given, the shape of the input along the axes specified        by `axes` is used.  See notes for issue on `ifft` zero padding.    axes : sequence of ints, optional        Axes over which to compute the IFFT.  If not given, the last ``len(s)``        axes are used, or all axes if `s` is also not specified.        Repeated indices in `axes` means that the inverse transform over that        axis is performed multiple times.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or by a combination of `s` or `a`,        as explained in the parameters section above."
"fft2(a, s=None, axes=(-2, -1), norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the 2-dimensional discrete Fourier Transform    This function computes the *n*-dimensional discrete Fourier Transform    over any axes in an *M*-dimensional array by means of the    Fast Fourier Transform (FFT).  By default, the transform is computed over    the last two axes of the input array, i.e., a 2-dimensional FFT.","a : array_like        Input array, can be complex    s : sequence of ints, optional        Shape (length of each transformed axis) of the output        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).        This corresponds to ``n`` for ``fft(x, n)``.        Along each axis, if the given shape is smaller than that of the input,        the input is cropped.  If it is larger, the input is padded with zeros.        if `s` is not given, the shape of the input along the axes specified        by `axes` is used.    axes : sequence of ints, optional        Axes over which to compute the FFT.  If not given, the last two        axes are used.  A repeated index in `axes` means the transform over        that axis is performed multiple times.  A one-element sequence means        that a one-dimensional FFT is performed.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or the last two axes if `axes` is not given."
"ifft2(a, s=None, axes=(-2, -1), norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the 2-dimensional inverse discrete Fourier Transform.    This function computes the inverse of the 2-dimensional discrete Fourier    Transform over any number of axes in an M-dimensional array by means of    the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``    to within numerical accuracy.  By default, the inverse transform is    computed over the last two axes of the input array.    The input, analogously to `ifft`, should be ordered in the same way as is    returned by `fft2`, i.e. it should have the term for zero frequency    in the low-order corner of the two axes, the positive frequency terms in    the first half of these axes, the term for the Nyquist frequency in the    middle of the axes and the negative frequency terms in the second half of    both axes, in order of decreasingly negative frequency.","a : array_like        Input array, can be complex.    s : sequence of ints, optional        Shape (length of each axis) of the output (``s[0]`` refers to axis 0,        ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.        Along each axis, if the given shape is smaller than that of the input,        the input is cropped.  If it is larger, the input is padded with zeros.        if `s` is not given, the shape of the input along the axes specified        by `axes` is used.  See notes for issue on `ifft` zero padding.    axes : sequence of ints, optional        Axes over which to compute the FFT.  If not given, the last two        axes are used.  A repeated index in `axes` means the transform over        that axis is performed multiple times.  A one-element sequence means        that a one-dimensional FFT is performed.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or the last two axes if `axes` is not given."
"rfftn(a, s=None, axes=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the N-dimensional discrete Fourier Transform for real input.    This function computes the N-dimensional discrete Fourier Transform over    any number of axes in an M-dimensional real array by means of the Fast    Fourier Transform (FFT).  By default, all axes are transformed, with the    real transform performed over the last axis, while the remaining    transforms are complex.","a : array_like        Input array, taken to be real.    s : sequence of ints, optional        Shape (length along each transformed axis) to use from the input.        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).        The final element of `s` corresponds to `n` for ``rfft(x, n)``, while        for the remaining axes, it corresponds to `n` for ``fft(x, n)``.        Along any axis, if the given shape is smaller than that of the input,        the input is cropped.  If it is larger, the input is padded with zeros.        if `s` is not given, the shape of the input along the axes specified        by `axes` is used.    axes : sequence of ints, optional        Axes over which to compute the FFT.  If not given, the last ``len(s)``        axes are used, or all axes if `s` is also not specified.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : complex ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or by a combination of `s` and `a`,        as explained in the parameters section above.        The length of the last axis transformed will be ``s[-1]//2+1``,        while the remaining transformed axes will have lengths according to        `s`, or unchanged from the input."
"rfft2(a, s=None, axes=(-2, -1), norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,     Compute the 2-dimensional FFT of a real array.,"a : array        Input array, taken to be real.    s : sequence of ints, optional        Shape of the FFT.    axes : sequence of ints, optional        Axes over which to compute the FFT.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0",out : ndarray        The result of the real 2-D FFT.
"irfftn(a, s=None, axes=None, norm=None):",https://github.com//numpy/numpy/blob/master/numpy/fft/pocketfft.py,"     Compute the inverse of the N-dimensional FFT of real input.    This function computes the inverse of the N-dimensional discrete    Fourier Transform for real input over any number of axes in an    M-dimensional array by means of the Fast Fourier Transform (FFT).  In    other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical    accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,    and for the same reason.)    The input should be ordered in the same way as is returned by `rfftn`,    i.e. as for `irfft` for the final transformation axis, and as for `ifftn`    along all the other axes.","a : array_like        Input array.    s : sequence of ints, optional        Shape (length of each transformed axis) of the output        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the        number of input points used along this axis, except for the last axis,        where ``s[-1]//2+1`` points of the input are used.        Along any axis, if the shape indicated by `s` is smaller than that of        the input, the input is cropped.  If it is larger, the input is padded        with zeros. If `s` is not given, the shape of the input along the        axes specified by `axes` is used.    axes : sequence of ints, optional        Axes over which to compute the inverse FFT. If not given, the last        `len(s)` axes are used, or all axes if `s` is also not specified.        Repeated indices in `axes` means that the inverse transform over that        axis is performed multiple times.    norm : {None, ""ortho""}, optional        .. versionadded:: 1.10.0","out : ndarray        The truncated or zero-padded input, transformed along the axes        indicated by `axes`, or by a combination of `s` or `a`,        as explained in the parameters section above.        The length of each transformed axis is as given by the corresponding        element of `s`, or the length of the input in every axis except for the        last one if `s` is not given.  In the final transformed axis the length        of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the        length of the final transformed axis of the input.  To get an odd        number of output points in the final axis, `s` must be specified."
,https://github.com//numpy/numpy/blob/master/numpy/fft/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
"urlopen_stub(url, data=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
setup_module():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
teardown_module():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
valid_textfile(filedir):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
invalid_textfile(filedir):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
valid_httpurl():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
invalid_httpurl():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
valid_baseurl():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
invalid_baseurl():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
valid_httpfile():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
invalid_httpfile():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__datasource.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__iotools.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,Tests for the NumpyVersion class.,,
test_main_versions():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_version_1_point_10():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_alpha_beta_rc():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_dev_version():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_dev_a_b_rc_mixed():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_dev0_version():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
test_dev0_a_b_rc_mixed():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test__version.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,Tests for the array padding functions.,,
test_legacy_vector_functionality():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_unicode_mode():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_object_input(mode):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_kwargs(mode):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py," Test behavior of pad's kwargs for the given mode.    allowed = _all_modes[mode]    not_allowed = {} for kwargs in _all_modes.values(): if kwargs != allowed:            not_allowed.update(kwargs) # Test if allowed keyword arguments pass    np.pad([1, 2, 3], 1, mode, **allowed) # Test if prohibited keyword arguments of other modes raise an error for key, value in not_allowed.items():        match = ""unsupported keyword arguments for mode '{}'"".format(mode) with pytest.raises(ValueError, match=match):            np.pad([1, 2, 3], 1, mode, **{key: value})

",,
test_constant_zero_default():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_unsupported_mode(mode):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_non_contiguous_array(mode):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py,,,
test_memory_layout_persistence(mode):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arraypad.py," Test if C and F order is preserved for all pad modes.    x = np.ones((5, 10), order='C') assert np.pad(x, 5, mode).flags[""C_CONTIGUOUS""]    x = np.ones((5, 10), order='F') assert np.pad(x, 5, mode).flags[""F_CONTIGUOUS""]

@pytest.mark.parametrize(""dtype"", chain( # Skip ""other"" dtypes as they are not supported by all modes    np.sctypes[""int""],    np.sctypes[""uint""],    np.sctypes[""float""],    np.sctypes[""complex""]))@pytest.mark.parametrize(""mode"", _all_modes.keys())",,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_arrayterator.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
setup_module():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
teardown_module():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
roundtrip(arr):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
roundtrip_randsize(arr):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
roundtrip_truncated(arr):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
"assert_equal_(o1, o2):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_roundtrip():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_roundtrip_randsize():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_roundtrip_truncated():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_long_str():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_memmap_roundtrip():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_compressed_roundtrip():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_load_padded_dtype(dt):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_python2_python3_interoperability():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_pickle_python2_python3():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_pickle_disallow():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_descr_to_dtype(dt):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_version_2_0():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_version_2_0_memmap():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_write_version():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_read_magic():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_read_magic_bad_magic():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_read_version_1_0_bad_magic():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_bad_magic_args():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_large_header():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_read_array_header_1_0():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_read_array_header_2_0():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_bad_header():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_large_file_support():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_large_archive():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
test_empty_npz():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_format.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_function_base.py,,,
get_mat(n):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_function_base.py,,,
"_make_complex(real, imag):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_function_base.py,"     Like real + 1j * imag, but behaves as expected when imag contains non-finite    values",,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_index_tricks.py,,,
test_c_():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_index_tricks.py,,,
test_diag_indices():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_index_tricks.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py," Helper IO class.    Writes encode strings to bytes if needed, reads return bytes.    This makes it easier to emulate files opened in binary mode    without needing to explicitly convert strings to bytes in    setting up the test data.",,
"strptime(s, fmt=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py,     This function is available in the datetime module only from Python >=    2.5.,,
test_gzip_load():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py,,,
test_gzip_loadtxt():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py,,,
test_gzip_loadtxt_from_string():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py,,,
test_npzfile_dict():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_io.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_mixins.py,,,
wrap_array_like(result):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_mixins.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_nanfunctions.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_packbits():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_packbits_empty():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_packbits_empty_with_axis():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_packbits_large(bitorder):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_packbits_very_large():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_unpackbits():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_pack_unpack_order():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_unpackbits_empty():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
test_unpackbits_empty_with_axis():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_packbits.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_shape_base.py,,,
_add_keepdims(func):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_shape_base.py,"  hack in keepdims behavior into a function taking an axis  @functools.wraps(func) def wrapped(a, axis, **kwargs):        res = func(a, axis=axis, **kwargs) if axis is None:            axis = 0 # res is now a scalar, so we can insert this anywhere return np.expand_dims(res, axis=axis) return wrapped

class TestTakeAlongAxis(object): def test_argequivalent(self):",,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
"assert_shapes_correct(input_shapes, expected_shape):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
assert_incompatible_shapes_raise(input_shapes):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
"assert_same_as_ufunc(shape0, shape1, transposed=False, flipped=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_same():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_broadcast_kwargs():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_one_off():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_same_input_shapes():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_two_compatible_by_ones_input_shapes():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_two_compatible_by_prepending_ones_input_shapes():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_incompatible_shapes_raise_valueerror():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_same_as_ufunc():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_broadcast_to_succeeds():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_broadcast_to_raises():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_broadcast_shape():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_as_strided():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
as_strided_writeable():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_subclasses():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
test_writeable():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_stride_tricks.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,Test functions for matrix module,,
get_mat(n):,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
test_tril_triu_ndim2():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
test_tril_triu_ndim3():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
test_tril_triu_with_inf():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
test_tril_triu_dtype():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
test_mask_indices():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_twodim_base.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_type_check.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_lookfor():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
"old_func(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
"old_func2(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
"old_func3(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
"old_func4(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py, Summary.    Further info.,,
"old_func5(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py, Summary.        Bizarre indentation.,,
"old_func6(self, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,     Also in PEP-257.,,
test_deprecate_decorator():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_deprecate_decorator_message():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_deprecate_fn():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_deprecate_help_indentation():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
"_compare_docs(old_func, new_func):",https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_deprecate_preserve_whitespace():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
test_safe_eval_nameconstant():,https://github.com//numpy/numpy/blob/master/numpy/lib/tests/test_utils.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/_datasource.py,"A file interface for handling local and remote data files.The goal of datasource is to abstract some of the file system operationswhen dealing with data files so the researcher doesn't have to know all thelow-level details.  Through datasource, a researcher can obtain and use afile with one function call, regardless of location of the file.DataSource is meant to augment standard python libraries, not replace them.It should work seamlessly with standard file IO operations and the osmodule.DataSource files can originate locally or remotely:- local files : '/home/guido/src/local/data.txt'- URLs (http, ftp, ...) : 'http://www.scipy.org/not/real/data.txt'DataSource files can also be compressed or uncompressed.  Currently onlygzip, bz2 and xz are supported.Example:: >>> # Create a DataSource, use os.curdir (default) for local storage. >>> from numpy import DataSource >>> ds = DataSource()    >>> >>> # Open a remote file. >>> # DataSource downloads the file, stores it locally in: >>> #     './www.google.com/index.html' >>> # opens the file and returns a file object. >>> fp = ds.open('http://www.google.com/') # doctest: +SKIP    >>> >>> # Use the file as you normally would >>> fp.read() # doctest: +SKIP >>> fp.close() # doctest: +SKIP",,
"_check_mode(mode, encoding, newline):",https://github.com//numpy/numpy/blob/master/numpy/lib/_datasource.py, Check mode and that encoding and newline are compatible.,mode : str        File open mode.    encoding : str        File encoding.    newline : str        Newline for text files.,
"_python2_bz2open(fn, mode, encoding, newline):",https://github.com//numpy/numpy/blob/master/numpy/lib/_datasource.py, Wrapper to open bz2 in text mode.,"fn : str        File name    mode : {'r', 'w'}        File mode. Note that bz2 Text files are not supported.    encoding : str        Ignored, text bz2 files not supported in Python2.    newline : str        Ignored, text bz2 files not supported in Python2. """""" import bz2
    _check_mode(mode, encoding, newline)
 if ""t"" in mode: # BZ2File is missing necessary functions for TextIOWrapper        warnings.warn(""Assuming latin1 encoding for bz2 text file in Python2"", RuntimeWarning, stacklevel=5)        mode = mode.replace(""t"", """") return bz2.BZ2File(fn, mode)
",
"_python2_gzipopen(fn, mode, encoding, newline):",https://github.com//numpy/numpy/blob/master/numpy/lib/_datasource.py,  Wrapper to open gzip in text mode.,"fn : str, bytes, file        File path or opened file.    mode : str        File mode. The actual files are opened as binary, but will decoded        using the specified `encoding` and `newline`.    encoding : str        Encoding to be used when reading/writing as text.    newline : str        Newline to be used when reading/writing as text.",
,https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,,,
"_decode_line(line, encoding=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py, Decode bytes from binary input streams.    Defaults to decoding from 'latin1'. That differs from the behavior of    np.compat.asunicode that decodes from 'ascii'.,line : str or bytes         Line to be decoded.,"decoded_line : unicode         Unicode in Python 2, a str (unicode) in Python 3."
_is_string_like(obj):,https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,     Check whether obj behaves like a string.,,
_is_bytes_like(obj):,https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,     Check whether obj behaves like a bytes object.,,
"_to_filehandle(fname, flag='r', return_opened=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,"     Returns the filehandle corresponding to a string or a file.    If the string ends in '.gz', the file is automatically unzipped.","fname : string, filehandle        Name of the file whose filehandle must be returned.    flag : string, optional        Flag indicating the status of the file ('r' for read, 'w' for write).    return_opened : boolean, optional        Whether to return the opening status of the file. """""" if _is_string_like(fname): if fname.endswith('.gz'): import gzip            fhd = gzip.open(fname, flag) elif fname.endswith('.bz2'): import bz2            fhd = bz2.BZ2File(fname) else:            fhd = file(fname, flag)        opened = True elif hasattr(fname, 'seek'):        fhd = fname        opened = False else: raise ValueError('fname must be a string or file handle') if return_opened: return fhd, opened return fhd

",
has_nested_fields(ndtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,     Returns whether one or several fields of a dtype are nested.,ndtype : dtype        Data-type of a structured array.,
"flatten_dtype(ndtype, flatten_base=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,     Unpack a structured data-type by collapsing nested fields and/or fields    with a shape.    Note that the field names are lost.,"ndtype : dtype        The datatype to collapse    flatten_base : bool, optional       If True, transform a field with a shape into several fields. Default is       False.delimiter : str, int, or sequence of ints, optional        If a string, character used to delimit consecutive fields.        If an integer or a sequence of integers, width(s) of each field.    comments : str, optional        Character used to mark the beginning of a comment. Default is '#'.    autostrip : bool, optional        Whether to strip each individual field. Default is True.excludelist : sequence, optional        A list of names to exclude. This list is appended to the default        list ['return', 'file', 'print']. Excluded names are appended an        underscore: for example, `file` becomes `file_` if supplied.    deletechars : str, optional        A string combining invalid characters that must be deleted from the        names.    case_sensitive : {True, False, 'upper', 'lower'}, optional        * If True, field names are case-sensitive.        * If False or 'upper', field names are converted to upper case.        * If 'lower', field names are converted to lower case.",
str2bool(value):,https://github.com//numpy/numpy/blob/master/numpy/lib/_iotools.py,     Tries to transform a string supposed to represent a boolean to a boolean.,"value : str        The string that is transformed to a boolean.dtype_or_func : {None, dtype, function}, optional        If a `dtype`, specifies the input data type, used to define a basic        function and a default value for missing data. For example, when        `dtype` is float, the `func` attribute is set to `float` and the        default value to `np.nan`.  If a function, this function is used to        convert a string to another object. In this case, it is recommended        to give an associated default value as input.    default : any, optional        Value to return by default, that is, when the string to be        converted is flagged as missing. If not given, `StringConverter`        tries to supply a reasonable default value.    missing_values : {None, sequence of str}, optional        ``None`` or sequence of strings indicating a missing value. If ``None``        then missing values are indicated by empty entries. The default is        ``None``.    locked : bool, optional        Whether the StringConverter should be locked to prevent automatic        upgrade or not. Default is False.func : var        Function, or sequence of functions",boolval : bool        The boolean representation of `value`.
,https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,,,
"_linear_ramp(ndim, axis, start, stop, size, reverse=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Create a linear ramp of `size` in `axis` with `ndim`.    This algorithm behaves like a vectorized version of `numpy.linspace`.    The resulting linear ramp is broadcastable to any array that matches the    ramp in `shape[axis]` and `ndim`.,"ndim : int        Number of dimensions of the resulting array. All dimensions except        the one specified by `axis` will have the size 1.    axis : int        The dimension that contains the linear ramp of `size`.    start : int or ndarray        The starting value(s) of the linear ramp. If given as an array, its        size must match `size`.    stop : int or ndarray        The stop value(s) (not included!) of the linear ramp. If given as an        array, its size must match `size`.    size : int        The number of elements in the linear ramp. If this argument is 0 the        dimensions of `ramp` will all be of length 1 except for the one given        by `axis` which will be 0.    reverse : bool        If False, increment in a positive fashion, otherwise decrement.",ramp : ndarray        Output array of dtype np.float64 that in- or decrements along the given        `axis`.
"_round_if_needed(arr, dtype):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Rounds arr inplace if destination dtype is integer.,"arr : ndarray        Input array.    dtype : dtype        The dtype of the destination array. """""" if np.issubdtype(dtype, np.integer):        arr.round(out=arr)

",
"_slice_at_axis(sl, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Construct tuple of slices to slice an array in the given dimension.,"sl : slice        The slice for the given dimension.    axis : int        The axis to which `sl` is applied. All other dimensions are left        ""unsliced"".",sl : tuple of slices        A tuple with slices matching `shape` in length.
"_view_roi(array, original_area_slice, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Get a view of the current region of interest during iterative padding.    When padding multiple dimensions iteratively corner values are    unnecessarily overwritten multiple times. This function reduces the    working area for the first dimensions so that corners are excluded.,array : ndarray        The array with the region of interest.    original_area_slice : tuple of slices        Denotes the area with original values of the unpadded array.    axis : int        The currently padded dimension assuming that `axis` is padded before        `axis` + 1.,"roi : ndarray        The region of interest of the original `array`. """"""    axis += 1    sl = (slice(None),) * axis + original_area_slice[axis:] return array[sl]

"
"_pad_simple(array, pad_width, fill_value=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Pad array on all sides with either a single value or undefined values.,"array : ndarray        Array to grow.    pad_width : sequence of tuple[int, int]        Pad width on both sides for each dimension in `arr`.    fill_value : scalar, optional        If provided the padded area is filled with this value, otherwise        the pad area left undefined.","padded : ndarray        The padded array with the same dtype as`array`. Its order will default        to C-style if `array` is not F-contiguous.    original_area_slice : tuple        A tuple of slices pointing to the area of the original array. """""" # Allocate grown array    new_shape = tuple(        left + size + right for size, (left, right) in zip(array.shape, pad_width)    )    order = 'F' if array.flags.fnc else 'C' # Fortran and not also C-order    padded = np.empty(new_shape, dtype=array.dtype, order=order)
 if fill_value is not None:        padded.fill(fill_value)
 # Copy old array into correct space    original_area_slice = tuple( slice(left, left + size) for size, (left, right) in zip(array.shape, pad_width)    )    padded[original_area_slice] = array
 return padded, original_area_slice

"
"_set_pad_area(padded, axis, width_pair, value_pair):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Set empty-padded area in given dimension.,"padded : ndarray        Array with the pad area which is modified inplace.    axis : int        Dimension with the pad area to set.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.    value_pair : tuple of scalars or ndarrays        Values inserted into the pad area on each side. It must match or be        broadcastable to the shape of `arr`. """"""    left_slice = _slice_at_axis(slice(None, width_pair[0]), axis)    padded[left_slice] = value_pair[0]
    right_slice = _slice_at_axis( slice(padded.shape[axis] - width_pair[1], None), axis)    padded[right_slice] = value_pair[1]

",
"_get_edges(padded, axis, width_pair):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Retrieve edge values from empty-padded array in given dimension.,"padded : ndarray        Empty-padded array.    axis : int        Dimension in which the edges are considered.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.","left_edge, right_edge : ndarray        Edge values of the valid area in `padded` in the given dimension. Its        shape will always match `padded` except for the dimension given by        `axis` which will have a length of 1. """"""    left_index = width_pair[0]    left_slice = _slice_at_axis(slice(left_index, left_index + 1), axis)    left_edge = padded[left_slice]
    right_index = padded.shape[axis] - width_pair[1]    right_slice = _slice_at_axis(slice(right_index - 1, right_index), axis)    right_edge = padded[right_slice]
 return left_edge, right_edge

"
"_get_linear_ramps(padded, axis, width_pair, end_value_pair):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Construct linear ramps for empty-padded array in given dimension.,"padded : ndarray        Empty-padded array.    axis : int        Dimension in which the ramps are constructed.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.    end_value_pair : (scalar, scalar)        End values for the linear ramps which form the edge of the fully padded        array. These values are included in the linear ramps.","left_ramp, right_ramp : ndarray        Linear ramps to set on both sides of `padded`. """"""    edge_pair = _get_edges(padded, axis, width_pair)
    left_ramp = _linear_ramp(        padded.ndim, axis, start=end_value_pair[0], stop=edge_pair[0], size=width_pair[0], reverse=False    )    _round_if_needed(left_ramp, padded.dtype)
    right_ramp = _linear_ramp(        padded.ndim, axis, start=end_value_pair[1], stop=edge_pair[1], size=width_pair[1], reverse=True    )    _round_if_needed(right_ramp, padded.dtype)
 return left_ramp, right_ramp

"
"_get_stats(padded, axis, width_pair, length_pair, stat_func):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Calculate statistic for the empty-padded array in given dimnsion.,"padded : ndarray        Empty-padded array.    axis : int        Dimension in which the statistic is calculated.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.    length_pair : 2-element sequence of None or int        Gives the number of values in valid area from each side that is        taken into account when calculating the statistic. If None the entire        valid area in `padded` is considered.    stat_func : function        Function to compute statistic. The expected signature is        ``stat_func(x: ndarray, axis: int, keepdims: bool) -> ndarray``.","left_stat, right_stat : ndarray        Calculated statistic for both sides of `padded`. """""" # Calculate indices of the edges of the area with original values    left_index = width_pair[0]    right_index = padded.shape[axis] - width_pair[1] # as well as its length    max_length = right_index - left_index
 # Limit stat_lengths to max_length    left_length, right_length = length_pair if left_length is None or max_length < left_length:        left_length = max_length if right_length is None or max_length < right_length:        right_length = max_length
 # Calculate statistic for the left side    left_slice = _slice_at_axis( slice(left_index, left_index + left_length), axis)    left_chunk = padded[left_slice]    left_stat = stat_func(left_chunk, axis=axis, keepdims=True)    _round_if_needed(left_stat, padded.dtype)
 if left_length == right_length == max_length: # return early as right_stat must be identical to left_stat return left_stat, left_stat
 # Calculate statistic for the right side    right_slice = _slice_at_axis( slice(right_index - right_length, right_index), axis)    right_chunk = padded[right_slice]    right_stat = stat_func(right_chunk, axis=axis, keepdims=True)    _round_if_needed(right_stat, padded.dtype) return left_stat, right_stat

"
"_set_reflect_both(padded, axis, width_pair, method, include_edge=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Pad `axis` of `arr` with reflection.,"padded : ndarray        Input array of arbitrary shape.    axis : int        Axis along which to pad `arr`.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.    method : str        Controls method of reflection; options are 'even' or 'odd'.    include_edge : bool        If true, edge value is included in reflection, otherwise the edge        value forms the symmetric axis to the reflection.","pad_amt : tuple of ints, length 2        New index positions of padding to do along the `axis`. If these are        both 0, padding is done in this dimension. """"""    left_pad, right_pad = width_pair    old_length = padded.shape[axis] - right_pad - left_pad
 if include_edge: # Edge is included, we need to offset the pad amount by 1        edge_offset = 1 else:        edge_offset = 0 # Edge is not included, no need to offset pad amount        old_length -= 1 # but must be omitted from the chunk
 if left_pad > 0: # Pad with reflected values on left side: # First limit chunk size which can't be larger than pad area        chunk_length = min(old_length, left_pad) # Slice right to left, stop on or next to edge, start relative to stop        stop = left_pad - edge_offset        start = stop + chunk_length        left_slice = _slice_at_axis(slice(start, stop, -1), axis)        left_chunk = padded[left_slice]
 if method == ""odd"": # Negate chunk and align with edge            edge_slice = _slice_at_axis(slice(left_pad, left_pad + 1), axis)            left_chunk = 2 * padded[edge_slice] - left_chunk
 # Insert chunk into padded area        start = left_pad - chunk_length        stop = left_pad        pad_area = _slice_at_axis(slice(start, stop), axis)        padded[pad_area] = left_chunk # Adjust pointer to left edge for next iteration        left_pad -= chunk_length
 if right_pad > 0: # Pad with reflected values on right side: # First limit chunk size which can't be larger than pad area        chunk_length = min(old_length, right_pad) # Slice right to left, start on or next to edge, stop relative to start        start = -right_pad + edge_offset - 2        stop = start - chunk_length        right_slice = _slice_at_axis(slice(start, stop, -1), axis)        right_chunk = padded[right_slice]
 if method == ""odd"": # Negate chunk and align with edge            edge_slice = _slice_at_axis( slice(-right_pad - 1, -right_pad), axis)            right_chunk = 2 * padded[edge_slice] - right_chunk
 # Insert chunk into padded area        start = padded.shape[axis] - right_pad        stop = start + chunk_length        pad_area = _slice_at_axis(slice(start, stop), axis)        padded[pad_area] = right_chunk # Adjust pointer to right edge for next iteration        right_pad -= chunk_length
 return left_pad, right_pad

"
"_set_wrap_both(padded, axis, width_pair):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,     Pad `axis` of `arr` with wrapped values.,"padded : ndarray        Input array of arbitrary shape.    axis : int        Axis along which to pad `arr`.    width_pair : (int, int)        Pair of widths that mark the pad area on both sides in the given        dimension.","pad_amt : tuple of ints, length 2        New index positions of padding to do along the `axis`. If these are        both 0, padding is done in this dimension. """"""    left_pad, right_pad = width_pair    period = padded.shape[axis] - right_pad - left_pad
 # If the current dimension of `arr` doesn't contain enough valid values # (not part of the undefined pad area) we need to pad multiple times. # Each time the pad area shrinks on both sides which is communicated with # these variables.    new_left_pad = 0    new_right_pad = 0
 if left_pad > 0: # Pad with wrapped values on left side # First slice chunk from right side of the non-pad area. # Use min(period, left_pad) to ensure that chunk is not larger than # pad area        right_slice = _slice_at_axis( slice(-right_pad - min(period, left_pad), -right_pad if right_pad != 0 else None),            axis        )        right_chunk = padded[right_slice]
 if left_pad > period: # Chunk is smaller than pad area            pad_area = _slice_at_axis(slice(left_pad - period, left_pad), axis)            new_left_pad = left_pad - period else: # Chunk matches pad area            pad_area = _slice_at_axis(slice(None, left_pad), axis)        padded[pad_area] = right_chunk
 if right_pad > 0: # Pad with wrapped values on right side # First slice chunk from left side of the non-pad area. # Use min(period, right_pad) to ensure that chunk is not larger than # pad area        left_slice = _slice_at_axis( slice(left_pad, left_pad + min(period, right_pad),), axis)        left_chunk = padded[left_slice]
 if right_pad > period: # Chunk is smaller than pad area            pad_area = _slice_at_axis( slice(-right_pad, -right_pad + period), axis)            new_right_pad = right_pad - period else: # Chunk matches pad area            pad_area = _slice_at_axis(slice(-right_pad, None), axis)        padded[pad_area] = left_chunk
 return new_left_pad, new_right_pad

"
"_as_pairs(x, ndim, as_index=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,"     Broadcast `x` to an array with the shape (`ndim`, 2).    A helper function for `pad` that prepares and validates arguments like    `pad_width` for iteration in pairs.","x : {None, scalar, array-like}        The object to broadcast to the shape (`ndim`, 2).    ndim : int        Number of pairs the broadcasted `x` will have.    as_index : bool, optional        If `x` is not None, try to round each element of `x` to an integer        (dtype `np.intp`) and ensure every element is positive.","pairs : nested iterables, shape (`ndim`, 2)        The broadcasted version of `x`."
"_pad_dispatcher(array, pad_width, mode=None, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraypad.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"_ediff1d_dispatcher(ary, to_end=None, to_begin=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"ediff1d(ary, to_end=None, to_begin=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,     The differences between consecutive elements of an array.,"ary : array_like        If necessary, will be flattened before the differences are taken.    to_end : array_like, optional        Number(s) to append at the end of the returned differences.    to_begin : array_like, optional        Number(s) to prepend at the beginning of the returned differences.","ediff1d : ndarray        The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``."
_unpack_tuple(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"  Unpacks one-element tuples for use as return values  if len(x) == 1: return x[0] else: return x

",,
"_unique_dispatcher(ar, return_index=None, return_inverse=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"unique(ar, return_index=False, return_inverse=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,     Find the unique elements of an array.    Returns the sorted unique elements of an array. There are three optional    outputs in addition to the unique elements:    * the indices of the input array that give the unique values    * the indices of the unique array that reconstruct the input array    * the number of times each unique value comes up in the input array,"ar : array_like        Input array. Unless `axis` is specified, this will be flattened if it        is not already 1-D.    return_index : bool, optional        If True, also return the indices of `ar` (along the specified axis,        if provided, or in the flattened array) that result in the unique array.    return_inverse : bool, optional        If True, also return the indices of the unique array (for the specified        axis, if provided) that can be used to reconstruct `ar`.    return_counts : bool, optional        If True, also return the number of times each unique item appears        in `ar`.","unique : ndarray        The sorted unique values.    unique_indices : ndarray, optional        The indices of the first occurrences of the unique values in the        original array. Only provided if `return_index` is True.    unique_inverse : ndarray, optional        The indices to reconstruct the original array from the        unique array. Only provided if `return_inverse` is True.    unique_counts : ndarray, optional        The number of times each of the unique values comes up in the        original array. Only provided if `return_counts` is True."
"_unique1d(ar, return_index=False, return_inverse=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"     Find the unique elements of an array, ignoring shape.",,
_intersect1d_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"intersect1d(ar1, ar2, assume_unique=False, return_indices=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"     Find the intersection of two arrays.    Return the sorted, unique values that are in both of the input arrays.","ar1, ar2 : array_like        Input arrays. Will be flattened if not already 1D.    assume_unique : bool        If True, the input arrays are both assumed to be unique, which        can speed up the calculation.  Default is False.    return_indices : bool        If True, the indices which correspond to the intersection of the two        arrays are returned. The first instance of a value is used if there are        multiple. Default is False.",intersect1d : ndarray        Sorted 1D array of common and unique elements.    comm1 : ndarray        The indices of the first occurrences of the common values in `ar1`.        Only provided if `return_indices` is True.    comm2 : ndarray        The indices of the first occurrences of the common values in `ar2`.        Only provided if `return_indices` is True.
"_setxor1d_dispatcher(ar1, ar2, assume_unique=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"setxor1d(ar1, ar2, assume_unique=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"     Find the set exclusive-or of two arrays.    Return the sorted, unique values that are in only one (not both) of the    input arrays.","ar1, ar2 : array_like        Input arrays.    assume_unique : bool        If True, the input arrays are both assumed to be unique, which        can speed up the calculation.  Default is False.",setxor1d : ndarray        Sorted 1D array of unique values that are in only one of the input        arrays.
"_in1d_dispatcher(ar1, ar2, assume_unique=None, invert=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"in1d(ar1, ar2, assume_unique=False, invert=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,     Test whether each element of a 1-D array is also present in a second array.    Returns a boolean array the same length as `ar1` that is True    where an element of `ar1` is in `ar2` and False otherwise.    We recommend using :func:`isin` instead of `in1d` for new code.,"ar1 : (M,) array_like        Input array.    ar2 : array_like        The values against which to test each value of `ar1`.    assume_unique : bool, optional        If True, the input arrays are both assumed to be unique, which        can speed up the calculation.  Default is False.    invert : bool, optional        If True, the values in the returned array are inverted (that is,        False where an element of `ar1` is in `ar2` and True otherwise).        Default is False. ``np.in1d(a, b, invert=True)`` is equivalent        to (but is faster than) ``np.invert(in1d(a, b))``.","in1d : (M,) ndarray, bool        The values `ar1[in1d]` are in `ar2`."
"_isin_dispatcher(element, test_elements, assume_unique=None, invert=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"isin(element, test_elements, assume_unique=False, invert=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"     Calculates `element in test_elements`, broadcasting over `element` only.    Returns a boolean array of the same shape as `element` that is True    where an element of `element` is in `test_elements` and False otherwise.","element : array_like        Input array.    test_elements : array_like        The values against which to test each value of `element`.        This argument is flattened if it is an array or array_like.        See notes for behavior with non-array-like parameters.    assume_unique : bool, optional        If True, the input arrays are both assumed to be unique, which        can speed up the calculation.  Default is False.    invert : bool, optional        If True, the values in the returned array are inverted, as if        calculating `element not in test_elements`. Default is False.        ``np.isin(a, b, invert=True)`` is equivalent to (but faster        than) ``np.invert(np.isin(a, b))``.","isin : ndarray, bool        Has the same shape as `element`. The values `element[isin]`        are in `test_elements`."
"_union1d_dispatcher(ar1, ar2):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
"union1d(ar1, ar2):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,"     Find the union of two arrays.    Return the unique, sorted array of values that are in either of the two    input arrays.","ar1, ar2 : array_like        Input arrays. They are flattened if they are not already 1D.","union1d : ndarray        Unique, sorted union of the input arrays."
"_setdiff1d_dispatcher(ar1, ar2, assume_unique=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/arraysetops.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
_convert_when(when):,https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"_fv_dispatcher(rate, nper, pmt, pv, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"fv(rate, nper, pmt, pv, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,"     Compute the future value.    Given:     * a present value, `pv`     * an interest `rate` compounded once per period, of which       there are     * `nper` total     * a (fixed) payment, `pmt`, paid either     * at the beginning (`when` = {'begin', 1}) or the end       (`when` = {'end', 0}) of each period    Return:       the value at the end of the `nper` periods","rate : scalar or array_like of shape(M, )        Rate of interest as decimal (not per cent) per period    nper : scalar or array_like of shape(M, )        Number of compounding periods    pmt : scalar or array_like of shape(M, )        Payment    pv : scalar or array_like of shape(M, )        Present value    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional        When payments are due ('begin' (1) or 'end' (0)).        Defaults to {'end', 0}.","out : ndarray        Future values.  If all input is scalar, returns a scalar float.  If        any input is array_like, returns future values for each input element.        If multiple inputs are array_like, they all must have the same shape."
"_pmt_dispatcher(rate, nper, pv, fv=None, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"pmt(rate, nper, pv, fv=0, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,"     Compute the payment against loan principal plus interest.    Given:     * a present value, `pv` (e.g., an amount borrowed)     * a future value, `fv` (e.g., 0)     * an interest `rate` compounded once per period, of which       there are     * `nper` total     * and (optional) specification of whether payment is made       at the beginning (`when` = {'begin', 1}) or the end       (`when` = {'end', 0}) of each period    Return:       the (fixed) periodic payment.","rate : array_like        Rate of interest (per period)    nper : array_like        Number of compounding periods    pv : array_like        Present value    fv : array_like,  optional        Future value (default = 0)    when : {{'begin', 1}, {'end', 0}}, {string, int}        When payments are due ('begin' (1) or 'end' (0))","out : ndarray        Payment against loan plus interest.  If all input is scalar, returns a        scalar float.  If any input is array_like, returns payment for each        input element. If multiple inputs are array_like, they all must have        the same shape."
"_nper_dispatcher(rate, pmt, pv, fv=None, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"nper(rate, pmt, pv, fv=0, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,     Compute the number of periodic payments.    :class:`decimal.Decimal` type is not supported.,"rate : array_like        Rate of interest (per period)    pmt : array_like        Payment    pv : array_like        Present value    fv : array_like, optional        Future value    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional        When payments are due ('begin' (1) or 'end' (0))",
"_ipmt_dispatcher(rate, per, nper, pv, fv=None, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"ipmt(rate, per, nper, pv, fv=0, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,     Compute the interest portion of a payment.,"rate : scalar or array_like of shape(M, )        Rate of interest as decimal (not per cent) per period    per : scalar or array_like of shape(M, )        Interest paid against the loan changes during the life or the loan.        The `per` is the payment period to calculate the interest amount.    nper : scalar or array_like of shape(M, )        Number of compounding periods    pv : scalar or array_like of shape(M, )        Present value    fv : scalar or array_like of shape(M, ), optional        Future value    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional        When payments are due ('begin' (1) or 'end' (0)).        Defaults to {'end', 0}.","out : ndarray        Interest portion of payment.  If all input is scalar, returns a scalar        float.  If any input is array_like, returns interest payment for each        input element. If multiple inputs are array_like, they all must have        the same shape."
"_rbl(rate, per, pmt, pv, when):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,"     This function is here to simply have a different name for the 'fv'    function to not interfere with the 'fv' keyword argument within the 'ipmt'    function.  It is the 'remaining balance on loan' which might be useful as    it's own function, but is easily calculated with the 'fv' function.",,
"_ppmt_dispatcher(rate, per, nper, pv, fv=None, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"ppmt(rate, per, nper, pv, fv=0, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,     Compute the payment against loan principal.,"rate : array_like        Rate of interest (per period)    per : array_like, int        Amount paid against the loan changes.  The `per` is the period of        interest.    nper : array_like        Number of compounding periods    pv : array_like        Present value    fv : array_like, optional        Future value    when : {{'begin', 1}, {'end', 0}}, {string, int}        When payments are due ('begin' (1) or 'end' (0))",
"_pv_dispatcher(rate, nper, pmt, fv=None, when=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"pv(rate, nper, pmt, fv=0, when='end'):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,"     Compute the present value.    Given:     * a future value, `fv`     * an interest `rate` compounded once per period, of which       there are     * `nper` total     * a (fixed) payment, `pmt`, paid either     * at the beginning (`when` = {'begin', 1}) or the end       (`when` = {'end', 0}) of each period    Return:       the value now","rate : array_like        Rate of interest (per period)    nper : array_like        Number of compounding periods    pmt : array_like        Payment    fv : array_like, optional        Future value    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional        When payments are due ('begin' (1) or 'end' (0))","out : ndarray, float        Present value of a series of payments or investments."
"_g_div_gp(r, n, p, x, y, w):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"_rate_dispatcher(nper, pmt, pv, fv, when=None, guess=None, tol=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"rate(nper, pmt, pv, fv, when='end', guess=None, tol=None, maxiter=100):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,     Compute the rate of interest per period.,"nper : array_like        Number of compounding periods    pmt : array_like        Payment    pv : array_like        Present value    fv : array_like        Future value    when : {{'begin', 1}, {'end', 0}}, {string, int}, optional        When payments are due ('begin' (1) or 'end' (0))    guess : Number, optional        Starting guess for solving the rate of interest, default 0.1    tol : Number, optional        Required tolerance for the solution, default 1e-6    maxiter : int, optional        Maximum iterations in finding the solution",
_irr_dispatcher(values):,https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
irr(values):,https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,"     Return the Internal Rate of Return (IRR).    This is the ""average"" periodically compounded rate of return    that gives a net present value of 0.0; for a more complete explanation,    see Notes below.    :class:`decimal.Decimal` type is not supported.","values : array_like, shape(N,)        Input cash flows per time period.  By convention, net ""deposits""        are negative and net ""withdrawals"" are positive.  Thus, for        example, at least the first element of `values`, which represents        the initial investment, will typically be negative.",out : float        Internal Rate of Return for periodic input values.
"_npv_dispatcher(rate, values):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
"npv(rate, values):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,     Returns the NPV (Net Present Value) of a cash flow series.,"rate : scalar        The discount rate.    values : array_like, shape(M, )        The values of the time series of cash flows.  The (fixed) time        interval between cash flow ""events"" must be the same as that for        which `rate` is given (i.e., if `rate` is per year, then precisely        a year is understood to elapse between each cash flow event).  By        convention, investments or ""deposits"" are negative, income or        ""withdrawals"" are positive; `values` must begin with the initial        investment, thus `values[0]` will typically be negative.",out : float        The NPV of the input cash flow series `values` at the discount        `rate`.
"_mirr_dispatcher(values, finance_rate, reinvest_rate):",https://github.com//numpy/numpy/blob/master/numpy/lib/financial.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,,,
_check_version(version):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,,,
"magic(major, minor):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Return the magic string for the given file format version.,"major : int in [0, 255]    minor : int in [0, 255]",magic : str
read_magic(fp):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Read the magic string to get the version of the file format.,fp : filelike object,"major : int    minor : int """"""    magic_str = _read_bytes(fp, MAGIC_LEN, ""magic string"") if magic_str[:-2] != MAGIC_PREFIX:        msg = ""the magic string is not correct; expected %r, got %r"" raise ValueError(msg % (MAGIC_PREFIX, magic_str[:-2])) if sys.version_info[0] < 3:        major, minor = map(ord, magic_str[-2:]) else:        major, minor = magic_str[-2:] return major, minor
"
dtype_to_descr(dtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,"     Get a serializable descriptor from the dtype.    The .descr attribute of a dtype object cannot be round-tripped through    the dtype() constructor. Simple types, like dtype('float32'), have    a descr which looks like a record array with one field with '' as    a name. The dtype() constructor interprets this as a request to give    a default name.  Instead, we construct descriptor that can be passed to    dtype().",dtype : dtype        The dtype of the array that will be written to disk.,descr : object        An object that can be passed to `numpy.dtype()` in order to        replicate the input dtype.
descr_to_dtype(descr):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,,,
header_data_from_array_1_0(array):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Get the dictionary of header metadata from a numpy.ndarray.,array : numpy.ndarray,"d : dict        This has the appropriate entries for writing its string representation        to the header of the file. """"""    d = {'shape': array.shape} if array.flags.c_contiguous:        d['fortran_order'] = False elif array.flags.f_contiguous:        d['fortran_order'] = True else: # Totally non-contiguous data. We will have to make it C-contiguous # before writing. Note that we need to test for C_CONTIGUOUS first # because a 1-D array is both C_CONTIGUOUS and F_CONTIGUOUS.        d['fortran_order'] = False
    d['descr'] = dtype_to_descr(array.dtype) return d

"
"_wrap_header(header, version):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,"     Takes a stringified header, and attaches the prefix and padding to it",,
_wrap_header_guess_version(header):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,"     Like `_wrap_header`, but chooses an appropriate version given the contents",,
"_write_array_header(fp, d, version=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Write the header for an array and returns the version used,"fp : filelike object    d : dict        This has the appropriate entries for writing its string representation        to the header of the file.    version: tuple or None        None means use oldest that works        explicit version will raise a ValueError if the format does not        allow saving this data.  Default: None """"""    header = [""{""] for key, value in sorted(d.items()): # Need to use repr here, since we eval these when reading        header.append(""'%s': %s, "" % (key, repr(value)))    header.append(""}"")    header = """".join(header)    header = _filter_header(header) if version is None:        header = _wrap_header_guess_version(header) else:        header = _wrap_header(header, version)    fp.write(header)
",
"write_array_header_1_0(fp, d):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Write the header for an array using the 1.0 format.,"fp : filelike object    d : dict        This has the appropriate entries for writing its string        representation to the header of the file. """"""    _write_array_header(fp, d, (1, 0))

",
"write_array_header_2_0(fp, d):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,  Write the header for an array using the 2.0 format.        The 2.0 format allows storing very large structured arrays.    .. versionadded:: 1.9.0,"fp : filelike object    d : dict        This has the appropriate entries for writing its string        representation to the header of the file. """"""    _write_array_header(fp, d, (2, 0))
",
read_array_header_1_0(fp):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,     Read an array header from a filelike object using the 1.0 file format    version.    This will leave the file object located just after the header.,fp : filelike object        A file object or something with a `.read()` method like a file.,"shape : tuple of int        The shape of the array.    fortran_order : bool        The array data will be written out directly if it is either        C-contiguous or Fortran-contiguous. Otherwise, it will be made        contiguous before writing it out.    dtype : dtype        The dtype of the file's data."
read_array_header_2_0(fp):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,     Read an array header from a filelike object using the 2.0 file format    version.    This will leave the file object located just after the header.    .. versionadded:: 1.9.0,fp : filelike object        A file object or something with a `.read()` method like a file.,"shape : tuple of int        The shape of the array.    fortran_order : bool        The array data will be written out directly if it is either        C-contiguous or Fortran-contiguous. Otherwise, it will be made        contiguous before writing it out.    dtype : dtype        The dtype of the file's data."
_filter_header(s):,https://github.com//numpy/numpy/blob/master/numpy/lib/format.py, Clean up 'L' in npz header ints.    Cleans up the 'L' in strings representing integers. Needed to allow npz    headers produced in Python2 to be read in Python3.,s : string        Npy file header.,header : str        Cleaned up header.
"_read_array_header(fp, version):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,     see read_array_header_1_0,,
"write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,"     Write an array to an NPY file, including a header.    If the array is neither C-contiguous nor Fortran-contiguous AND the    file_like object is not a real file object, this function will have to    copy data in memory.","fp : file_like object        An open, writable file object, or similar object with a        ``.write()`` method.    array : ndarray        The array to write to disk.    version : (int, int) or None, optional        The version number of the format. None means use the oldest        supported version that is able to store the data.  Default: None    allow_pickle : bool, optional        Whether to allow writing pickled data. Default: True    pickle_kwargs : dict, optional        Additional keyword arguments to pass to pickle.dump, excluding        'protocol'. These are only useful when pickling objects in object        arrays on Python 3 to Python 2 compatible format.",
"read_array(fp, allow_pickle=False, pickle_kwargs=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,     Read an array from an NPY file.,"fp : file_like object        If this is not a real file object, then this may take extra memory        and time.    allow_pickle : bool, optional        Whether to allow writing pickled data. Default: False",array : ndarray        The array from the data on disk.
"open_memmap(filename, mode='r+', dtype=None, shape=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/format.py,     Open a .npy file as a memory-mapped array.    This may be used to read an existing file or create a new one.,"filename : str or path-like        The name of the file on disk.  This may *not* be a file-like        object.    mode : str, optional        The mode in which to open the file; the default is 'r+'.  In        addition to the standard file modes, 'c' is also accepted to mean        ""copy on write.""  See `memmap` for the available mode strings.    dtype : data-type, optional        The data type of the array if we are creating a new file in ""write""        mode, if not, `dtype` is ignored.  The default value is None, which        results in a data-type of `float64`.    shape : tuple of int        The shape of the array if we are creating a new file in ""write""        mode, in which case this parameter is required.  Otherwise, this        parameter is ignored and is thus optional.    fortran_order : bool, optional        Whether the array should be Fortran-contiguous (True) or        C-contiguous (False, the default) if we are creating a new file in        ""write"" mode.    version : tuple of int (major, minor) or None        If the mode is a ""write"" mode, then this is the version of the file        format used to create the file.  None means use the oldest        supported version that is able to store the data.  Default: None",marray : memmap        The memory-mapped array.
,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"_rot90_dispatcher(m, k=None, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"rot90(m, k=1, axes=(0,1)):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Rotate an array by 90 degrees in the plane specified by axes.    Rotation direction is from the first towards the second axis.,"m : array_like        Array of two or more dimensions.    k : integer        Number of times the array is rotated by 90 degrees.    axes: (2,) array_like        The array is rotated in the plane defined by the axes.        Axes must be different.",y : ndarray        A rotated view of `m`.
"_flip_dispatcher(m, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"flip(m, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Reverse the order of elements in an array along the given axis.    The shape of the array is preserved, but the elements are reordered.    .. versionadded:: 1.12.0","m : array_like        Input array.    axis : None or int or tuple of ints, optional         Axis or axes along which to flip over. The default,         axis=None, will flip over all of the axes of the input array.         If axis is negative it counts from the last to the first axis.","out : array_like        A view of `m` with the entries of axis reversed.  Since a view is        returned, this operation is done in constant time."
iterable(y):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Check whether or not an object can be iterated over.,y : object      Input object.,b : bool      Return ``True`` if the object has an iterator method or is a      sequence and ``False`` otherwise.
"_average_dispatcher(a, axis=None, weights=None, returned=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"average(a, axis=None, weights=None, returned=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Compute the weighted average along the specified axis.,"a : array_like        Array containing data to be averaged. If `a` is not an array, a        conversion is attempted.    axis : None or int or tuple of ints, optional        Axis or axes along which to average `a`.  The default,        axis=None, will average over all of the elements of the input array.        If axis is negative it counts from the last to the first axis.","retval, [sum_of_weights] : array_type or double        Return the average along the specified axis. When `returned` is `True`,        return a tuple with the average as the first element and the sum        of the weights as the second element. `sum_of_weights` is of the        same type as `retval`. The result dtype follows a genereal pattern.        If `weights` is None, the result dtype will be that of `a` , or ``float64``        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-        integral, the result type will be the type of lowest precision capable of        representing values of both `a` and `weights`. If `a` happens to be        integral, the previous rules still applies but the result dtype will        at least be ``float64``."
"asarray_chkfinite(a, dtype=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py," Convert the input to an array, checking for NaNs or Infs.","a : array_like        Input data, in any form that can be converted to an array.  This        includes lists, lists of tuples, tuples, tuples of tuples, tuples        of lists and ndarrays.  Success requires no NaNs or Infs.    dtype : data-type, optional        By default, the data-type is inferred from the input data.    order : {'C', 'F'}, optional         Whether to use row-major (C-style) or         column-major (Fortran-style) memory representation.         Defaults to 'C'.","out : ndarray        Array interpretation of `a`.  No copy is performed if the input        is already an ndarray.  If `a` is a subclass of ndarray, a base        class ndarray is returned."
"_piecewise_dispatcher(x, condlist, funclist, *args, **kw):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"piecewise(x, condlist, funclist, *args, **kw):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Evaluate a piecewise-defined function.    Given a set of conditions and corresponding functions, evaluate each    function on the input data wherever its condition is true.","x : ndarray or scalar        The input domain.    condlist : list of bool arrays or bool scalars        Each boolean array corresponds to a function in `funclist`.  Wherever        `condlist[i]` is True, `funclist[i](x)` is used as the output value.","out : ndarray        The output is the same shape and type as x and is found by        calling the functions in `funclist` on the appropriate portions of `x`,        as defined by the boolean arrays in `condlist`.  Portions not covered        by any condition have a default value of 0."
"_select_dispatcher(condlist, choicelist, default=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"select(condlist, choicelist, default=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return an array drawn from elements in choicelist, depending on conditions.","condlist : list of bool ndarrays        The list of conditions which determine from which array in `choicelist`        the output elements are taken. When multiple conditions are satisfied,        the first one encountered in `condlist` is used.    choicelist : list of ndarrays        The list of arrays from which the output elements are taken. It has        to be of the same length as `condlist`.    default : scalar, optional        The element inserted in `output` when all conditions evaluate to False.",output : ndarray        The output at position m is the m-th element of the array in        `choicelist` where the m-th element of the corresponding array in        `condlist` is True.
"_copy_dispatcher(a, order=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"copy(a, order='K'):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return an array copy of the given object.,"a : array_like        Input data.    order : {'C', 'F', 'A', 'K'}, optional        Controls the memory layout of the copy. 'C' means C-order,        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,        'C' otherwise. 'K' means match the layout of `a` as closely        as possible. (Note that this function and :meth:`ndarray.copy` are very        similar, but have different default values for their order=        arguments.)",arr : ndarray        Array interpretation of `a`.
"_gradient_dispatcher(f, *varargs, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"gradient(f, *varargs, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the gradient of an N-dimensional array.    The gradient is computed using second order accurate central differences    in the interior points and either first or second order accurate one-sides    (forward or backwards) differences at the boundaries.    The returned gradient hence has the same shape as the input array.,"f : array_like        An N-dimensional array containing samples of a scalar function.    varargs : list of scalar or array, optional        Spacing between f values. Default unitary spacing for all dimensions.        Spacing can be specified using:",gradient : ndarray or list of ndarray        A set of ndarrays (or a single ndarray if there is only one dimension)        corresponding to the derivatives of f with respect to each dimension.        Each derivative has the same shape as f.
"_diff_dispatcher(a, n=None, axis=None, prepend=None, append=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Calculate the n-th discrete difference along the given axis.    The first difference is given by ``out[i] = a[i+1] - a[i]`` along    the given axis, higher differences are calculated by using `diff`    recursively.","a : array_like        Input array    n : int, optional        The number of times values are differenced. If zero, the input        is returned as-is.    axis : int, optional        The axis along which the difference is taken, default is the        last axis.    prepend, append : array_like, optional        Values to prepend or append to ""a"" along axis prior to        performing the difference.  Scalar values are expanded to        arrays with length 1 in the direction of axis and the shape        of the input array in along all other axes.  Otherwise the        dimension and shape must match ""a"" except along axis.","diff : ndarray        The n-th differences. The shape of the output is the same as `a`        except along `axis` where the dimension is smaller by `n`. The        type of the output is the same as the type of the difference        between any two elements of `a`. This is the same as the type of        `a` in most cases. A notable exception is `datetime64`, which        results in a `timedelta64` output array."
"_interp_dispatcher(x, xp, fp, left=None, right=None, period=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"interp(x, xp, fp, left=None, right=None, period=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     One-dimensional linear interpolation.    Returns the one-dimensional piecewise linear interpolant to a function    with given discrete data points (`xp`, `fp`), evaluated at `x`.",x : array_like        The x-coordinates at which to evaluate the interpolated values.,"y : float or complex (corresponding to fp) or ndarray        The interpolated values, same shape as `x`."
"_angle_dispatcher(z, deg=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"angle(z, deg=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the angle of the complex argument.,"z : array_like        A complex number or sequence of complex numbers.    deg : bool, optional        Return angle in degrees if True, radians if False (default).","angle : ndarray or scalar        The counterclockwise angle from the positive real axis on the complex        plane in the range ``(-pi, pi]``, with dtype as numpy.float64."
"_unwrap_dispatcher(p, discont=None, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"unwrap(p, discont=pi, axis=-1):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Unwrap by changing deltas between values to 2*pi complement.    Unwrap radian phase `p` by changing absolute jumps greater than    `discont` to their 2*pi complement along the given axis.,"p : array_like        Input array.    discont : float, optional        Maximum discontinuity between values, default is ``pi``.    axis : int, optional        Axis along which unwrap will operate, default is the last axis.",out : ndarray        Output array.
_sort_complex(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
sort_complex(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Sort a complex array using the real part first, then the imaginary part.",a : array_like        Input array,out : complex ndarray        Always returns a sorted complex array.
"_trim_zeros(filt, trim=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"trim_zeros(filt, trim='fb'):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Trim the leading and/or trailing zeros from a 1-D array or sequence.,"filt : 1-D array or sequence        Input array.    trim : str, optional        A string with 'f' representing trim from front and 'b' to trim from        back. Default is 'fb', trim zeros from both front and back of the        array.",trimmed : 1-D array or sequence        The result of trimming the input. The input data type is preserved.
"_extract_dispatcher(condition, arr):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"extract(condition, arr):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return the elements of an array that satisfy some condition.    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.    Note that `place` does the exact opposite of `extract`.",condition : array_like        An array whose nonzero or True entries indicate the elements of `arr`        to extract.    arr : array_like        Input array of the same size as `condition`.,extract : ndarray        Rank 1 array of values from `arr` where `condition` is True.
"_place_dispatcher(arr, mask, vals):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"place(arr, mask, vals):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Change elements of an array based on conditional and input values.    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that    `place` uses the first N elements of `vals`, where N is the number of    True values in `mask`, while `copyto` uses the elements where `mask`    is True.    Note that `extract` does the exact opposite of `place`.","arr : ndarray        Array to put data into.    mask : array_like        Boolean mask array. Must have the same size as `a`.    vals : 1-D sequence        Values to put into `a`. Only the first N elements are used, where        N is the number of True values in `mask`. If `vals` is smaller        than N, it will be repeated, and if elements of `a` are to be masked,        this sequence must be non-empty.",
"disp(mesg, device=None, linefeed=True):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Display a message on a device.,"mesg : str        Message to display.    device : object        Device to write message. If None, defaults to ``sys.stdout`` which is        very similar to ``print``. `device` needs to have ``write()`` and        ``flush()`` methods.    linefeed : bool, optional        Option whether to print a line feed or not. Defaults to True.",
_parse_gufunc_signature(signature):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Parse string signatures for a generalized universal function.    Arguments    ---------    signature : string        Generalized universal function signature, e.g., ``(m,n),(n,p)->(m,p)``        for ``np.matmul``.",,"Tuple of input and output core dimensions parsed from the signature, each    of the form List[Tuple[str, ...]]. """""" if not re.match(_SIGNATURE, signature): raise ValueError( 'not a valid gufunc signature: {}'.format(signature)) return tuple([tuple(re.findall(_DIMENSION_NAME, arg)) for arg in re.findall(_ARGUMENT, arg_list)] for arg_list in signature.split('->'))

"
"_update_dim_sizes(dim_sizes, arg, core_dims):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Incrementally check and update core dimension sizes for a single argument.    Arguments    ---------    dim_sizes : Dict[str, int]        Sizes of existing core dimensions. Will be updated in-place.    arg : ndarray        Argument to examine.    core_dims : Tuple[str, ...]        Core dimensions for this argument.",,
"_parse_input_dimensions(args, input_core_dims):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Parse broadcast and core dimensions for vectorize with a signature.    Arguments    ---------    args : Tuple[ndarray, ...]        Tuple of input arguments to examine.    input_core_dims : List[Tuple[str, ...]]        List of core dimensions corresponding to each input.",,"broadcast_shape : Tuple[int, ...]        Common shape to broadcast all non-core dimensions to.    dim_sizes : Dict[str, int]        Common sizes for named core dimensions. """"""    broadcast_args = []    dim_sizes = {} for arg, core_dims in zip(args, input_core_dims):        _update_dim_sizes(dim_sizes, arg, core_dims)        ndim = arg.ndim - len(core_dims)        dummy_array = np.lib.stride_tricks.as_strided(0, arg.shape[:ndim])        broadcast_args.append(dummy_array)    broadcast_shape = np.lib.stride_tricks._broadcast_shape(*broadcast_args) return broadcast_shape, dim_sizes

"
"_calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py," Helper for calculating broadcast shapes with core dimensions. return [broadcast_shape + tuple(dim_sizes[dim] for dim in core_dims) for core_dims in list_of_core_dims]

",,
"_create_arrays(broadcast_shape, dim_sizes, list_of_core_dims, dtypes):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py," Helper for creating output arrays in vectorize.    shapes = _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims)    arrays = tuple(np.empty(shape, dtype=dtype) for shape, dtype in zip(shapes, dtypes)) return arrays

@set_module('numpy')class vectorize(object):","pyfunc : callable        A python function or method.    otypes : str or list of dtypes, optional        The output data type. It must be specified as either a string of        typecode characters or a list of data type specifiers. There should        be one data type specifier for each output.    doc : str, optional        The docstring for the function. If `None`, the docstring will be the        ``pyfunc.__doc__``.    excluded : set, optional        Set of strings or integers representing the positional or keyword        arguments for which the function will not be vectorized.  These will be        passed directly to `pyfunc` unmodified.",vectorized : callable        Vectorized function.
"_cov_dispatcher(m, y=None, rowvar=None, bias=None, ddof=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Estimate a covariance matrix, given data and weights.    Covariance indicates the level to which two variables vary together.    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,    then the covariance matrix element :math:`C_{ij}` is the covariance of    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance    of :math:`x_i`.    See the notes for an outline of the algorithm.","m : array_like        A 1-D or 2-D array containing multiple variables and observations.        Each row of `m` represents a variable, and each column a single        observation of all those variables. Also see `rowvar` below.    y : array_like, optional        An additional set of variables and observations. `y` has the same form        as that of `m`.    rowvar : bool, optional        If `rowvar` is True (default), then each row represents a        variable, with observations in the columns. Otherwise, the relationship        is transposed: each column represents a variable, while the rows        contain observations.    bias : bool, optional        Default normalization (False) is by ``(N - 1)``, where ``N`` is the        number of observations given (unbiased estimate). If `bias` is True,        then normalization is by ``N``. These values can be overridden by using        the keyword ``ddof`` in numpy versions >= 1.5.    ddof : int, optional        If not ``None`` the default value implied by `bias` is overridden.        Note that ``ddof=1`` will return the unbiased estimate, even if both        `fweights` and `aweights` are specified, and ``ddof=0`` will return        the simple average. See the notes for the details. The default value        is ``None``.",out : ndarray        The covariance matrix of the variables.
"_corrcoef_dispatcher(x, y=None, rowvar=None, bias=None, ddof=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return Pearson product-moment correlation coefficients.    Please refer to the documentation for `cov` for more detail.  The    relationship between the correlation coefficient matrix, `R`, and the    covariance matrix, `C`, is    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }    The values of `R` are between -1 and 1, inclusive.","x : array_like        A 1-D or 2-D array containing multiple variables and observations.        Each row of `x` represents a variable, and each column a single        observation of all those variables. Also see `rowvar` below.    y : array_like, optional        An additional set of variables and observations. `y` has the same        shape as `x`.    rowvar : bool, optional        If `rowvar` is True (default), then each row represents a        variable, with observations in the columns. Otherwise, the relationship        is transposed: each column represents a variable, while the rows        contain observations.    bias : _NoValue, optional        Has no effect, do not use.",R : ndarray        The correlation coefficient matrix of the variables.
blackman(M):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return the Blackman window.    The Blackman window is a taper formed by using the first three    terms of a summation of cosines. It was designed to have close to the    minimal leakage possible.  It is close to optimal, only slightly worse    than a Kaiser window.","M : int        Number of points in the output window. If zero or less, an empty        array is returned.","out : ndarray        The window, with the maximum value normalized to one (the value one        appears only if the number of samples is odd)."
bartlett(M):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return the Bartlett window.    The Bartlett window is very similar to a triangular window, except    that the end points are at zero.  It is often used in signal    processing for tapering a signal, without generating too much    ripple in the frequency domain.","M : int        Number of points in the output window. If zero or less, an        empty array is returned.","out : array        The triangular window, with the maximum value normalized to one        (the value one appears only if the number of samples is odd), with        the first and last samples equal to zero."
hanning(M):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the Hanning window.    The Hanning window is a taper formed by using a weighted cosine.,"M : int        Number of points in the output window. If zero or less, an        empty array is returned.","out : ndarray, shape(M,)        The window, with the maximum value normalized to one (the value        one appears only if `M` is odd)."
hamming(M):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the Hamming window.    The Hamming window is a taper formed by using a weighted cosine.,"M : int        Number of points in the output window. If zero or less, an        empty array is returned.","out : ndarray        The window, with the maximum value normalized to one (the value        one appears only if the number of samples is odd)."
"_chbevl(x, vals):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
_i0_1(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
_i0_2(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
_i0_dispatcher(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
i0(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Modified Bessel function of the first kind, order 0.    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*    ""up-cast"" int dtype arguments unless accompanied by at least one float or    complex dtype argument (see Raises below).","x : array_like, dtype float or complex        Argument of the Bessel function.","out : ndarray, shape = x.shape, dtype = x.dtype        The modified Bessel function evaluated at each of the elements of `x`."
"kaiser(M, beta):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the Kaiser window.    The Kaiser window is a taper formed by using a Bessel function.,"M : int        Number of points in the output window. If zero or less, an        empty array is returned.    beta : float        Shape parameter for window.","out : array        The window, with the maximum value normalized to one (the value        one appears only if the number of samples is odd)."
_sinc_dispatcher(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
sinc(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return the sinc function.    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.,x : ndarray        Array (possibly multi-dimensional) of values for which to to        calculate ``sinc(x)``.,"out : ndarray        ``sinc(x)``, which has the same shape as the input."
_msort_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
msort(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Return a copy of an array sorted along the first axis.,a : array_like        Array to be sorted.,sorted_array : ndarray        Array of the same type and shape as `a`.
"_ureduce(a, func, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Internal Function.    Call `func` with `a` as first argument swapping the axes to use extended    axis on functions that don't support it natively.    Returns result and a.shape with axis dims set to 1.,a : array_like        Input array or object that can be converted to an array.    func : callable        Reduction function capable of receiving a single axis argument.        It is called with `a` as first argument followed by `kwargs`.    kwargs : keyword arguments        additional keyword arguments to pass to `func`.,"result : tuple        Result of func(a, **kwargs) and a.shape with axis dims set to 1        which can be used to reshape the result to the same shape a ufunc with        keepdims=True would produce."
_median_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"median(a, axis=None, out=None, overwrite_input=False, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Compute the median along the specified axis.    Returns the median of the array elements.,"a : array_like        Input array or object that can be converted to an array.    axis : {int, sequence of int, None}, optional        Axis or axes along which the medians are computed. The default        is to compute the median along a flattened version of the array.        A sequence of axes is supported since version 1.9.0.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output,        but the type (of the output) will be cast if necessary.    overwrite_input : bool, optional       If True, then allow use of memory of input array `a` for       calculations. The input array will be modified by the call to       `median`. This will save memory when you do not need to preserve       the contents of the input array. Treat the input as undefined,       but it will probably be fully or partially sorted. Default is       False. If `overwrite_input` is ``True`` and `a` is not already an       `ndarray`, an error will be raised.    keepdims : bool, optional        If this is set to True, the axes which are reduced are left        in the result as dimensions with size one. With this option,        the result will broadcast correctly against the original `arr`.","median : ndarray        A new array holding the result. If the input contains integers        or floats smaller than ``float64``, then the output data-type is        ``np.float64``.  Otherwise, the data-type of the output is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_median(a, axis=None, out=None, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"_percentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"percentile(a, q, axis=None, out=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Compute the q-th percentile of the data along the specified axis.    Returns the q-th percentile(s) of the array elements.,"a : array_like        Input array or object that can be converted to an array.    q : array_like of float        Percentile or sequence of percentiles to compute, which must be between        0 and 100 inclusive.    axis : {int, tuple of int, None}, optional        Axis or axes along which the percentiles are computed. The        default is to compute the percentile(s) along a flattened        version of the array.","percentile : scalar or ndarray        If `q` is a single percentile and `axis=None`, then the result        is a scalar. If multiple percentiles are given, first axis of        the result corresponds to the percentiles. The other axes are        the axes that remain after the reduction of `a`. If the input        contains integers or floats smaller than ``float64``, the output        data-type is ``float64``. Otherwise, the output data-type is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_quantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"quantile(a, q, axis=None, out=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Compute the q-th quantile of the data along the specified axis.     .. versionadded:: 1.15.0,"a : array_like        Input array or object that can be converted to an array.    q : array_like of float        Quantile or sequence of quantiles to compute, which must be between        0 and 1 inclusive.    axis : {int, tuple of int, None}, optional        Axis or axes along which the quantiles are computed. The        default is to compute the quantile(s) along a flattened        version of the array.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output,        but the type (of the output) will be cast if necessary.    overwrite_input : bool, optional        If True, then allow the input array `a` to be modified by intermediate        calculations, to save memory. In this case, the contents of the input        `a` after this function completes is undefined.    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}        This optional parameter specifies the interpolation method to        use when the desired quantile lies between two data points        ``i < j``:","quantile : scalar or ndarray        If `q` is a single quantile and `axis=None`, then the result        is a scalar. If multiple quantiles are given, first axis of        the result corresponds to the quantiles. The other axes are        the axes that remain after the reduction of `a`. If the input        contains integers or floats smaller than ``float64``, the output        data-type is ``float64``. Otherwise, the output data-type is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_quantile_unchecked(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py," Assumes that q is in [0, 1], and is an ndarray    r, k = _ureduce(a, func=_quantile_ureduce_func, q=q, axis=axis, out=out, overwrite_input=overwrite_input, interpolation=interpolation) if keepdims: return r.reshape(q.shape + k) else: return r

",,
_quantile_is_valid(q):,https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"_quantile_ureduce_func(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"_trapz_dispatcher(y, x=None, dx=None, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"trapz(y, x=None, dx=1.0, axis=-1):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Integrate along the given axis using the composite trapezoidal rule.    Integrate `y` (`x`) along given axis.,"y : array_like        Input array to integrate.    x : array_like, optional        The sample points corresponding to the `y` values. If `x` is None,        the sample points are assumed to be evenly spaced `dx` apart. The        default is None.    dx : scalar, optional        The spacing between sample points when `x` is None. The default is 1.    axis : int, optional        The axis along which to integrate.",trapz : float        Definite integral as approximated by trapezoidal rule.
"_meshgrid_dispatcher(*xi, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"meshgrid(*xi, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return coordinate matrices from coordinate vectors.    Make N-D coordinate arrays for vectorized evaluations of    N-D scalar/vector fields over N-D grids, given    one-dimensional coordinate arrays x1, x2,..., xn.    .. versionchanged:: 1.9       1-D and 0-D cases are allowed.","x1, x2,..., xn : array_like        1-D arrays representing the coordinates of a grid.    indexing : {'xy', 'ij'}, optional        Cartesian ('xy', default) or matrix ('ij') indexing of output.        See Notes for more details.","X1, X2,..., XN : ndarray        For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'        with the elements of `xi` repeated to fill the matrix along        the first dimension for `x1`, the second for `x2` and so on."
"_delete_dispatcher(arr, obj, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"delete(arr, obj, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,"     Return a new array with sub-arrays along an axis deleted. For a one    dimensional array, this returns those entries not returned by    `arr[obj]`.","arr : array_like      Input array.    obj : slice, int or array of ints      Indicate indices of sub-arrays to remove along the specified axis.    axis : int, optional      The axis along which to delete the subarray defined by `obj`.      If `axis` is None, `obj` is applied to the flattened array.","out : ndarray        A copy of `arr` with the elements specified by `obj` removed. Note        that `delete` does not occur in-place. If `axis` is None, `out` is        a flattened array."
"_insert_dispatcher(arr, obj, values, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"insert(arr, obj, values, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Insert values along the given axis before the given indices.,"arr : array_like        Input array.    obj : int, slice or sequence of ints        Object that defines the index or indices before which `values` is        inserted.","out : ndarray        A copy of `arr` with `values` inserted.  Note that `insert`        does not occur in-place: a new array is returned. If        `axis` is None, `out` is a flattened array."
"_append_dispatcher(arr, values, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
"append(arr, values, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,     Append values to the end of an array.,"arr : array_like        Values are appended to a copy of this array.    values : array_like        These values are appended to a copy of `arr`.  It must be of the        correct shape (the same shape as `arr`, excluding `axis`).  If        `axis` is not specified, `values` can be any shape and will be        flattened before use.    axis : int, optional        The axis along which `values` are appended.  If `axis` is not        given, both `arr` and `values` are flattened before use.","append : ndarray        A copy of `arr` with `values` appended to `axis`.  Note that        `append` does not occur in-place: a new array is allocated and        filled.  If `axis` is None, `out` is a flattened array."
"_digitize_dispatcher(x, bins, right=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/function_base.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,,,
"_hist_bin_sqrt(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,     Square root histogram bin estimator.    Bin width is inversely proportional to the data size. Used by many    programs for its simplicity.,"x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused return x.ptp() / np.sqrt(x.size)

"
"_hist_bin_sturges(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Sturges histogram bin estimator.    A very simplistic estimator based on the assumption of normality of    the data. This estimator has poor performance for non-normal data,    which becomes especially obvious for large data sets. The estimate    depends only on size of the data.","x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused return x.ptp() / (np.log2(x.size) + 1.0)

"
"_hist_bin_rice(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Rice histogram bin estimator.    Another simple estimator with no normality assumption. It has better    performance for large data than Sturges, but tends to overestimate    the number of bins. The number of bins is proportional to the cube    root of data size (asymptotically optimal). The estimate depends    only on size of the data.","x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused return x.ptp() / (2.0 * x.size ** (1.0 / 3))

"
"_hist_bin_scott(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,     Scott histogram bin estimator.    The binwidth is proportional to the standard deviation of the data    and inversely proportional to the cube root of data size    (asymptotically optimal).,"x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused return (24.0 * np.pi**0.5 / x.size)**(1.0 / 3.0) * np.std(x)

"
"_hist_bin_stone(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,     Histogram bin estimator based on minimizing the estimated integrated squared error (ISE).    The number of bins is chosen by minimizing the estimated ISE against the unknown true distribution.    The ISE is estimated using cross-validation and can be regarded as a generalization of Scott's rule.    https://en.wikipedia.org/wiki/Histogram#Scott.27s_normal_reference_rule    This paper by Stone appears to be the origination of this rule.    http://digitalassets.lib.berkeley.edu/sdtr/ucb/text/34.pdf,"x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.    range : (float, float)        The lower and upper range of the bins.","h : An estimate of the optimal bin width for the given data. """"""
    n = x.size    ptp_x = np.ptp(x) if n <= 1 or ptp_x == 0: return 0
 def jhat(nbins):        hh = ptp_x / nbins        p_k = np.histogram(x, bins=nbins, range=range)[0] / n return (2 - (n + 1) * p_k.dot(p_k)) / hh
    nbins_upper_bound = max(100, int(np.sqrt(n)))    nbins = min(_range(1, nbins_upper_bound + 1), key=jhat) if nbins == nbins_upper_bound:        warnings.warn(""The number of bins estimated may be suboptimal."", RuntimeWarning, stacklevel=3) return ptp_x / nbins

"
"_hist_bin_doane(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,     Doane's histogram bin estimator.    Improved version of Sturges' formula which works better for    non-normal data. See    stats.stackexchange.com/questions/55134/doanes-formula-for-histogram-binning,"x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused if x.size > 2:        sg1 = np.sqrt(6.0 * (x.size - 2) / ((x.size + 1.0) * (x.size + 3)))        sigma = np.std(x) if sigma > 0.0: # These three operations add up to # g1 = np.mean(((x - np.mean(x)) / sigma)**3) # but use only one temp array instead of three            temp = x - np.mean(x)            np.true_divide(temp, sigma, temp)            np.power(temp, 3, temp)            g1 = np.mean(temp) return x.ptp() / (1.0 + np.log2(x.size) +                                    np.log2(1.0 + np.absolute(g1) / sg1)) return 0.0

"
"_hist_bin_fd(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     The Freedman-Diaconis histogram bin estimator.    The Freedman-Diaconis rule uses interquartile range (IQR) to    estimate binwidth. It is considered a variation of the Scott rule    with more robustness as the IQR is less affected by outliers than    the standard deviation. However, the IQR depends on fewer points    than the standard deviation, so it is less accurate, especially for    long tailed distributions.    If the IQR is 0, this function returns 1 for the number of bins.    Binwidth is inversely proportional to the cube root of data size    (asymptotically optimal).","x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.","h : An estimate of the optimal bin width for the given data. """""" del range # unused    iqr = np.subtract(*np.percentile(x, [75, 25])) return 2.0 * iqr * x.size ** (-1.0 / 3.0)

"
"_hist_bin_auto(x, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Histogram bin estimator that uses the minimum width of the    Freedman-Diaconis and Sturges estimators if the FD bandwidth is non zero    and the Sturges estimator if the FD bandwidth is 0.    The FD estimator is usually the most robust method, but its width    estimate tends to be too large for small `x` and bad for data with limited    variance. The Sturges estimator is quite good for small (<1000) datasets    and is the default in the R language. This method gives good off the shelf    behaviour.    .. versionchanged:: 1.15.0    If there is limited variance the IQR can be 0, which results in the    FD bin width being 0 too. This is not a valid bin width, so    ``np.histogram_bin_edges`` chooses 1 bin instead, which may not be optimal.    If the IQR is 0, it's unlikely any variance based estimators will be of    use, so we revert to the sturges estimator, which only uses the size of the    dataset in its calculation.","x : array_like        Input data that is to be histogrammed, trimmed to range. May not        be empty.",h : An estimate of the optimal bin width for the given data.
"_ravel_and_check_weights(a, weights):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"  Check a and weights have matching shapes, and ravel both     a = np.asarray(a)
 # Ensure that the array is a ""subtractable"" dtype if a.dtype == np.bool_:        warnings.warn(""Converting input from {} to {} for compatibility.""                      .format(a.dtype, np.uint8), RuntimeWarning, stacklevel=3)        a = a.astype(np.uint8)
 if weights is not None:        weights = np.asarray(weights) if weights.shape != a.shape: raise ValueError( 'weights should have the same shape as a.')        weights = weights.ravel()    a = a.ravel() return a, weights

",,
"_get_outer_edges(a, range):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Determine the outer bin edges to use, from either the data or the range    argument",,
"_unsigned_subtract(a, b):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Subtract two values where a >= b, and produce an unsigned result    This is needed when finding the difference between the upper and lower    bound of an int16 histogram",,
"_get_bin_edges(a, bins, range, weights):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,     Computes the bins used internally by `histogram`.,"    Parameters    ==========    a : ndarray        Ravelled data array    bins, range        Forwarded arguments from `histogram`.    weights : ndarray, optional        Ravelled weights array, or None","    Returns    =======    bin_edges : ndarray        Array of bin edges    uniform_bins : (Number, Number, int):        The upper bound, lowerbound, and number of bins, used in the optimized        implementation of `histogram` that works on uniform bins. """""" # parse the overloaded bins argument    n_equal_bins = None    bin_edges = None
 if isinstance(bins, basestring):        bin_name = bins # if `bins` is a string for an automatic method, # this will replace it with the number of bins calculated if bin_name not in _hist_bin_selectors: raise ValueError( ""{!r} is not a valid estimator for `bins`"".format(bin_name)) if weights is not None: raise TypeError(""Automated estimation of the number of "" ""bins is not supported for weighted data"")
        first_edge, last_edge = _get_outer_edges(a, range)
 # truncate the range if needed if range is not None:            keep = (a >= first_edge)            keep &= (a <= last_edge) if not np.logical_and.reduce(keep):                a = a[keep]
 if a.size == 0:            n_equal_bins = 1 else: # Do not call selectors on empty arrays            width = _hist_bin_selectors[bin_name](a, (first_edge, last_edge)) if width:                n_equal_bins = int(np.ceil(_unsigned_subtract(last_edge, first_edge) / width)) else: # Width can be zero for some estimators, e.g. FD when # the IQR of the data is zero.                n_equal_bins = 1
 elif np.ndim(bins) == 0: try:            n_equal_bins = operator.index(bins) except TypeError: raise TypeError( '`bins` must be an integer, a string, or an array') if n_equal_bins < 1: raise ValueError('`bins` must be positive, when an integer')
        first_edge, last_edge = _get_outer_edges(a, range)
 elif np.ndim(bins) == 1:        bin_edges = np.asarray(bins) if np.any(bin_edges[:-1] > bin_edges[1:]): raise ValueError( '`bins` must increase monotonically, when an array')
 else: raise ValueError('`bins` must be 1d, when an array')
 if n_equal_bins is not None: # gh-10322 means that type resolution rules are dependent on array # shapes. To avoid this causing problems, we pick a type now and stick # with it throughout.        bin_type = np.result_type(first_edge, last_edge, a) if np.issubdtype(bin_type, np.integer):            bin_type = np.result_type(bin_type, float)
 # bin edges must be computed        bin_edges = np.linspace(            first_edge, last_edge, n_equal_bins + 1, endpoint=True, dtype=bin_type) return bin_edges, (first_edge, last_edge, n_equal_bins) else: return bin_edges, None

"
"_search_sorted_inclusive(a, v):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,"     Like `searchsorted`, but where the last item in `v` is placed on the right.    In the context of a histogram, this makes the last bin edge inclusive",,
"_histogram_bin_edges_dispatcher(a, bins=None, range=None, weights=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,,,
"histogram_bin_edges(a, bins=10, range=None, weights=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py, r    Function to calculate only the edges of the bins used by the `histogram`    function.,"a : array_like        Input data. The histogram is computed over the flattened array.    bins : int or sequence of scalars or str, optional        If `bins` is an int, it defines the number of equal-width        bins in the given range (10, by default). If `bins` is a        sequence, it defines the bin edges, including the rightmost        edge, allowing for non-uniform bin widths.",bin_edges : array of dtype float        The edges to pass into `histogram`
_histogram_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,,,
"histogram(a, bins=10, range=None, normed=None, weights=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py, r    Compute the histogram of a set of data.,"a : array_like        Input data. The histogram is computed over the flattened array.    bins : int or sequence of scalars or str, optional        If `bins` is an int, it defines the number of equal-width        bins in the given range (10, by default). If `bins` is a        sequence, it defines a monotonically increasing array of bin edges,        including the rightmost edge, allowing for non-uniform bin widths.",hist : array        The values of the histogram. See `density` and `weights` for a        description of the possible semantics.    bin_edges : array of dtype float        Return the bin edges ``(length(hist)+1)``.
"_histogramdd_dispatcher(sample, bins=None, range=None, normed=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/histograms.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,,,
_ix__dispatcher(*args):,https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,,,
ix_(*args):,https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,"     Construct an open mesh from multiple sequences.    This function takes N 1-D sequences and returns N outputs with N    dimensions each, such that the shape is 1 in all but one dimension    and the dimension with the non-unit shape value cycles through all    N dimensions.    Using `ix_` one can quickly construct index arrays that will index    the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array    ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.","args : 1-D sequences        Each sequence should be of integer or boolean type.        Boolean sequences will be interpreted as boolean masks for the        corresponding dimension (equivalent to passing in        ``np.nonzero(boolean_sequence)``).sparse : bool, optional        Whether the grid is sparse or not. Default is False.Not a function, so takes no parametersarr : ndarray      Input array.`*args` : ints      The size of each dimension of the array.maketuple : bool        If True, always returns a tuple.","out : tuple of ndarrays        N arrays with N dimensions each, with N the number of input        sequences. Together these arrays form an open mesh.    Returns    ----------    mesh-grid `ndarrays` all of the same dimensionsmesh-grid        `ndarrays` with only one dimension not equal to 1A concatenated ndarray or matrix."
"_fill_diagonal_dispatcher(a, val, wrap=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,,,
"fill_diagonal(a, val, wrap=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py," Fill the main diagonal of the given array of any dimensionality.    For an array `a` with ``a.ndim >= 2``, the diagonal is the list of    locations with indices ``a[i, ..., i]`` all identical. This function    modifies the input array in-place, it does not return a value.","a : array, at least 2-D.      Array whose diagonal is to be filled, it gets modified in-place.",
"diag_indices(n, ndim=2):",https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,"     Return the indices to access the main diagonal of an array.    This returns a tuple of indices that can be used to access the main    diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for    ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``    for ``i = [0..n-1]``.","n : int      The size, along each dimension, of the arrays for which the returned      indices can be used.",
_diag_indices_from(arr):,https://github.com//numpy/numpy/blob/master/numpy/lib/index_tricks.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py,,,
_disables_array_ufunc(obj):,https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py," True when __array_ufunc__ is set to None. try: return obj.__array_ufunc__ is None except AttributeError: return False

",,
"_binary_method(ufunc, name):",https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py," Implement a forward binary method with a ufunc, e.g., __add__. def func(self, other): if _disables_array_ufunc(other): return NotImplemented return ufunc(self, other)    func.__name__ = '__{}__'.format(name) return func

",,
"_reflected_binary_method(ufunc, name):",https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py," Implement a reflected binary method with a ufunc, e.g., __radd__. def func(self, other): if _disables_array_ufunc(other): return NotImplemented return ufunc(other, self)    func.__name__ = '__r{}__'.format(name) return func

",,
"_inplace_binary_method(ufunc, name):",https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py," Implement an in-place binary method with a ufunc, e.g., __iadd__. def func(self, other): return ufunc(self, other, out=(self,))    func.__name__ = '__i{}__'.format(name) return func

",,
"_numeric_methods(ufunc, name):",https://github.com//numpy/numpy/blob/master/numpy/lib/mixins.py," Implement forward, reflected and inplace binary methods with a ufunc. return (_binary_method(ufunc, name),            _reflected_binary_method(ufunc, name),            _inplace_binary_method(ufunc, name))

",,
,https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"_nan_mask(a, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py, ,"a : array-like        Input array with at least 1 dimension.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``; if provided, it must have the same shape as the        expected output and will prevent the allocation of a new array.","y : bool ndarray or True        A bool array where ``np.nan`` positions are marked with ``False``        and other positions are marked with ``True``. If the type of ``a``        is such that it can't possibly contain ``np.nan``, returns ``True``. """""" # we assume that a is an array for this private function
 if a.dtype.kind not in 'fc': return True
    y = np.isnan(a, out=out)    y = np.invert(y, out=y) return y
"
"_replace_nan(a, val):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     If `a` is of inexact type, make a copy of `a`, replace NaNs with    the `val` value, and return the copy together with a boolean mask    marking the locations where NaNs were present. If `a` is not of    inexact type, do nothing and return `a` together with a mask of None.    Note that scalars will end up as array scalars, which is important    for using the result as the value of the out argument in some    operations.",a : array-like        Input array.    val : float        NaN values are set to val before doing the operation.,"y : ndarray        If `a` is of inexact type, return a copy of `a` with the NaNs        replaced by the fill value, otherwise return `a`.    mask: {bool, None}        If `a` is of inexact type, return a boolean mask marking locations of        NaNs, otherwise return None."
"_copyto(a, val, mask):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Replace values in `a` with NaN where `mask` is True.  This differs from    copyto in that it will deal with the case where `a` is a numpy scalar.,"a : ndarray or numpy scalar        Array or numpy scalar some of whose values are to be replaced        by val.    val : numpy scalar        Value used a replacement.    mask : ndarray, scalar        Boolean array. Where True the corresponding element of `a` is        replaced by `val`. Broadcasts.","res : ndarray, scalar        Array with elements replaced or scalar `val`."
"_remove_nan_1d(arr1d, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Equivalent to arr1d[~arr1d.isnan()], but in a different order    Presumably faster as it incurs fewer copies",arr1d : ndarray        Array to remove nans from    overwrite_input : bool        True if `arr1d` can be modified in place,"res : ndarray        Array with nan elements removed    overwrite_input : bool        True if `res` can be modified in place, given the constraint on the        input """"""
    c = np.isnan(arr1d)    s = np.nonzero(c)[0] if s.size == arr1d.size:        warnings.warn(""All-NaN slice encountered"", RuntimeWarning, stacklevel=5) return arr1d[:0], True elif s.size == 0: return arr1d, overwrite_input else: if not overwrite_input:            arr1d = arr1d.copy() # select non-nans at end of array        enonan = arr1d[-s.size:][~c[-s.size:]] # fill nans in beginning of array with non-nans of end        arr1d[s[:enonan.size]] = enonan
 return arr1d[:-s.size], True

"
"_divide_by_count(a, b, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute a/b ignoring invalid results. If `a` is an array the division    is done in place. If `a` is a scalar, then its type is preserved in the    output. If out is None, then then a is used instead so that the    division is in place. Note that this is only called with `a` an inexact    type.","a : {ndarray, numpy scalar}        Numerator. Expected to be of inexact type but not checked.    b : {ndarray, numpy scalar}        Denominator.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``; if provided, it must have the same shape as the        expected output, but the type will be cast if necessary.","ret : {ndarray, numpy scalar}        The return value is a/b. If `a` was an ndarray the division is done        in place. If `a` is a numpy scalar, the division preserves its type."
"_nanmin_dispatcher(a, axis=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanmin(a, axis=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Return minimum of an array or minimum along an axis, ignoring any NaNs.    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and    Nan is returned for that slice.","a : array_like        Array containing numbers whose minimum is desired. If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the minimum is computed. The default is to compute        the minimum of the flattened array.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``; if provided, it must have the same shape as the        expected output, but the type will be cast if necessary.  See        `doc.ufuncs` for details.","nanmin : ndarray        An array with the same shape as `a`, with the specified axis        removed.  If `a` is a 0-d array, or if axis is None, an ndarray        scalar is returned.  The same dtype as `a` is returned."
"_nanmax_dispatcher(a, axis=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanmax(a, axis=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Return the maximum of an array or maximum along an axis, ignoring any    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is    raised and NaN is returned for that slice.","a : array_like        Array containing numbers whose maximum is desired. If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the maximum is computed. The default is to compute        the maximum of the flattened array.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``; if provided, it must have the same shape as the        expected output, but the type will be cast if necessary.  See        `doc.ufuncs` for details.","nanmax : ndarray        An array with the same shape as `a`, with the specified axis removed.        If `a` is a 0-d array, or if axis is None, an ndarray scalar is        returned.  The same dtype as `a` is returned."
"_nanargmin_dispatcher(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanargmin(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the indices of the minimum values in the specified axis ignoring    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results    cannot be trusted if a slice contains only NaNs and Infs.,"a : array_like        Input data.    axis : int, optional        Axis along which to operate.  By default flattened input is used.",index_array : ndarray        An array of indices or a single index value.
"_nanargmax_dispatcher(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanargmax(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the indices of the maximum values in the specified axis ignoring    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the    results cannot be trusted if a slice contains only NaNs and -Infs.,"a : array_like        Input data.    axis : int, optional        Axis along which to operate.  By default flattened input is used.",index_array : ndarray        An array of indices or a single index value.
"_nansum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nansum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the sum of array elements over a given axis treating Not a    Numbers (NaNs) as zero.    In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or    empty. In later versions zero is returned.,"a : array_like        Array containing numbers whose sum is desired. If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the sum is computed. The default is to compute the        sum of the flattened array.    dtype : data-type, optional        The type of the returned array and of the accumulator in which the        elements are summed.  By default, the dtype of `a` is used.  An        exception is when `a` has an integer type with less precision than        the platform (u)intp. In that case, the default will be either        (u)int32 or (u)int64 depending on whether the platform is 32 or 64        bits. For inexact inputs, dtype must be inexact.","nansum : ndarray.        A new array holding the result is returned unless `out` is        specified, in which it is returned. The result has the same        size as `a`, and the same shape as `a` if `axis` is not None        or `a` is a 1-d array."
"_nanprod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanprod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the product of array elements over a given axis treating Not a    Numbers (NaNs) as ones.    One is returned for slices that are all-NaN or empty.    .. versionadded:: 1.10.0,"a : array_like        Array containing numbers whose product is desired. If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the product is computed. The default is to compute        the product of the flattened array.    dtype : data-type, optional        The type of the returned array and of the accumulator in which the        elements are summed.  By default, the dtype of `a` is used.  An        exception is when `a` has an integer type with less precision than        the platform (u)intp. In that case, the default will be either        (u)int32 or (u)int64 depending on whether the platform is 32 or 64        bits. For inexact inputs, dtype must be inexact.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``. If provided, it must have the same shape as the        expected output, but the type will be cast if necessary.  See        `doc.ufuncs` for details. The casting of NaN to integer can yield        unexpected results.    keepdims : bool, optional        If True, the axes which are reduced are left in the result as        dimensions with size one. With this option, the result will        broadcast correctly against the original `arr`.","nanprod : ndarray        A new array holding the result is returned unless `out` is        specified, in which case it is returned."
"_nancumsum_dispatcher(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nancumsum(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the cumulative sum of array elements over a given axis treating Not a    Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are    encountered and leading NaNs are replaced by zeros.    Zeros are returned for slices that are all-NaN or empty.    .. versionadded:: 1.12.0,"a : array_like        Input array.    axis : int, optional        Axis along which the cumulative sum is computed. The default        (None) is to compute the cumsum over the flattened array.    dtype : dtype, optional        Type of the returned array and of the accumulator in which the        elements are summed.  If `dtype` is not specified, it defaults        to the dtype of `a`, unless `a` has an integer dtype with a        precision less than that of the default platform integer.  In        that case, the default platform integer is used.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output        but the type will be cast if necessary. See `doc.ufuncs`        (Section ""Output arguments"") for more details.","nancumsum : ndarray.        A new array holding the result is returned unless `out` is        specified, in which it is returned. The result has the same        size as `a`, and the same shape as `a` if `axis` is not None        or `a` is a 1-d array."
"_nancumprod_dispatcher(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nancumprod(a, axis=None, dtype=None, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Return the cumulative product of array elements over a given axis treating Not a    Numbers (NaNs) as one.  The cumulative product does not change when NaNs are    encountered and leading NaNs are replaced by ones.    Ones are returned for slices that are all-NaN or empty.    .. versionadded:: 1.12.0,"a : array_like        Input array.    axis : int, optional        Axis along which the cumulative product is computed.  By default        the input is flattened.    dtype : dtype, optional        Type of the returned array, as well as of the accumulator in which        the elements are multiplied.  If *dtype* is not specified, it        defaults to the dtype of `a`, unless `a` has an integer dtype with        a precision less than that of the default platform integer.  In        that case, the default platform integer is used instead.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output        but the type of the resulting values will be cast if necessary.","nancumprod : ndarray        A new array holding the result is returned unless `out` is        specified, in which case it is returned."
"_nanmean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanmean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute the arithmetic mean along the specified axis, ignoring NaNs.    Returns the average of the array elements.  The average is taken over    the flattened array by default, otherwise over the specified axis.    `float64` intermediate and return values are used for integer inputs.    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.    .. versionadded:: 1.8.0","a : array_like        Array containing numbers whose mean is desired. If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the means are computed. The default is to compute        the mean of the flattened array.    dtype : data-type, optional        Type to use in computing the mean.  For integer inputs, the default        is `float64`; for inexact inputs, it is the same as the input        dtype.    out : ndarray, optional        Alternate output array in which to place the result.  The default        is ``None``; if provided, it must have the same shape as the        expected output, but the type will be cast if necessary.  See        `doc.ufuncs` for details.    keepdims : bool, optional        If this is set to True, the axes which are reduced are left        in the result as dimensions with size one. With this option,        the result will broadcast correctly against the original `a`.","m : ndarray, see dtype parameter above        If `out=None`, returns a new array containing the mean values,        otherwise a reference to the output array is returned. Nan is        returned for slices that contain only NaNs."
"_nanmedian1d(arr1d, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Private function for rank 1 arrays. Compute the median ignoring NaNs.    See nanmedian for parameter usage,,
"_nanmedian(a, axis=None, out=None, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Private function that doesn't support extended axis or keepdims.    These methods are extended to this function using _ureduce    See nanmedian for parameter usage,,
"_nanmedian_small(a, axis=None, out=None, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     sort + indexing median, faster for small medians along multiple    dimensions due to the high overhead of apply_along_axis    see nanmedian for parameter usage",,
_nanmedian_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute the median along the specified axis, while ignoring NaNs.    Returns the median of the array elements.    .. versionadded:: 1.9.0","a : array_like        Input array or object that can be converted to an array.    axis : {int, sequence of int, None}, optional        Axis or axes along which the medians are computed. The default        is to compute the median along a flattened version of the array.        A sequence of axes is supported since version 1.9.0.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output,        but the type (of the output) will be cast if necessary.    overwrite_input : bool, optional       If True, then allow use of memory of input array `a` for       calculations. The input array will be modified by the call to       `median`. This will save memory when you do not need to preserve       the contents of the input array. Treat the input as undefined,       but it will probably be fully or partially sorted. Default is       False. If `overwrite_input` is ``True`` and `a` is not already an       `ndarray`, an error will be raised.    keepdims : bool, optional        If this is set to True, the axes which are reduced are left        in the result as dimensions with size one. With this option,        the result will broadcast correctly against the original `a`.","median : ndarray        A new array holding the result. If the input contains integers        or floats smaller than ``float64``, then the output data-type is        ``np.float64``.  Otherwise, the data-type of the output is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_nanpercentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanpercentile(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute the qth percentile of the data along the specified axis,    while ignoring nan values.    Returns the qth percentile(s) of the array elements.    .. versionadded:: 1.9.0","a : array_like        Input array or object that can be converted to an array, containing        nan values to be ignored.    q : array_like of float        Percentile or sequence of percentiles to compute, which must be between        0 and 100 inclusive.    axis : {int, tuple of int, None}, optional        Axis or axes along which the percentiles are computed. The        default is to compute the percentile(s) along a flattened        version of the array.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output,        but the type (of the output) will be cast if necessary.    overwrite_input : bool, optional        If True, then allow the input array `a` to be modified by intermediate        calculations, to save memory. In this case, the contents of the input        `a` after this function completes is undefined.    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}        This optional parameter specifies the interpolation method to        use when the desired percentile lies between two data points        ``i < j``:","percentile : scalar or ndarray        If `q` is a single percentile and `axis=None`, then the result        is a scalar. If multiple percentiles are given, first axis of        the result corresponds to the percentiles. The other axes are        the axes that remain after the reduction of `a`. If the input        contains integers or floats smaller than ``float64``, the output        data-type is ``float64``. Otherwise, the output data-type is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_nanquantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanquantile(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute the qth quantile of the data along the specified axis,    while ignoring nan values.    Returns the qth quantile(s) of the array elements.     .. versionadded:: 1.15.0","a : array_like        Input array or object that can be converted to an array, containing        nan values to be ignored    q : array_like of float        Quantile or sequence of quantiles to compute, which must be between        0 and 1 inclusive.    axis : {int, tuple of int, None}, optional        Axis or axes along which the quantiles are computed. The        default is to compute the quantile(s) along a flattened        version of the array.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output,        but the type (of the output) will be cast if necessary.    overwrite_input : bool, optional        If True, then allow the input array `a` to be modified by intermediate        calculations, to save memory. In this case, the contents of the input        `a` after this function completes is undefined.    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}        This optional parameter specifies the interpolation method to        use when the desired quantile lies between two data points        ``i < j``:","quantile : scalar or ndarray        If `q` is a single percentile and `axis=None`, then the result        is a scalar. If multiple quantiles are given, first axis of        the result corresponds to the quantiles. The other axes are        the axes that remain after the reduction of `a`. If the input        contains integers or floats smaller than ``float64``, the output        data-type is ``float64``. Otherwise, the output data-type is the        same as that of the input. If `out` is specified, that array is        returned instead."
"_nanquantile_unchecked(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py," Assumes that q is in [0, 1], and is an ndarray # apply_along_axis in _nanpercentile doesn't handle empty arrays well, # so deal them upfront if a.size == 0: return np.nanmean(a, axis, out=out, keepdims=keepdims)
    r, k = function_base._ureduce(        a, func=_nanquantile_ureduce_func, q=q, axis=axis, out=out, overwrite_input=overwrite_input, interpolation=interpolation    ) if keepdims and keepdims is not np._NoValue: return r.reshape(q.shape + k) else: return r

",,
"_nanquantile_ureduce_func(a, q, axis=None, out=None, overwrite_input=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Private function that doesn't support extended axis or keepdims.    These methods are extended to this function using _ureduce    See nanpercentile for parameter usage,,
"_nanquantile_1d(arr1d, q, overwrite_input=False, interpolation='linear'):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,     Private function for rank 1 arrays. Compute quantile ignoring NaNs.    See nanpercentile for parameter usage,,
_nanvar_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
"nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,"     Compute the variance along the specified axis, while ignoring NaNs.    Returns the variance of the array elements, a measure of the spread of    a distribution.  The variance is computed for the flattened array by    default, otherwise over the specified axis.    For all-NaN slices or slices with zero degrees of freedom, NaN is    returned and a `RuntimeWarning` is raised.    .. versionadded:: 1.8.0","a : array_like        Array containing numbers whose variance is desired.  If `a` is not an        array, a conversion is attempted.    axis : {int, tuple of int, None}, optional        Axis or axes along which the variance is computed.  The default is to compute        the variance of the flattened array.    dtype : data-type, optional        Type to use in computing the variance.  For arrays of integer type        the default is `float32`; for arrays of float types it is the same as        the array type.    out : ndarray, optional        Alternate output array in which to place the result.  It must have        the same shape as the expected output, but the type is cast if        necessary.    ddof : int, optional        ""Delta Degrees of Freedom"": the divisor used in the calculation is        ``N - ddof``, where ``N`` represents the number of non-NaN        elements. By default `ddof` is zero.    keepdims : bool, optional        If this is set to True, the axes which are reduced are left        in the result as dimensions with size one. With this option,        the result will broadcast correctly against the original `a`.","variance : ndarray, see dtype parameter above        If `out` is None, return a new array containing the variance,        otherwise return a reference to the output array. If ddof is >= the        number of non-NaN elements in a slice or the slice contains only        NaNs, then the result for that slice is NaN."
_nanstd_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/nanfunctions.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
"loads(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,     BagObj(obj)    Convert attribute look-ups to getitems on the object passed in.,obj : class instance        Object on which attribute look-up is performed.,
"zipfile_factory(file, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Create a ZipFile.    Allows for Zip64, and the `file` argument can accept file, str, or    pathlib.Path objects. `args` and `kwargs` are passed to the zipfile.ZipFile    constructor.","fid : file or str        The zipped archive to open. This is either a file-like object        or a string containing the path to the archive.    own_fid : bool, optional        Whether NpzFile should close the file handle.        Requires that `fid` is a file-like object.",
"load(file, mmap_mode=None, allow_pickle=False, fix_imports=True,",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.    .. warning:: Loading files that contain object arrays uses the ``pickle``                 module, which is not secure against erroneous or maliciously                 constructed data. Consider passing ``allow_pickle=False`` to                 load data that is known not to contain object arrays for the                 safer handling of untrusted sources.","file : file-like object, string, or pathlib.Path        The file to read. File-like objects must support the        ``seek()`` and ``read()`` methods. Pickled files require that the        file-like object support the ``readline()`` method as well.    mmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional        If not None, then memory-map the file, using the given mode (see        `numpy.memmap` for a detailed description of the modes).  A        memory-mapped array is kept on disk. However, it can be accessed        and sliced like any ndarray.  Memory mapping is especially useful        for accessing small fragments of large files without reading the        entire file into memory.    allow_pickle : bool, optional        Allow loading pickled object arrays stored in npy files. Reasons for        disallowing pickles include security, as loading pickled data can        execute arbitrary code. If pickles are disallowed, loading object        arrays will fail. Default: False","result : array, tuple, dict, etc.        Data stored in the file. For ``.npz`` files, the returned instance        of NpzFile class must be closed to avoid leaking file descriptors."
"_save_dispatcher(file, arr, allow_pickle=None, fix_imports=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
"save(file, arr, allow_pickle=True, fix_imports=True):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,     Save an array to a binary file in NumPy ``.npy`` format.,"file : file, str, or pathlib.Path        File or filename to which the data is saved.  If file is a file-object,        then the filename is unchanged.  If file is a string or Path, a ``.npy``        extension will be appended to the file name if it does not already        have one.    arr : array_like        Array data to be saved.    allow_pickle : bool, optional        Allow saving object arrays using Python pickles. Reasons for disallowing        pickles include security (loading pickled data can execute arbitrary        code) and portability (pickled objects may not be loadable on different        Python installations, for example if the stored objects require libraries        that are not available, and not all pickled data is compatible between        Python 2 and Python 3).        Default: True    fix_imports : bool, optional        Only useful in forcing objects in object arrays on Python 3 to be        pickled in a Python 2 compatible way. If `fix_imports` is True, pickle        will try to map the new Python 3 names to the old module names used in        Python 2, so that the pickle data stream is readable with Python 2.",
"_savez_dispatcher(file, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
"savez(file, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Save several arrays into a single file in uncompressed ``.npz`` format.    If arguments are passed in with no keywords, the corresponding variable    names, in the ``.npz`` file, are 'arr_0', 'arr_1', etc. If keyword    arguments are given, the corresponding variable names, in the ``.npz``    file will match the keyword names.","file : str or file        Either the file name (string) or an open file (file-like object)        where the data will be saved. If file is a string or a Path, the        ``.npz`` extension will be appended to the file name if it is not        already there.    args : Arguments, optional        Arrays to save to the file. Since it is not possible for Python to        know the names of the arrays outside `savez`, the arrays will be saved        with names ""arr_0"", ""arr_1"", and so on. These arguments can be any        expression.    kwds : Keyword arguments, optional        Arrays to save to the file. Arrays will be saved in the file with the        keyword names.",None
"_savez_compressed_dispatcher(file, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
"savez_compressed(file, *args, **kwds):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Save several arrays into a single file in compressed ``.npz`` format.    If keyword arguments are given, then filenames are taken from the keywords.    If arguments are passed in with no keywords, then stored file names are    arr_0, arr_1, etc.","file : str or file        Either the file name (string) or an open file (file-like object)        where the data will be saved. If file is a string or a Path, the        ``.npz`` extension will be appended to the file name if it is not        already there.    args : Arguments, optional        Arrays to save to the file. Since it is not possible for Python to        know the names of the arrays outside `savez`, the arrays will be saved        with names ""arr_0"", ""arr_1"", and so on. These arguments can be any        expression.    kwds : Keyword arguments, optional        Arrays to save to the file. Arrays will be saved in the file with the        keyword names.",None
"_savez(file, args, kwds, compress, allow_pickle=True, pickle_kwargs=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
_getconv(dtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"  Find the correct dtype converter. Adapted from matplotlib 
 def floatconv(x):        x.lower() if '0x' in x: return float.fromhex(x) return float(x)
    typ = dtype.type if issubclass(typ, np.bool_): return lambda x: bool(int(x)) if issubclass(typ, np.uint64): return np.uint64 if issubclass(typ, np.int64): return np.int64 if issubclass(typ, np.integer): return lambda x: int(float(x)) elif issubclass(typ, np.longdouble): return np.longdouble elif issubclass(typ, np.floating): return floatconv elif issubclass(typ, complex): return lambda x: complex(asstr(x).replace('+-', '-')) elif issubclass(typ, np.bytes_): return asbytes elif issubclass(typ, np.unicode_): return asunicode else: return asstr
# amount of lines loadtxt reads in one chunk, can be overridden for testing_loadtxt_chunksize = 50000

@set_module('numpy')",,
"loadtxt(fname, dtype=float, comments='#', delimiter=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,     Load data from a text file.    Each row in the text file must have the same number of values.,"fname : file, str, or pathlib.Path        File, filename, or generator to read.  If the filename extension is        ``.gz`` or ``.bz2``, the file is first decompressed. Note that        generators should return byte strings for Python 3k.    dtype : data-type, optional        Data-type of the resulting array; default: float.  If this is a        structured data-type, the resulting array will be 1-dimensional, and        each row will be interpreted as an element of the array.  In this        case, the number of columns used must match the number of fields in        the data-type.    comments : str or sequence of str, optional        The characters or list of characters used to indicate the start of a        comment. None implies no comments. For backwards compatibility, byte        strings will be decoded as 'latin1'. The default is '#'.    delimiter : str, optional        The string used to separate values. For backwards compatibility, byte        strings will be decoded as 'latin1'. The default is whitespace.    converters : dict, optional        A dictionary mapping column number to a function that will parse the        column string into the desired value.  E.g., if column 0 is a date        string: ``converters = {0: datestr2num}``.  Converters can also be        used to provide a default value for missing data (but see also        `genfromtxt`): ``converters = {3: lambda s: float(s.strip() or 0)}``.        Default: None.    skiprows : int, optional        Skip the first `skiprows` lines, including comments; default: 0.    usecols : int or sequence, optional        Which columns to read, with 0 being the first. For example,        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.        The default, None, results in all columns being read.",out : ndarray        Data read from the text file.
"_savetxt_dispatcher(fname, X, fmt=None, delimiter=None, newline=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,,,
"savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='',",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,     Save an array to a text file.,"fname : filename or file handle        If the filename ends in ``.gz``, the file is automatically saved in        compressed gzip format.  `loadtxt` understands gzipped files        transparently.    X : 1D or 2D array_like        Data to be saved to a text file.    fmt : str or sequence of strs, optional        A single format (%10.5f), a sequence of formats, or a        multi-format string, e.g. 'Iteration %d -- %10.5f', in which        case `delimiter` is ignored. For complex `X`, the legal options        for `fmt` are:",
"fromregex(file, regexp, dtype, encoding=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Construct an array from a text file, using regular expression parsing.    The returned array is always a structured array, and is constructed from    all matches of the regular expression in the file. Groups in the regular    expression are converted to fields of the structured array.","file : str or file        File name or file object to read.    regexp : str or regexp        Regular expression used to parse the file.        Groups in the regular expression correspond to fields in the dtype.    dtype : dtype or list of dtypes        Dtype for the structured array.    encoding : str, optional        Encoding used to decode the inputfile. Does not apply to input streams.","output : ndarray        The output array, containing the part of the content of `file` that        was matched by `regexp`. `output` is always a structured array."
"genfromtxt(fname, dtype=float, comments='#', delimiter=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Load data from a text file, with missing values handled as specified.    Each line past the first `skip_header` lines is split at the `delimiter`    character, and characters following the `comments` character are discarded.","fname : file, str, pathlib.Path, list of str, generator        File, filename, list, or generator to read.  If the filename        extension is `.gz` or `.bz2`, the file is first decompressed. Note        that generators must return byte strings in Python 3k.  The strings        in a list or produced by a generator are treated as lines.    dtype : dtype, optional        Data type of the resulting array.        If None, the dtypes will be determined by the contents of each        column, individually.    comments : str, optional        The character used to indicate the start of a comment.        All the characters occurring on a line after a comment are discarded    delimiter : str, int, or sequence, optional        The string used to separate values.  By default, any consecutive        whitespaces act as delimiter.  An integer or sequence of integers        can also be provided as width(s) of each field.    skiprows : int, optional        `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.    skip_header : int, optional        The number of lines to skip at the beginning of the file.    skip_footer : int, optional        The number of lines to skip at the end of the file.    converters : variable, optional        The set of functions that convert the data of a column to a value.        The converters can also be used to provide a default value        for missing data: ``converters = {3: lambda s: float(s or 0)}``.    missing : variable, optional        `missing` was removed in numpy 1.10. Please use `missing_values`        instead.    missing_values : variable, optional        The set of strings corresponding to missing data.    filling_values : variable, optional        The set of values to be used as default when the data are missing.    usecols : sequence, optional        Which columns to read, with 0 being the first.  For example,        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.    names : {None, True, str, sequence}, optional        If `names` is True, the field names are read from the first line after        the first `skip_header` lines.  This line can optionally be proceeded        by a comment delimiter. If `names` is a sequence or a single-string of        comma-separated names, the names will be used to define the field names        in a structured dtype. If `names` is None, the names of the dtype        fields will be used, if any.    excludelist : sequence, optional        A list of names to exclude. This list is appended to the default list        ['return','file','print']. Excluded names are appended an underscore:        for example, `file` would become `file_`.    deletechars : str, optional        A string combining invalid characters that must be deleted from the        names.    defaultfmt : str, optional        A format used to define default field names, such as ""f%i"" or ""f_%02i"".    autostrip : bool, optional        Whether to automatically strip white spaces from the variables.    replace_space : char, optional        Character(s) used in replacement of white spaces in the variables        names. By default, use a '_'.    case_sensitive : {True, False, 'upper', 'lower'}, optional        If True, field names are case sensitive.        If False or 'upper', field names are converted to upper case.        If 'lower', field names are converted to lower case.    unpack : bool, optional        If True, the returned array is transposed, so that arguments may be        unpacked using ``x, y, z = loadtxt(...)``    usemask : bool, optional        If True, return a masked array.        If False, return a regular array.    loose : bool, optional        If True, do not raise errors for invalid values.    invalid_raise : bool, optional        If True, an exception is raised if an inconsistency is detected in the        number of columns.        If False, a warning is emitted and the offending lines are skipped.    max_rows : int,  optional        The maximum number of rows to read. Must not be used with skip_footer        at the same time.  If given, the value must be at least 1. Default is        to read the entire file.","out : ndarray        Data read from the text file. If `usemask` is True, this is a        masked array."
"ndfromtxt(fname, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Load ASCII data stored in a file and return it as a single array.    .. deprecated:: 1.17        ndfromtxt` is a deprecated alias of `genfromtxt` which        overwrites the ``usemask`` argument with `False` even when        explicitly called as ``ndfromtxt(..., usemask=True)``.        Use `genfromtxt` instead.","fname, kwargs : For a description of input parameters, see `genfromtxt`.",
"mafromtxt(fname, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Load ASCII data stored in a text file and return a masked array.    .. deprecated:: 1.17        np.mafromtxt is a deprecated alias of `genfromtxt` which        overwrites the ``usemask`` argument with `True` even when        explicitly called as ``mafromtxt(..., usemask=False)``.        Use `genfromtxt` instead.","fname, kwargs : For a description of input parameters, see `genfromtxt`.",
"recfromtxt(fname, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/npyio.py,"     Load ASCII data from a file and return it in a record array.    If ``usemask=False`` a standard `recarray` is returned,    if ``usemask=True`` a MaskedRecords array is returned.","fname, kwargs : For a description of input parameters, see `genfromtxt`.",
,https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
_poly_dispatcher(seq_of_zeros):,https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
poly(seq_of_zeros):,https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Find the coefficients of a polynomial with the given sequence of roots.    Returns the coefficients of the polynomial whose leading coefficient    is one for the given sequence of zeros (multiple roots must be included    in the sequence as many times as their multiplicity; see Examples).    A square matrix (or array, which will be treated as a matrix) can also    be given, in which case the coefficients of the characteristic polynomial    of the matrix are returned.","seq_of_zeros : array_like, shape (N,) or (N, N)        A sequence of polynomial roots, or a square array or matrix object.",c : ndarray        1D array of polynomial coefficients from highest to lowest degree:
_roots_dispatcher(p):,https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
roots(p):,https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,     Return the roots of a polynomial with coefficients given in p.    The values in the rank-1 array `p` are coefficients of a polynomial.    If the length of `p` is n+1 then the polynomial is described by::      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n],p : array_like        Rank-1 array of polynomial coefficients.,out : ndarray        An array containing the roots of the polynomial.
"_polyint_dispatcher(p, m=None, k=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polyint(p, m=1, k=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,     Return an antiderivative (indefinite integral) of a polynomial.    The returned order `m` antiderivative `P` of polynomial `p` satisfies    :math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`    integration constants `k`. The constants determine the low-order    polynomial part    .. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1}    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.,"p : array_like or poly1d        Polynomial to integrate.        A sequence is interpreted as polynomial coefficients, see `poly1d`.    m : int, optional        Order of the antiderivative. (Default: 1)    k : list of `m` scalars or scalar, optional        Integration constants. They are given in the order of integration:        those corresponding to highest-order terms come first.",
"_polyder_dispatcher(p, m=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polyder(p, m=1):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,     Return the derivative of the specified order of a polynomial.,"p : poly1d or sequence        Polynomial to differentiate.        A sequence is interpreted as polynomial coefficients, see `poly1d`.    m : int, optional        Order of differentiation (default: 1)",der : poly1d        A new polynomial representing the derivative.
"_polyfit_dispatcher(x, y, deg, rcond=None, full=None, w=None, cov=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Least squares polynomial fit.    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`    to points `(x, y)`. Returns a vector of coefficients `p` that minimises    the squared error in the order `deg`, `deg-1`, ... `0`.    The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class    method is recommended for new code as it is more stable numerically. See    the documentation of the method for more information.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int        Degree of the fitting polynomial    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (M,), optional        Weights to apply to the y-coordinates of the sample points. For        gaussian uncertainties, use 1/sigma (not 1/sigma**2).    cov : bool or str, optional        If given and not `False`, return not just the estimate but also its        covariance matrix. By default, the covariance are scaled by        chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable        except in a relative sense and everything is scaled such that the        reduced chi2 is unity. This scaling is omitted if ``cov='unscaled'``,        as is relevant for the case that the weights are 1/sigma**2, with        sigma known to be a reliable estimate of the uncertainty.","p : ndarray, shape (deg + 1,) or (deg + 1, K)        Polynomial coefficients, highest power first.  If `y` was 2-D, the        coefficients for `k`-th data set are in ``p[:,k]``."
"_polyval_dispatcher(p, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polyval(p, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Evaluate a polynomial at specific values.    If `p` is of length N, this function returns the value:        ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``    If `x` is a sequence, then `p(x)` is returned for each element of `x`.    If `x` is another polynomial then the composite polynomial `p(x(t))`    is returned.","p : array_like or poly1d object       1D array of polynomial coefficients (including coefficients equal       to zero) from highest degree to the constant term, or an       instance of poly1d.    x : array_like or poly1d object       A number, an array of numbers, or an instance of poly1d, at       which to evaluate `p`.","values : ndarray or poly1d       If `x` is a poly1d instance, the result is the composition of the two       polynomials, i.e., `x` is ""substituted"" in `p` and the simplified       result is returned. In addition, the type of `x` - array_like or       poly1d - governs the type of the output: `x` array_like => `values`       array_like, `x` a poly1d object => `values` is also."
"_binary_op_dispatcher(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polyadd(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Find the sum of two polynomials.    Returns the polynomial resulting from the sum of two input polynomials.    Each input must be either a poly1d object or a 1D sequence of polynomial    coefficients, from highest to lowest degree.","a1, a2 : array_like or poly1d object        Input polynomials.","out : ndarray or poly1d object        The sum of the inputs. If either input is a poly1d object, then the        output is also a poly1d object. Otherwise, it is a 1D array of        polynomial coefficients from highest to lowest degree."
"polysub(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Difference (subtraction) of two polynomials.    Given two polynomials `a1` and `a2`, returns ``a1 - a2``.    `a1` and `a2` can be either array_like sequences of the polynomials'    coefficients (including coefficients equal to zero), or `poly1d` objects.","a1, a2 : array_like or poly1d        Minuend and subtrahend polynomials, respectively.",out : ndarray or poly1d        Array or `poly1d` object of the difference polynomial's coefficients.
"polymul(a1, a2):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Find the product of two polynomials.    Finds the polynomial resulting from the multiplication of the two input    polynomials. Each input must be either a poly1d object or a 1D sequence    of polynomial coefficients, from highest to lowest degree.","a1, a2 : array_like or poly1d object        Input polynomials.","out : ndarray or poly1d object        The polynomial resulting from the multiplication of the inputs. If        either inputs is a poly1d object, then the output is also a poly1d        object. Otherwise, it is a 1D array of polynomial coefficients from        highest to lowest degree."
"_polydiv_dispatcher(u, v):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,,,
"polydiv(u, v):",https://github.com//numpy/numpy/blob/master/numpy/lib/polynomial.py,"     Returns the quotient and remainder of polynomial division.    The input arrays are the coefficients (including any coefficients    equal to zero) of the ""numerator"" (dividend) and ""denominator""    (divisor) polynomials, respectively.",u : array_like or poly1d        Dividend polynomial's coefficients.,"q : ndarray        Coefficients, including those equal to zero, of the quotient.    r : ndarray        Coefficients, including those equal to zero, of the remainder."
,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"_recursive_fill_fields_dispatcher(input, output):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"recursive_fill_fields(input, output):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Fills fields from output with fields from input,    with support for nested structures.",input : ndarray        Input array.    output : ndarray        Output array.,
get_fieldspec(dtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Produce a list of name/dtype pairs corresponding to the dtype fields    Similar to dtype.descr, but the second item of each tuple is a dtype, not a    string. As a result, this handles subarray dtypes    Can be passed to the dtype constructor to reconstruct the dtype, noting that    this (deliberately) discards field offsets.    Examples    -------- >>> dt = np.dtype([(('a', 'A'), np.int64), ('b', np.double, 3)]) >>> dt.descr    [(('a', 'A'), '<i8'), ('b', '<f8', (3,))] >>> get_fieldspec(dt)    [(('a', 'A'), dtype('int64')), ('b', dtype(('<f8', (3,))))]",,
get_names(adtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns the field names of the input datatype as a tuple.,adtype : dtype        Input datatype,
get_names_flat(adtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns the field names of the input datatype as a tuple. Nested structure    are flattened beforehand.,adtype : dtype        Input datatype,
flatten_descr(ndtype):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Flatten a structured data-type description.    Examples    -------- >>> from numpy.lib import recfunctions as rfn >>> ndtype = np.dtype([('a', '<i4'), ('b', [('ba', '<f8'), ('bb', '<i4')])]) >>> rfn.flatten_descr(ndtype)    (('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))",,
"_zip_dtype_dispatcher(seqarrays, flatten=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"zip_dtype(seqarrays, flatten=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"zip_descr(seqarrays, flatten=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Combine the dtype description of a series of arrays.,"seqarrays : sequence of arrays        Sequence of arrays    flatten : {boolean}, optional        Whether to collapse nested descriptions. """""" return zip_dtype(seqarrays, flatten=flatten).descr

",
"get_fieldstructure(adtype, lastname=None, parents=None,):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns a dictionary with fields indexing lists of their parent fields.    This function is used to simplify access to fields nested in other fields.,adtype : np.dtype        Input datatype    lastname : optional        Last processed field name (used internally during recursion).    parents : dictionary        Dictionary of parent fields (used interbally during recursion).,
_izip_fields_flat(iterable):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Returns an iterator of concatenated fields from a sequence of arrays,    collapsing any nested structure.",,
_izip_fields(iterable):,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns an iterator of concatenated fields from a sequence of arrays.,,
"_izip_records_dispatcher(seqarrays, fill_value=None, flatten=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"izip_records(seqarrays, fill_value=None, flatten=True):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns an iterator of concatenated items from a sequence of arrays.,"seqarrays : sequence of arrays        Sequence of arrays.    fill_value : {None, integer}        Value used to pad shorter iterables.    flatten : {True, False},        Whether to """"""
 # Should we flatten the items, or just use a nested approach if flatten:        zipfunc = _izip_fields_flat else:        zipfunc = _izip_fields
 if sys.version_info[0] >= 3:        zip_longest = itertools.zip_longest else:        zip_longest = itertools.izip_longest
 for tup in zip_longest(*seqarrays, fillvalue=fill_value): yield tuple(zipfunc(tup))

",
"_fix_output(output, usemask=True, asrecarray=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Private function: return a recarray, a ndarray, a MaskedArray    or a MaskedRecords depending on the input parameters",,
"_fix_defaults(output, defaults=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Update the fill_value and masked data of `output`    from the default given in a dictionary defaults.,,
"_merge_arrays_dispatcher(seqarrays, fill_value=None, flatten=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"merge_arrays(seqarrays, fill_value=-1, flatten=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Merge arrays field by field.,"seqarrays : sequence of ndarrays        Sequence of arrays    fill_value : {float}, optional        Filling value used to pad missing data on the shorter arrays.    flatten : {False, True}, optional        Whether to collapse nested fields.    usemask : {False, True}, optional        Whether to return a masked array or not.    asrecarray : {False, True}, optional        Whether to return a recarray (MaskedRecords) or not.",
"_drop_fields_dispatcher(base, drop_names, usemask=None, asrecarray=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"drop_fields(base, drop_names, usemask=True, asrecarray=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Return a new array with fields in `drop_names` dropped.    Nested fields are supported.,"base : array        Input array    drop_names : string or sequence        String or sequence of strings corresponding to the names of the        fields to drop.    usemask : {False, True}, optional        Whether to return a masked array or not.    asrecarray : string or sequence, optional        Whether to return a recarray or a mrecarray (`asrecarray=True`) or        a plain ndarray or masked array with flexible dtype. The default        is False.",
"_keep_fields(base, keep_names, usemask=True, asrecarray=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Return a new array keeping only the fields in `keep_names`,    and preserving the order of those fields.","base : array        Input array    keep_names : string or sequence        String or sequence of strings corresponding to the names of the        fields to keep. Order of the names will be preserved.    usemask : {False, True}, optional        Whether to return a masked array or not.    asrecarray : string or sequence, optional        Whether to return a recarray or a mrecarray (`asrecarray=True`) or        a plain ndarray or masked array with flexible dtype. The default        is False. """"""    newdtype = [(n, base.dtype[n]) for n in keep_names]    output = np.empty(base.shape, dtype=newdtype)    output = recursive_fill_fields(base, output) return _fix_output(output, usemask=usemask, asrecarray=asrecarray)

",
"_rec_drop_fields_dispatcher(base, drop_names):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"rec_drop_fields(base, drop_names):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Returns a new numpy.recarray with fields in `drop_names` dropped.,,
"_rename_fields_dispatcher(base, namemapper):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"rename_fields(base, namemapper):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Rename the fields from a flexible-datatype ndarray or recarray.    Nested fields are supported.,base : ndarray        Input array whose fields must be modified.    namemapper : dictionary        Dictionary mapping old field names to their new version.,
"_append_fields_dispatcher(base, names, data, dtypes=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"append_fields(base, names, data, dtypes=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Add new fields to an existing array.    The names of the fields are given with the `names` arguments,    the corresponding values with the `data` arguments.    If a single field is appended, `names`, `data` and `dtypes` do not have    to be lists but just values.","base : array        Input array to extend.    names : string, sequence        String or sequence of strings corresponding to the names        of the new fields.    data : array or sequence of arrays        Array or sequence of arrays storing the fields to add to the base.    dtypes : sequence of datatypes, optional        Datatype or sequence of datatypes.        If None, the datatypes are estimated from the `data`.    fill_value : {float}, optional        Filling value used to pad missing data on the shorter arrays.    usemask : {False, True}, optional        Whether to return a masked array or not.    asrecarray : {False, True}, optional        Whether to return a recarray (MaskedRecords) or not.",
"_rec_append_fields_dispatcher(base, names, data, dtypes=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"rec_append_fields(base, names, data, dtypes=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Add new fields to an existing array.    The names of the fields are given with the `names` arguments,    the corresponding values with the `data` arguments.    If a single field is appended, `names`, `data` and `dtypes` do not have    to be lists but just values.","base : array        Input array to extend.    names : string, sequence        String or sequence of strings corresponding to the names        of the new fields.    data : array or sequence of arrays        Array or sequence of arrays storing the fields to add to the base.    dtypes : sequence of datatypes, optional        Datatype or sequence of datatypes.        If None, the datatypes are estimated from the `data`.","appended_array : np.recarray """""" return append_fields(base, names, data=data, dtypes=dtypes, asrecarray=True, usemask=False)

"
"_repack_fields_dispatcher(a, align=None, recurse=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"repack_fields(a, align=False, recurse=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Re-pack the fields of a structured array or dtype in memory.    The memory layout of structured datatypes allows fields at arbitrary    byte offsets. This means the fields can be separated by padding bytes,    their offsets can be non-monotonically increasing, and they can overlap.    This method removes any overlaps and reorders the fields in memory so they    have increasing byte offsets, and adds or removes padding bytes depending    on the `align` option, which behaves like the `align` option to `np.dtype`.    If `align=False`, this method produces a ""packed"" memory layout in which    each field starts at the byte the previous field ended, and any padding    bytes are removed.    If `align=True`, this methods produces an ""aligned"" memory layout in which    each field's offset is a multiple of its alignment, and the total itemsize    is a multiple of the largest alignment, by adding padding bytes as needed.","a : ndarray or dtype       array or dtype for which to repack the fields.    align : boolean       If true, use an ""aligned"" memory layout, otherwise use a ""packed"" layout.    recurse : boolean       If True, also repack nested structures.","repacked : ndarray or dtype       Copy of `a` with fields repacked, or `a` itself if no repacking was       needed."
"_get_fields_and_offsets(dt, offset=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Returns a flat list of (dtype, count, offset) tuples of all the    scalar fields in the dtype ""dt"", including nested fields, in left    to right order.",,
"_structured_to_unstructured_dispatcher(arr, dtype=None, copy=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"structured_to_unstructured(arr, dtype=None, copy=False, casting='unsafe'):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Converts and n-D structured array into an (n+1)-D unstructured array.    The new array will have a new last dimension equal in size to the    number of field-elements of the input array. If not supplied, the output    datatype is determined from the numpy type promotion rules applied to all    the field datatypes.    Nested fields, as well as each element of any subarray fields, all count    as a single field-elements.","arr : ndarray       Structured array or dtype to convert. Cannot contain object datatype.    dtype : dtype, optional       The dtype of the output unstructured array.    copy : bool, optional        See copy argument to `ndarray.astype`. If true, always return a copy.        If false, and `dtype` requirements are satisfied, a view is returned.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        See casting argument of `ndarray.astype`. Controls what kind of data        casting may occur.",unstructured : ndarray       Unstructured array with one more dimension.
"_unstructured_to_structured_dispatcher(arr, dtype=None, names=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"unstructured_to_structured(arr, dtype=None, names=None, align=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Converts and n-D unstructured array into an (n-1)-D structured array.    The last dimension of the input array is converted into a structure, with    number of field-elements equal to the size of the last dimension of the    input array. By default all output fields have the input array's dtype, but    an output structured dtype with an equal number of fields-elements can be    supplied instead.    Nested fields, as well as each element of any subarray fields, all count    towards the number of field-elements.","arr : ndarray       Unstructured array or dtype to convert.    dtype : dtype, optional       The structured dtype of the output array    names : list of strings, optional       If dtype is not supplied, this specifies the field names for the output       dtype, in order. The field dtypes will be the same as the input array.    align : boolean, optional       Whether to create an aligned memory layout.    copy : bool, optional        See copy argument to `ndarray.astype`. If true, always return a copy.        If false, and `dtype` requirements are satisfied, a view is returned.    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional        See casting argument of `ndarray.astype`. Controls what kind of data        casting may occur.",structured : ndarray       Structured array with fewer dimensions.
"_apply_along_fields_dispatcher(func, arr):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"apply_along_fields(func, arr):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Apply function 'func' as a reduction across fields of a structured array.    This is similar to `apply_along_axis`, but treats the fields of a    structured array as an extra axis. The fields are all first cast to a    common type following the type-promotion rules from `numpy.result_type`    applied to the field's dtypes.","func : function       Function to apply on the ""field"" dimension. This function must       support an `axis` argument, like np.mean, np.sum, etc.    arr : ndarray       Structured array for which to apply func.",out : ndarray       Result of the recution operation
"_assign_fields_by_name_dispatcher(dst, src, zero_unassigned=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"assign_fields_by_name(dst, src, zero_unassigned=True):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Assigns values from one structured array to another by field name.    Normally in numpy >= 1.14, assignment of one structured array to another    copies fields ""by position"", meaning that the first field from the src is    copied to the first field of the dst, and so on, regardless of field name.    This function instead copies ""by field name"", such that fields in the dst    are assigned from the identically named field in the src. This applies    recursively for nested structures. This is how structure assignment worked    in numpy >= 1.6 to <= 1.13.","dst : ndarray    src : ndarray        The source and destination arrays during assignment.    zero_unassigned : bool, optional        If True, fields in the dst for which there was no matching        field in the src are filled with the value 0 (zero). This        was the behavior of numpy <= 1.13. If False, those fields        are not modified. """"""
 if dst.dtype.names is None:        dst[...] = src return
 for name in dst.dtype.names: if name not in src.dtype.names: if zero_unassigned:                dst[name] = 0 else:            assign_fields_by_name(dst[name], src[name],                                  zero_unassigned)
",
"_require_fields_dispatcher(array, required_dtype):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"require_fields(array, required_dtype):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,"     Casts a structured array to a new dtype using assignment by field-name.    This function assigns from the old to the new array by name, so the    value of a field in the output array is the value of the field with the    same name in the source array. This has the effect of creating a new    ndarray containing only the fields ""required"" by the required_dtype.    If a field name in the required_dtype does not exist in the    input array, that field is created and set to 0 in the output array.",a : ndarray       array to cast    required_dtype : dtype       datatype for output array,"out : ndarray        array with the new dtype, with field values copied from the fields in        the input array with the same name"
"_stack_arrays_dispatcher(arrays, defaults=None, usemask=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"stack_arrays(arrays, defaults=None, usemask=True, asrecarray=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Superposes arrays fields by fields,"arrays : array or sequence        Sequence of input arrays.    defaults : dictionary, optional        Dictionary mapping field names to the corresponding default values.    usemask : {True, False}, optional        Whether to return a MaskedArray (or MaskedRecords is        `asrecarray==True`) or a ndarray.    asrecarray : {False, True}, optional        Whether to return a recarray (or MaskedRecords if `usemask==True`)        or just a flexible-type ndarray.    autoconvert : {False, True}, optional        Whether automatically cast the type of the field to the maximum.",
_find_duplicates_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"find_duplicates(a, key=None, ignoremask=True, return_index=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Find the duplicates in a structured array along a given key,"a : array-like        Input array    key : {string, None}, optional        Name of the fields along which to check the duplicates.        If None, the search is performed by records    ignoremask : {True, False}, optional        Whether masked data should be discarded or considered as duplicates.    return_index : {False, True}, optional        Whether to return the indices of the duplicated values.",
_join_by_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
"join_by(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2',",https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,     Join arrays `r1` and `r2` on key `key`.    The key should be either a string or a sequence of string corresponding    to the fields used to join the array.  An exception is raised if the    `key` field cannot be found in the two input arrays.  Neither `r1` nor    `r2` should have any duplicates along `key`: the presence of duplicates    will make the output quite unreliable. Note that duplicates are not    looked for by the algorithm.,"key : {string, sequence}        A string or a sequence of strings corresponding to the fields used        for comparison.    r1, r2 : arrays        Structured arrays.    jointype : {'inner', 'outer', 'leftouter'}, optional        If 'inner', returns the elements common to both r1 and r2.        If 'outer', returns the common elements as well as the elements of        r1 not in r2 and the elements of not in r2.        If 'leftouter', returns the common elements and the elements of r1        not in r2.    r1postfix : string, optional        String appended to the names of the fields of r1 that are present        in r2 but absent of the key.    r2postfix : string, optional        String appended to the names of the fields of r2 that are present        in r1 but absent of the key.    defaults : {dictionary}, optional        Dictionary mapping field names to the corresponding default values.    usemask : {True, False}, optional        Whether to return a MaskedArray (or MaskedRecords is        `asrecarray==True`) or a ndarray.    asrecarray : {False, True}, optional        Whether to return a recarray (or MaskedRecords if `usemask==True`)        or just a flexible-type ndarray.",
_rec_join_dispatcher(,https://github.com//numpy/numpy/blob/master/numpy/lib/recfunctions.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,,,
_tocomplex(arr):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py," Convert its input `arr` to a complex array.    The input is returned as a complex array of the smallest type that will fit    the original data: types like single, byte, short, etc. become csingle,    while others become cdouble.    A copy of the input is always made.",arr : array,array        An array with the same input data as the input but in complex form.
_fix_real_lt_zero(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py," Convert `x` to complex if it has real, negative components.    Otherwise, output is just the array version of the input (via asarray).",x : array_like,array
_fix_int_lt_zero(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py," Convert `x` to double if it has real, negative components.    Otherwise, output is just the array version of the input (via asarray).",x : array_like,array
_fix_real_abs_gt_1(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py," Convert `x` to complex if it has real components x_i with abs(x_i)>1.    Otherwise, output is just the array version of the input (via asarray).",x : array_like,array
_unary_dispatcher(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,,,
sqrt(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the square root of x.    For negative input elements, a complex value is returned    (unlike `numpy.sqrt` which returns NaN).",x : array_like       The input value(s).,"out : ndarray or scalar       The square root of `x`. If `x` was a scalar, so is `out`,       otherwise an array is returned."
log(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the natural logarithm of `x`.    Return the ""principal value"" (for a description of this, see `numpy.log`)    of :math:`log_e(x)`. For real `x > 0`, this is a real number (``log(0)``    returns ``-inf`` and ``log(np.inf)`` returns ``inf``). Otherwise, the    complex principle value is returned.",x : array_like       The value(s) whose log is (are) required.,"out : ndarray or scalar       The log of the `x` value(s). If `x` was a scalar, so is `out`,       otherwise an array is returned."
log10(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the logarithm base 10 of `x`.    Return the ""principal value"" (for a description of this, see    `numpy.log10`) of :math:`log_{10}(x)`. For real `x > 0`, this    is a real number (``log10(0)`` returns ``-inf`` and ``log10(np.inf)``    returns ``inf``). Otherwise, the complex principle value is returned.",x : array_like or scalar       The value(s) whose log base 10 is (are) required.,"out : ndarray or scalar       The log base 10 of the `x` value(s). If `x` was a scalar, so is `out`,       otherwise an array object is returned."
"_logn_dispatcher(n, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,,,
"logn(n, x):",https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Take log base n of x.    If `x` contains negative inputs, the answer is computed and returned in the    complex domain.",n : array_like       The integer base(s) in which the log is taken.    x : array_like       The value(s) whose log base `n` is (are) required.,"out : ndarray or scalar       The log base `n` of the `x` value(s). If `x` was a scalar, so is       `out`, otherwise an array is returned."
log2(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the logarithm base 2 of `x`.    Return the ""principal value"" (for a description of this, see    `numpy.log2`) of :math:`log_2(x)`. For real `x > 0`, this is    a real number (``log2(0)`` returns ``-inf`` and ``log2(np.inf)`` returns    ``inf``). Otherwise, the complex principle value is returned.",x : array_like       The value(s) whose log base 2 is (are) required.,"out : ndarray or scalar       The log base 2 of the `x` value(s). If `x` was a scalar, so is `out`,       otherwise an array is returned."
"_power_dispatcher(x, p):",https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,,,
"power(x, p):",https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Return x to the power p, (x**p).    If `x` contains negative values, the output is converted to the    complex domain.","x : array_like        The input value(s).    p : array_like of ints        The power(s) to which `x` is raised. If `x` contains multiple values,        `p` has to either be a scalar, or contain the same number of values        as `x`. In the latter case, the result is        ``x[0]**p[0], x[1]**p[1], ...``.","out : ndarray or scalar        The result of ``x**p``. If `x` and `p` are scalars, so is `out`,        otherwise an array is returned."
arccos(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the inverse cosine of x.    Return the ""principal value"" (for a description of this, see    `numpy.arccos`) of the inverse cosine of `x`. For real `x` such that    `abs(x) <= 1`, this is a real number in the closed interval    :math:`[0, \\pi]`.  Otherwise, the complex principle value is returned.",x : array_like or scalar       The value(s) whose arccos is (are) required.,"out : ndarray or scalar       The inverse cosine(s) of the `x` value(s). If `x` was a scalar, so       is `out`, otherwise an array object is returned."
arcsin(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/scimath.py,"     Compute the inverse sine of x.    Return the ""principal value"" (for a description of this, see    `numpy.arcsin`) of the inverse sine of `x`. For real `x` such that    `abs(x) <= 1`, this is a real number in the closed interval    :math:`[-\\pi/2, \\pi/2]`.  Otherwise, the complex principle value is    returned.",x : array_like or scalar       The value(s) whose arcsin is (are) required.,"out : ndarray or scalar       The inverse sine(s) of the `x` value(s). If `x` was a scalar, so       is `out`, otherwise an array object is returned."
,https://github.com//numpy/numpy/blob/master/numpy/lib/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"_make_along_axis_idx(arr_shape, indices, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"_take_along_axis_dispatcher(arr, indices, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"take_along_axis(arr, indices, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Take values from the input array by matching 1d index and data slices.    This iterates over matching 1d slices oriented along the specified axis in    the index and data arrays, and uses the former to look up values in the    latter. These slices can be different lengths.    Functions returning an index along an axis, like `argsort` and    `argpartition`, produce suitable indices for this function.    .. versionadded:: 1.15.0","arr: ndarray (Ni..., M, Nk...)        Source array    indices: ndarray (Ni..., J, Nk...)        Indices to take along each 1d slice of `arr`. This must match the        dimension of arr, but dimensions Ni and Nj only need to broadcast        against `arr`.    axis: int        The axis to take 1d slices along. If axis is None, the input array is        treated as if it had first been flattened to 1d, for consistency with        `sort` and `argsort`.","out: ndarray (Ni..., J, Nk...)        The indexed result."
"_put_along_axis_dispatcher(arr, indices, values, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"put_along_axis(arr, indices, values, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Put values into the destination array by matching 1d index and data slices.    This iterates over matching 1d slices oriented along the specified axis in    the index and data arrays, and uses the former to place values into the    latter. These slices can be different lengths.    Functions returning an index along an axis, like `argsort` and    `argpartition`, produce suitable indices for this function.    .. versionadded:: 1.15.0","arr: ndarray (Ni..., M, Nk...)        Destination array.    indices: ndarray (Ni..., J, Nk...)        Indices to change along each 1d slice of `arr`. This must match the        dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast        against `arr`.    values: array_like (Ni..., J, Nk...)        values to insert at those indices. Its shape and dimension are        broadcast to match that of `indices`.    axis: int        The axis to take 1d slices along. If axis is None, the destination        array is treated as if a flattened 1d view had been created of it.",
"_apply_along_axis_dispatcher(func1d, axis, arr, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"apply_along_axis(func1d, axis, arr, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Apply a function to 1-D slices along the given axis.    Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`    is a 1-D slice of `arr` along `axis`.    This is equivalent to (but faster than) the following use of `ndindex` and    `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::        Ni, Nk = a.shape[:axis], a.shape[axis+1:]        for ii in ndindex(Ni):            for kk in ndindex(Nk):                f = func1d(arr[ii + s_[:,] + kk])                Nj = f.shape                for jj in ndindex(Nj):                    out[ii + jj + kk] = f[jj]    Equivalently, eliminating the inner loop, this can be expressed as::        Ni, Nk = a.shape[:axis], a.shape[axis+1:]        for ii in ndindex(Ni):            for kk in ndindex(Nk):                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])","func1d : function (M,) -> (Nj...)        This function should accept 1-D arrays. It is applied to 1-D        slices of `arr` along the specified axis.    axis : integer        Axis along which `arr` is sliced.    arr : ndarray (Ni..., M, Nk...)        Input array.    args : any        Additional arguments to `func1d`.    kwargs : any        Additional named arguments to `func1d`.","out : ndarray  (Ni..., Nj..., Nk...)        The output array. The shape of `out` is identical to the shape of        `arr`, except along the `axis` dimension. This axis is removed, and        replaced with new dimensions equal to the shape of the return value        of `func1d`. So if `func1d` returns a scalar `out` will have one        fewer dimensions than `arr`."
"_apply_over_axes_dispatcher(func, a, axes):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"apply_over_axes(func, a, axes):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Apply a function repeatedly over multiple axes.    `func` is called as `res = func(a, axis)`, where `axis` is the first    element of `axes`.  The result `res` of the function call must have    either the same dimensions as `a` or one less dimension.  If `res`    has one less dimension than `a`, a dimension is inserted before    `axis`.  The call to `func` is then repeated for each axis in `axes`,    with `res` as the first argument.","func : function        This function must take two arguments, `func(a, axis)`.    a : array_like        Input array.    axes : array_like        Axes over which `func` is applied; the elements must be integers.","apply_over_axis : ndarray        The output array.  The number of dimensions is the same as `a`,        but the shape can be different.  This depends on whether `func`        changes the shape of its output with respect to its input."
"_expand_dims_dispatcher(a, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"expand_dims(a, axis):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Expand the shape of an array.    Insert a new axis that will appear at the `axis` position in the expanded    array shape.    .. note:: Previous to NumPy 1.13.0, neither ``axis < -a.ndim - 1`` nor       ``axis > a.ndim`` raised errors or put the new axis where documented.       Those axis values are now deprecated and will raise an AxisError in the       future.",a : array_like        Input array.    axis : int        Position in the expanded axes where the new axis is placed.,res : ndarray        View of `a` with the number of dimensions increased by one.
_column_stack_dispatcher(tup):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
column_stack(tup):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Stack 1-D arrays as columns into a 2-D array.    Take a sequence of 1-D arrays and stack them as columns    to make a single 2-D array. 2-D arrays are stacked as-is,    just like with `hstack`.  1-D arrays are turned into 2-D columns    first.",tup : sequence of 1-D or 2-D arrays.        Arrays to stack. All of them must have the same first dimension.,stacked : 2-D array        The array formed by stacking the given arrays.
_dstack_dispatcher(tup):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
dstack(tup):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Stack arrays in sequence depth wise (along third axis).    This is equivalent to concatenation along the third axis after 2-D arrays    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by    `dsplit`.    This function makes most sense for arrays with up to 3 dimensions. For    instance, for pixel-data with a height (first axis), width (second axis),    and r/g/b channels (third axis). The functions `concatenate`, `stack` and    `block` provide more general stacking and concatenation operations.",tup : sequence of arrays        The arrays must have the same shape along all but the third axis.        1-D or 2-D arrays must have the same shape.,"stacked : ndarray        The array formed by stacking the given arrays, will be at least 3-D."
_replace_zero_by_x_arrays(sub_arys):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"_array_split_dispatcher(ary, indices_or_sections, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"array_split(ary, indices_or_sections, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Split an array into multiple sub-arrays.    Please refer to the ``split`` documentation.  The only difference    between these functions is that ``array_split`` allows    `indices_or_sections` to be an integer that does *not* equally    divide the axis. For an array of length l that should be split    into n sections, it returns l % n sub-arrays of size l//n + 1    and the rest of size l//n.    See Also    --------    split : Split array into multiple sub-arrays of equal size.    Examples    -------- >>> x = np.arange(8.0) >>> np.array_split(x, 3)        [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])] >>> x = np.arange(7.0) >>> np.array_split(x, 3)        [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]",,
"_split_dispatcher(ary, indices_or_sections, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"split(ary, indices_or_sections, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,     Split an array into multiple sub-arrays.,"ary : ndarray        Array to be divided into sub-arrays.    indices_or_sections : int or 1-D array        If `indices_or_sections` is an integer, N, the array will be divided        into N equal arrays along `axis`.  If such a split is not possible,        an error is raised.",sub-arrays : list of ndarrays        A list of sub-arrays.
"_hvdsplit_dispatcher(ary, indices_or_sections):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"hsplit(ary, indices_or_sections):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Split an array into multiple sub-arrays horizontally (column-wise).    Please refer to the `split` documentation.  `hsplit` is equivalent    to `split` with ``axis=1``, the array is always split along the second    axis regardless of the array dimension.    See Also    --------    split : Split an array into multiple sub-arrays of equal size.    Examples    -------- >>> x = np.arange(16.0).reshape(4, 4) >>> x    array([[ 0.,   1.,   2.,   3.],           [ 4.,   5.,   6.,   7.],           [ 8.,   9.,  10.,  11.],           [12.,  13.,  14.,  15.]]) >>> np.hsplit(x, 2)    [array([[  0.,   1.],           [  4.,   5.],           [  8.,   9.],           [12.,  13.]]),     array([[  2.,   3.],           [  6.,   7.],           [10.,  11.],           [14.,  15.]])] >>> np.hsplit(x, np.array([3, 6]))    [array([[ 0.,   1.,   2.],           [ 4.,   5.,   6.],           [ 8.,   9.,  10.],           [12.,  13.,  14.]]),     array([[ 3.],           [ 7.],           [11.],           [15.]]),     array([], shape=(4, 0), dtype=float64)]    With a higher dimensional array the split is still along the second axis. >>> x = np.arange(8.0).reshape(2, 2, 2) >>> x    array([[[0.,  1.],            [2.,  3.]],           [[4.,  5.],            [6.,  7.]]]) >>> np.hsplit(x, 2)    [array([[[0.,  1.]],           [[4.,  5.]]]),     array([[[2.,  3.]],           [[6.,  7.]]])]",,
"vsplit(ary, indices_or_sections):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Split an array into multiple sub-arrays vertically (row-wise).    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent    to ``split`` with `axis=0` (default), the array is always split along the    first axis regardless of the array dimension.    See Also    --------    split : Split an array into multiple sub-arrays of equal size.    Examples    -------- >>> x = np.arange(16.0).reshape(4, 4) >>> x    array([[ 0.,   1.,   2.,   3.],           [ 4.,   5.,   6.,   7.],           [ 8.,   9.,  10.,  11.],           [12.,  13.,  14.,  15.]]) >>> np.vsplit(x, 2)    [array([[0., 1., 2., 3.],           [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],           [12., 13., 14., 15.]])] >>> np.vsplit(x, np.array([3, 6]))    [array([[ 0.,  1.,  2.,  3.],           [ 4.,  5.,  6.,  7.],           [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]    With a higher dimensional array the split is still along the first axis. >>> x = np.arange(8.0).reshape(2, 2, 2) >>> x    array([[[0.,  1.],            [2.,  3.]],           [[4.,  5.],            [6.,  7.]]]) >>> np.vsplit(x, 2)    [array([[[0., 1.],            [2., 3.]]]), array([[[4., 5.],            [6., 7.]]])]",,
"dsplit(ary, indices_or_sections):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Split array into multiple sub-arrays along the 3rd axis (depth).    Please refer to the `split` documentation.  `dsplit` is equivalent    to `split` with ``axis=2``, the array is always split along the third    axis provided the array dimension is greater than or equal to 3.    See Also    --------    split : Split an array into multiple sub-arrays of equal size.    Examples    -------- >>> x = np.arange(16.0).reshape(2, 2, 4) >>> x    array([[[ 0.,   1.,   2.,   3.],            [ 4.,   5.,   6.,   7.]],           [[ 8.,   9.,  10.,  11.],            [12.,  13.,  14.,  15.]]]) >>> np.dsplit(x, 2)    [array([[[ 0.,  1.],            [ 4.,  5.]],           [[ 8.,  9.],            [12., 13.]]]), array([[[ 2.,  3.],            [ 6.,  7.]],           [[10., 11.],            [14., 15.]]])] >>> np.dsplit(x, np.array([3, 6]))    [array([[[ 0.,   1.,   2.],            [ 4.,   5.,   6.]],           [[ 8.,   9.,  10.],            [12.,  13.,  14.]]]),     array([[[ 3.],            [ 7.]],           [[11.],            [15.]]]),    array([], shape=(2, 2, 0), dtype=float64)]",,
get_array_prepare(*args):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py," Find the wrapper for the array with the highest priority.    In case of ties, leftmost wins. If no wrapper is found, return None",,
get_array_wrap(*args):,https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py," Find the wrapper for the array with the highest priority.    In case of ties, leftmost wins. If no wrapper is found, return None",,
"_kron_dispatcher(a, b):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
"kron(a, b):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,"     Kronecker product of two arrays.    Computes the Kronecker product, a composite array made of blocks of the    second array scaled by the first.","a, b : array_like",out : ndarray
"_tile_dispatcher(A, reps):",https://github.com//numpy/numpy/blob/master/numpy/lib/shape_base.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,,,
"_maybe_view_as_subclass(original_array, new_array):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,,,
"as_strided(x, shape=None, strides=None, subok=False, writeable=True):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,"     Create a view into the array with the given shape and strides.    .. warning:: This function has to be used with extreme care, see notes.","x : ndarray        Array to create a new.    shape : sequence of int, optional        The shape of the new array. Defaults to ``x.shape``.    strides : sequence of int, optional        The strides of the new array. Defaults to ``x.strides``.    subok : bool, optional        .. versionadded:: 1.10",view : ndarray
"_broadcast_to(array, shape, subok, readonly):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,,,
"_broadcast_to_dispatcher(array, shape, subok=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,,,
"broadcast_to(array, shape, subok=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py, Broadcast an array to a new shape.,"array : array_like        The array to broadcast.    shape : tuple        The shape of the desired array.    subok : bool, optional        If True, then sub-classes will be passed-through, otherwise        the returned array will be forced to be a base-class array (default).","broadcast : array        A readonly view on the original array with the given shape. It is        typically not contiguous. Furthermore, more than one element of a        broadcasted array may refer to a single memory location."
_broadcast_shape(*args):,https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py, Returns the shape of the arrays that would result from broadcasting the    supplied arrays against each other.,,
"_broadcast_arrays_dispatcher(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/stride_tricks.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"_min_int(low, high):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"  get small int that fits the range  if high <= i1.max and low >= i1.min: return int8 if high <= i2.max and low >= i2.min: return int16 if high <= i4.max and low >= i4.min: return int32 return int64

",,
_flip_dispatcher(m):,https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
fliplr(m):,https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Flip array in the left/right direction.    Flip the entries in each row in the left/right direction.    Columns are preserved, but appear in a different order than before.","m : array_like        Input array, must be at least 2-D.","f : ndarray        A view of `m` with the columns reversed.  Since a view        is returned, this operation is :math:`\\mathcal O(1)`."
flipud(m):,https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Flip array in the up/down direction.    Flip the entries in each column in the up/down direction.    Rows are preserved, but appear in a different order than before.",m : array_like        Input array.,"out : array_like        A view of `m` with the rows reversed.  Since a view is        returned, this operation is :math:`\\mathcal O(1)`."
"eye(N, M=None, k=0, dtype=float, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Return a 2-D array with ones on the diagonal and zeros elsewhere.,"N : int      Number of rows in the output.    M : int, optional      Number of columns in the output. If None, defaults to `N`.    k : int, optional      Index of the diagonal: 0 (the default) refers to the main diagonal,      a positive value refers to an upper diagonal, and a negative value      to a lower diagonal.    dtype : data-type, optional      Data-type of the returned array.    order : {'C', 'F'}, optional        Whether the output should be stored in row-major (C-style) or        column-major (Fortran-style) order in memory.","I : ndarray of shape (N,M)      An array where all elements are equal to zero, except for the `k`-th      diagonal, whose values are equal to one."
"_diag_dispatcher(v, k=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"diag(v, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Extract a diagonal or construct a diagonal array.    See the more detailed documentation for ``numpy.diagonal`` if you use this    function to extract a diagonal and wish to write to the resulting array;    whether it returns a copy or a view depends on what version of numpy you    are using.,"v : array_like        If `v` is a 2-D array, return a copy of its `k`-th diagonal.        If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th        diagonal.    k : int, optional        Diagonal in question. The default is 0. Use `k>0` for diagonals        above the main diagonal, and `k<0` for diagonals below the main        diagonal.",out : ndarray        The extracted diagonal or constructed diagonal array.
"diagflat(v, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Create a two-dimensional array with the flattened input as a diagonal.,"v : array_like        Input data, which is flattened and set as the `k`-th        diagonal of the output.    k : int, optional        Diagonal to set; 0, the default, corresponds to the ""main"" diagonal,        a positive (negative) `k` giving the number of the diagonal above        (below) the main.",out : ndarray        The 2-D output array.
"tri(N, M=None, k=0, dtype=float):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     An array with ones at and below the given diagonal and zeros elsewhere.,"N : int        Number of rows in the array.    M : int, optional        Number of columns in the array.        By default, `M` is taken equal to `N`.    k : int, optional        The sub-diagonal at and below which the array is filled.        `k` = 0 is the main diagonal, while `k` < 0 is below it,        and `k` > 0 is above.  The default is 0.    dtype : dtype, optional        Data type of the returned array.  The default is float.","tri : ndarray of shape (N, M)        Array with its lower triangle filled with ones and zero elsewhere;        in other words ``T[i,j] == 1`` for ``i <= j + k``, 0 otherwise."
"_trilu_dispatcher(m, k=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"tril(m, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Lower triangle of an array.    Return a copy of an array with elements above the `k`-th diagonal zeroed.,"m : array_like, shape (M, N)        Input array.    k : int, optional        Diagonal above which to zero elements.  `k = 0` (the default) is the        main diagonal, `k < 0` is below it and `k > 0` is above.","tril : ndarray, shape (M, N)        Lower triangle of `m`, of same shape and data-type as `m`."
"triu(m, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Upper triangle of an array.    Return a copy of a matrix with the elements below the `k`-th diagonal    zeroed.    Please refer to the documentation for `tril` for further details.    See Also    --------    tril : lower triangle of an array    Examples    -------- >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)    array([[ 1,  2,  3],           [ 4,  5,  6],           [ 0,  8,  9],           [ 0,  0, 12]])",,
"_vander_dispatcher(x, N=None, increasing=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"vander(x, N=None, increasing=False):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Generate a Vandermonde matrix.    The columns of the output matrix are powers of the input vector. The    order of the powers is determined by the `increasing` boolean argument.    Specifically, when `increasing` is False, the `i`-th output column is    the input vector raised element-wise to the power of ``N - i - 1``. Such    a matrix with a geometric progression in each row is named for Alexandre-    Theophile Vandermonde.","x : array_like        1-D input array.    N : int, optional        Number of columns in the output.  If `N` is not specified, a square        array is returned (``N = len(x)``).    increasing : bool, optional        Order of the powers of the columns.  If True, the powers increase        from left to right, if False (the default) they are reversed.","out : ndarray        Vandermonde matrix.  If `increasing` is False, the first column is        ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is        True, the columns are ``x^0, x^1, ..., x^(N-1)``."
"_histogram2d_dispatcher(x, y, bins=None, range=None, normed=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"histogram2d(x, y, bins=10, range=None, normed=None, weights=None,",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Compute the bi-dimensional histogram of two data samples.,"x : array_like, shape (N,)        An array containing the x coordinates of the points to be        histogrammed.    y : array_like, shape (N,)        An array containing the y coordinates of the points to be        histogrammed.    bins : int or array_like or [int, int] or [array, array], optional        The bin specification:","H : ndarray, shape(nx, ny)        The bi-dimensional histogram of samples `x` and `y`. Values in `x`        are histogrammed along the first dimension and values in `y` are        histogrammed along the second dimension.    xedges : ndarray, shape(nx+1,)        The bin edges along the first dimension.    yedges : ndarray, shape(ny+1,)        The bin edges along the second dimension."
"mask_indices(n, mask_func, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Return the indices to access (n, n) arrays, given a masking function.    Assume `mask_func` is a function that, for a square array a of size    ``(n, n)`` with a possible offset argument `k`, when called as    ``mask_func(a, k)`` returns a new array with zeros in certain locations    (functions like `triu` or `tril` do precisely this). Then this function    returns the indices where the non-zero values would be located.","n : int        The returned indices will be valid to access arrays of shape (n, n).    mask_func : callable        A function whose call signature is similar to that of `triu`, `tril`.        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.        `k` is an optional argument to the function.    k : scalar        An optional argument which is passed through to `mask_func`. Functions        like `triu`, `tril` take a second argument that is interpreted as an        offset.","indices : tuple of arrays.        The `n` arrays of indices corresponding to the locations where        ``mask_func(np.ones((n, n)), k)`` is True."
"tril_indices(n, k=0, m=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Return the indices for the lower-triangle of an (n, m) array.","n : int        The row dimension of the arrays for which the returned        indices will be valid.    k : int, optional        Diagonal offset (see `tril` for details).    m : int, optional        .. versionadded:: 1.9.0","inds : tuple of arrays        The indices for the triangle. The returned tuple contains two arrays,        each with the indices along one dimension of the array."
"_trilu_indices_form_dispatcher(arr, k=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,,,
"tril_indices_from(arr, k=0):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,     Return the indices for the lower-triangle of arr.    See `tril_indices` for full details.,"arr : array_like        The indices will be valid for square arrays whose dimensions are        the same as arr.    k : int, optional        Diagonal offset (see `tril` for details).",
"triu_indices(n, k=0, m=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/twodim_base.py,"     Return the indices for the upper-triangle of an (n, m) array.","n : int        The size of the arrays for which the returned indices will        be valid.    k : int, optional        Diagonal offset (see `triu` for details).    m : int, optional        .. versionadded:: 1.9.0","inds : tuple, shape(2) of ndarrays, shape(`n`)        The indices for the triangle. The returned tuple contains two arrays,        each with the indices along one dimension of the array.  Can be used        to slice a ndarray of shape(`n`, `n`)."
,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
"mintypecode(typechars, typeset='GDFgdf', default='d'):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Return the character for the minimum-size type to which given types can    be safely cast.    The returned type character must represent the smallest size dtype such    that an array of the returned type can handle the data from an array of    all types in `typechars` (or if `typechars` is an array, then its    dtype.char).","typechars : list of str or array_like        If a list of strings, each string should represent a dtype.        If array_like, the character representation of the array dtype is used.    typeset : str or list of str, optional        The set of characters that the returned character is chosen from.        The default set is 'GDFgdf'.    default : str, optional        The default character, this is returned if none of the characters in        `typechars` matches a character in `typeset`.",typechar : str        The character representing the minimum-size type that was found.
"_asfarray_dispatcher(a, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
"asfarray(a, dtype=_nx.float_):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,     Return an array converted to a float type.,"a : array_like        The input array.    dtype : str or dtype object, optional        Float type code to coerce input array `a`.  If `dtype` is one of the        'int' dtypes, it is replaced with float64.",out : ndarray        The input `a` as a float ndarray.
_real_dispatcher(val):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
real(val):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,     Return the real part of the complex argument.,val : array_like        Input array.,"out : ndarray or scalar        The real component of the complex argument. If `val` is real, the type        of `val` is used for the output.  If `val` has complex elements, the        returned type is float."
_imag_dispatcher(val):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
imag(val):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,     Return the imaginary part of the complex argument.,val : array_like        Input array.,"out : ndarray or scalar        The imaginary component of the complex argument. If `val` is real,        the type of `val` is used for the output.  If `val` has complex        elements, the returned type is float."
_is_type_dispatcher(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
iscomplex(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Returns a bool array, where True if input element is complex.    What is tested is whether the input has a non-zero imaginary part, not if    the input type is complex.",x : array_like        Input array.,out : ndarray of bools        Output array.
isreal(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Returns a bool array, where True if input element is real.    If element has complex type with zero complex part, the return value    for that element is True.",x : array_like        Input array.,"out : ndarray, bool        Boolean array of same shape as `x`."
iscomplexobj(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Check for a complex type or an array of complex numbers.    The type of the input is checked, not the value. Even if the input    has an imaginary part equal to zero, `iscomplexobj` evaluates to True.",x : any        The input can be of any type and shape.,"iscomplexobj : bool        The return value, True if `x` is of a complex type or has at least        one complex element."
isrealobj(x):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Return True if x is a not complex type or an array of complex numbers.    The type of the input is checked, not the value. So even if the input    has an imaginary part equal to zero, `isrealobj` evaluates to False    if the data type is complex.",x : any        The input can be of any type and shape.,"y : bool        The return value, False if `x` is of a complex type."
_getmaxmin(t):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
"_nan_to_num_dispatcher(x, copy=None, nan=None, posinf=None, neginf=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
"nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Replace NaN with zero and infinity with large finite numbers (default    behaviour) or with the numbers defined by the user using the `nan`,     `posinf` and/or `neginf` keywords.    If `x` is inexact, NaN is replaced by zero or by the user defined value in    `nan` keyword, infinity is replaced by the largest finite floating point     values representable by ``x.dtype`` or by the user defined value in     `posinf` keyword and -infinity is replaced by the most negative finite     floating point values representable by ``x.dtype`` or by the user defined     value in `neginf` keyword.    For complex dtypes, the above is applied to each of the real and    imaginary components of `x` separately.    If `x` is not inexact, then no replacements are made.","x : scalar or array_like        Input data.    copy : bool, optional        Whether to create a copy of `x` (True) or to replace values        in-place (False). The in-place operation only occurs if        casting to an array does not require a copy.        Default is True.    nan : int, float, optional        Value to be used to fill NaN values. If no value is passed         then NaN values will be replaced with 0.0.    posinf : int, float, optional        Value to be used to fill positive infinity values. If no value is         passed then positive infinity values will be replaced with a very        large number.    neginf : int, float, optional        Value to be used to fill negative infinity values. If no value is         passed then negative infinity values will be replaced with a very        small (or negative) number.","out : ndarray        `x`, with the non-finite values replaced. If `copy` is False, this may        be `x` itself."
"_real_if_close_dispatcher(a, tol=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
"real_if_close(a, tol=100):",https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     If complex input returns a real array if complex parts are close to zero.    ""Close to zero"" is defined as `tol` * (machine epsilon of the type for    `a`).",a : array_like        Input array.    tol : float        Tolerance in machine epsilons for the complex part of the elements        in the array.,"out : ndarray        If `a` is real, the type of `a` is used for the output.  If `a`        has complex elements, the returned type is float."
_asscalar_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
asscalar(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,"     Convert an array of size 1 to its scalar equivalent.    .. deprecated:: 1.16        Deprecated, use `numpy.ndarray.item()` instead.",a : ndarray        Input array of size 1.,out : scalar        Scalar representation of `a`. The output data type is the same type        returned by the input's `item` method.
typename(char):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,     Return a description for the given data type code.,char : str        Data type code.,out : str        Description of the input data type code.
_common_type_dispatcher(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/lib/type_check.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,,,
_deprecate_out_named_y(f):,https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,"     Allow the out argument to be passed as the name `y` (deprecated)    In future, this decorator should be removed.",,
_fix_out_named_y(f):,https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,     Allow the out argument to be passed as the name `y` (deprecated)    This decorator should only be used if _deprecate_out_named_y is used on    a corresponding dispatcher function.,,
_fix_and_maybe_deprecate_out_named_y(f):,https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,"     Use the appropriate decorator, depending upon if dispatching is being used.",,
"_dispatcher(x, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,,,
"fix(x, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,     Round to nearest integer towards zero.    Round an array of floats element-wise to nearest integer towards zero.    The rounded values are returned as floats.,"x : array_like        An array of floats to be rounded    y : ndarray, optional        Output array",out : ndarray of floats        The array of rounded numbers
"isposinf(x, out=None):",https://github.com//numpy/numpy/blob/master/numpy/lib/ufunclike.py,"     Test element-wise for positive infinity, return result as bool array.","x : array_like        The input array.    y : array_like, optional        A boolean array with the same shape as `x` to store the result.",out : ndarray        A boolean array with the same dimensions as the input.        If second argument is not supplied then a boolean array is returned        with values True where the corresponding element of the input is        positive infinity and values False where the element of the input is        not positive infinity.
,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,,,
get_include():,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,"     Return the directory that contains the NumPy \\*.h header files.    Extension modules that need to compile against NumPy should use this    function to locate the appropriate include directory.    Notes    -----    When using ``distutils``, for example in ``setup.py``.    ::        import numpy as np        ...        Extension('extension_name', ...                include_dirs=[np.get_include()])        ...",,
"_set_function_name(func, name):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Decorator class to deprecate old functions.    Refer to `deprecate` for details.    See Also    --------    deprecate,,
_get_indent(lines):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Determines the leading whitespace that could be removed from all the lines.,,
"deprecate(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,"     Issues a DeprecationWarning, adds warning to `old_name`'s    docstring, rebinds ``old_name.__name__`` and returns the new    function object.    This function may also be used as a decorator.","func : function        The function to be deprecated.    old_name : str, optional        The name of the function to be deprecated. Default is None, in        which case the name of `func` is used.    new_name : str, optional        The new name for the function. Default is None, in which case the        deprecation message is that `old_name` is deprecated. If given, the        deprecation message is that `old_name` is deprecated and `new_name`        should be used instead.    message : str, optional        Additional explanation of the deprecation.  Displayed in the        docstring after the warning.",old_func : function        The deprecated function.
byte_bounds(a):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Returns pointers to the end-points of an array.,a : ndarray        Input array. It must conform to the Python-side of the array        interface.,"(low, high) : tuple of 2 integers        The first integer is the first byte of the array, the second        integer is just past the last byte of the array.  If `a` is not        contiguous it will not use every byte between the (`low`, `high`)        values."
who(vardict=None):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Print the NumPy arrays in the given dictionary.    If there is no dictionary passed in or `vardict` is None then returns    NumPy arrays in the globals() dictionary (all NumPy arrays in the    namespace).,"vardict : dict, optional        A dictionary possibly containing ndarrays.  Default is globals().",out : None        Returns 'None'.
"_split_line(name, arguments, width):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,,,
_makenamedict(module='numpy'):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,,,
"_info(obj, output=sys.stdout):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py, Provide information about ndarray obj.,"obj : ndarray        Must be ndarray, not checked.    output        Where printed output goes.",
"info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,"     Get help information for a function, class, or module.","object : object or str, optional        Input object or name to get information about. If `object` is a        numpy object, its docstring is given. If it is a string, available        modules are searched for matching objects.  If None, information        about `info` itself is returned.    maxwidth : int, optional        Printing width.    output : file like object, optional        File like object that the output is written to, default is        ``stdout``.  The object has to be opened in 'w' or 'a' mode.    toplevel : str, optional        Start search at this level.",
"source(object, output=sys.stdout):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Print or write to a file the source code for a NumPy object.    The source code is only returned for objects written in Python. Many    functions and classes are defined in C and will therefore not return    useful information.,"object : numpy object        Input object. This can be any object (function, class, module,        ...).    output : file object, optional        If `output` not supplied then source code is printed to screen        (sys.stdout).  File object must be created with either write 'w' or        append 'a' modes.",
"lookfor(what, module=None, import_modules=True, regenerate=False,",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,"     Do a keyword search on docstrings.    A list of objects that matched the search is displayed,    sorted by relevance. All given keywords need to be found in the    docstring for it to be returned as a result, but the order does    not matter.","what : str        String containing words to look for.    module : str or list, optional        Name of module(s) whose docstrings to go through.    import_modules : bool, optional        Whether to import sub-modules in packages. Default is True.    regenerate : bool, optional        Whether to re-generate the docstring cache. Default is False.    output : file-like, optional        File-like object to write the output to. If omitted, use a pager.",
"_lookfor_generate_cache(module, import_modules, regenerate):",https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Generate docstring cache for given module.,"module : str, None, module        Module for which to generate docstring cache    import_modules : bool        Whether to import sub-modules in packages.    regenerate : bool        Re-generate the docstring cache","cache : dict {obj_full_name: (docstring, kind, index), ...}        Docstring cache for the module, either cached one (regenerate=False)        or newly generated."
_getmembers(item):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,"     Object to evaluate constant string expressions.    This includes strings with lists, dicts and tuples using the abstract    syntax tree created by ``compiler.parse``.    .. deprecated:: 1.10.0    See Also    --------    safe_eval",,
safe_eval(source):,https://github.com//numpy/numpy/blob/master/numpy/lib/utils.py,     Protected string evaluation.    Evaluate a string containing a Python literal expression without    allowing the execution of arbitrary non-literal code.,source : str        The string to evaluate.,obj : object       The result of evaluating `source`.
,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
"sep_seq(sequence, sep):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
"runScanner(data, scanner_class, lexicon=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py," Following clapack, we remove ftnlen arguments, which f2c puts after    a char * argument to hold the length of the passed string. This is just    a nuisance in C.",,
scrubFtnlen(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
cleanSource(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
cleanComments(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
removeHeader(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
removeSubroutinePrototypes(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
removeBuiltinFunctions(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py,,,
replaceDlamch(source):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/clapack_scrub.py," Replace dlamch_ calls with appropriate macros def repl(m):        s = m.group(1) return dict(E='EPSILON', P='PRECISION', S='SAFEMINIMUM', B='BASE')[s[0]]    source = re.sub(r'dlamch_\(""(.*?)""\)', repl, source)    source = re.sub(r'^\s+extern.*? dlamch_.*?;$(?m)', '', source) return source
# do it
",,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py,,,
isBlank(line):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py,,,
isLabel(line):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py,,,
isComment(line):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py,,,
isContinuation(line):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py,,,
lineType(line):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py," Return the type of a line of Fortan code. if isBlank(line): return COMMENT elif isLabel(line): return STATEMENT elif isComment(line): return COMMENT elif isContinuation(line): return CONTINUATION else: return STATEMENT
class LineIterator(object):",,
fortranSourceLines(fo):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/fortran.py," Return an iterator over statement lines of a Fortran source file.    Comment and blank lines are stripped out, and continuation lines are    merged.",,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
"printRoutineNames(desc, routines):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
"getLapackRoutines(wrapped_routines, ignores, lapack_dir):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
getWrappedRoutineNames(wrapped_routines_file):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
"dumpRoutineNames(library, output_dir):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
"concatenateRoutines(routines, output_file):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
"runF2C(fortran_filename, output_dir):",https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
scrubF2CSource(c_file):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
ensure_executable(name):,https://github.com//numpy/numpy/blob/master/numpy/linalg/lapack_lite/make_lite.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_deprecations.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
"consistent_subclass(out, in_):",https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
"assert_almost_equal(a, b, single_decimal=6, double_decimal=12, **kw):",https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
get_real_dtype(dtype):,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
get_complex_dtype(dtype):,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
get_rtol(dtype):,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,"         A bundle of arguments to be passed to a test case, with an identifying        name, the operands a and b, and a set of tags to filter the tests",,
"apply_tag(tag, cases):",https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,     Add the given tag (a string) to each of the cases (a list of LinalgCase    objects),,
_make_generalized_cases():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
_stride_comb_iter(x):,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,     Generate cartesian product of strides for all axes,,
_make_strided_cases():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,"         Run func on each of the cases with all of the tags in require, and none        of the tags in exclude",,
"dot_generalized(a, b):",https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
identity_like_generalized(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,"  Empty input should put an identity matrix in u or vh         x = np.empty((4, 0))        u, s, vh = linalg.svd(x, compute_uv=True, hermitian=self.hermitian)        assert_equal(u.shape, (4, 4))        assert_equal(vh.shape, (0, 0))        assert_equal(u, np.eye(4))
        x = np.empty((0, 4))        u, s, vh = linalg.svd(x, compute_uv=True, hermitian=self.hermitian)        assert_equal(u.shape, (0, 0))        assert_equal(vh.shape, (4, 4))        assert_equal(vh, np.eye(4))

class SVDHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
 def do(self, a, b, tags):        u, s, vt = linalg.svd(a, 0, hermitian=True)        assert_allclose(a, dot_generalized(np.asarray(u) * np.asarray(s)[..., None, :],                                           np.asarray(vt)), rtol=get_rtol(u.dtype))        assert_(consistent_subclass(u, a))        assert_(consistent_subclass(vt, a))

class TestSVDHermitian(SVDHermitianCases, SVDBaseTests):    hermitian = True

class CondCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase): # cond(x, p) for p in (None, 2, -2)
 def do(self, a, b, tags):        c = asarray(a)  # a might be a matrix if 'size-0' in tags:            assert_raises(LinAlgError, linalg.cond, c) return
 # +-2 norms        s = linalg.svd(c, compute_uv=False)        assert_almost_equal(            linalg.cond(a), s[..., 0] / s[..., -1], single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, 2), s[..., 0] / s[..., -1], single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, -2), s[..., -1] / s[..., 0], single_decimal=5, double_decimal=11)
 # Other norms        cinv = np.linalg.inv(c)        assert_almost_equal(            linalg.cond(a, 1), abs(c).sum(-2).max(-1) * abs(cinv).sum(-2).max(-1), single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, -1), abs(c).sum(-2).min(-1) * abs(cinv).sum(-2).min(-1), single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, np.inf), abs(c).sum(-1).max(-1) * abs(cinv).sum(-1).max(-1), single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, -np.inf), abs(c).sum(-1).min(-1) * abs(cinv).sum(-1).min(-1), single_decimal=5, double_decimal=11)        assert_almost_equal(            linalg.cond(a, 'fro'),            np.sqrt((abs(c)**2).sum(-1).sum(-1) * (abs(cinv)**2).sum(-1).sum(-1)), single_decimal=5, double_decimal=11)

class TestCond(CondCases): def test_basic_nonsvd(self): # Smoketest the non-svd norms        A = array([[1., 0, 1], [0, -2., 0], [0, 0, 3.]])        assert_almost_equal(linalg.cond(A, inf), 4)        assert_almost_equal(linalg.cond(A, -inf), 2/3)        assert_almost_equal(linalg.cond(A, 1), 4)        assert_almost_equal(linalg.cond(A, -1), 0.5)        assert_almost_equal(linalg.cond(A, 'fro'), np.sqrt(265 / 12))
 def test_singular(self): # Singular matrices have infinite condition number for # positive norms, and negative norms shouldn't raise # exceptions        As = [np.zeros((2, 2)), np.ones((2, 2))]        p_pos = [None, 1, 2, 'fro']        p_neg = [-1, -2] for A, p in itertools.product(As, p_pos): # Inversion may not hit exact infinity, so just check the # number is large            assert_(linalg.cond(A, p) > 1e15) for A, p in itertools.product(As, p_neg):            linalg.cond(A, p)
 def test_nan(self): # nans should be passed through, not converted to infs        ps = [None, 1, -1, 2, -2, 'fro']        p_pos = [None, 1, 2, 'fro']
        A = np.ones((2, 2))        A[0,1] = np.nan for p in ps:            c = linalg.cond(A, p)            assert_(isinstance(c, np.float_))            assert_(np.isnan(c))
        A = np.ones((3, 2, 2))        A[1,0,1] = np.nan for p in ps:            c = linalg.cond(A, p)            assert_(np.isnan(c[1])) if p in p_pos:                assert_(c[0] > 1e15)                assert_(c[2] > 1e15) else:                assert_(not np.isnan(c[0]))                assert_(not np.isnan(c[2]))
 def test_stacked_singular(self): # Check behavior when only some of the stacked matrices are # singular        np.random.seed(1234)        A = np.random.rand(2, 2, 2, 2)        A[0,0] = 0        A[1,1] = 0
 for p in (None, 1, 2, 'fro', -1, -2):            c = linalg.cond(A, p)            assert_equal(c[0,0], np.inf)            assert_equal(c[1,1], np.inf)            assert_(np.isfinite(c[0,1]))            assert_(np.isfinite(c[1,0]))

class PinvCases(LinalgSquareTestCase, LinalgNonsquareTestCase, LinalgGeneralizedSquareTestCase, LinalgGeneralizedNonsquareTestCase):
 def do(self, a, b, tags):        a_ginv = linalg.pinv(a) # `a @ a_ginv == I` does not hold if a is singular        dot = dot_generalized        assert_almost_equal(dot(dot(a, a_ginv), a), a, single_decimal=5, double_decimal=11)        assert_(consistent_subclass(a_ginv, a))

class TestPinv(PinvCases): pass

class PinvHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
 def do(self, a, b, tags):        a_ginv = linalg.pinv(a, hermitian=True) # `a @ a_ginv == I` does not hold if a is singular        dot = dot_generalized        assert_almost_equal(dot(dot(a, a_ginv), a), a, single_decimal=5, double_decimal=11)        assert_(consistent_subclass(a_ginv, a))

class TestPinvHermitian(PinvHermitianCases): pass

class DetCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
 def do(self, a, b, tags):        d = linalg.det(a)        (s, ld) = linalg.slogdet(a) if asarray(a).dtype.type in (single, double):            ad = asarray(a).astype(double) else:            ad = asarray(a).astype(cdouble)        ev = linalg.eigvals(ad)        assert_almost_equal(d, multiply.reduce(ev, axis=-1))        assert_almost_equal(s * np.exp(ld), multiply.reduce(ev, axis=-1))
        s = np.atleast_1d(s)        ld = np.atleast_1d(ld)        m = (s != 0)        assert_almost_equal(np.abs(s[m]), 1)        assert_equal(ld[~m], -inf)

class TestDet(DetCases): def test_zero(self):        assert_equal(linalg.det([[0.0]]), 0.0)        assert_equal(type(linalg.det([[0.0]])), double)        assert_equal(linalg.det([[0.0j]]), 0.0)        assert_equal(type(linalg.det([[0.0j]])), cdouble)
        assert_equal(linalg.slogdet([[0.0]]), (0.0, -inf))        assert_equal(type(linalg.slogdet([[0.0]])[0]), double)        assert_equal(type(linalg.slogdet([[0.0]])[1]), double)        assert_equal(linalg.slogdet([[0.0j]]), (0.0j, -inf))        assert_equal(type(linalg.slogdet([[0.0j]])[0]), cdouble)        assert_equal(type(linalg.slogdet([[0.0j]])[1]), double)
 @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble]) def test_types(self, dtype):        x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)        assert_equal(np.linalg.det(x).dtype, dtype)        ph, s = np.linalg.slogdet(x)        assert_equal(s.dtype, get_real_dtype(dtype))        assert_equal(ph.dtype, dtype)
 def test_0_size(self):        a = np.zeros((0, 0), dtype=np.complex64)        res = linalg.det(a)        assert_equal(res, 1.)        assert_(res.dtype.type is np.complex64)        res = linalg.slogdet(a)        assert_equal(res, (1, 0))        assert_(res[0].dtype.type is np.complex64)        assert_(res[1].dtype.type is np.float32)
        a = np.zeros((0, 0), dtype=np.float64)        res = linalg.det(a)        assert_equal(res, 1.)        assert_(res.dtype.type is np.float64)        res = linalg.slogdet(a)        assert_equal(res, (1, 0))        assert_(res[0].dtype.type is np.float64)        assert_(res[1].dtype.type is np.float64)

class LstsqCases(LinalgSquareTestCase, LinalgNonsquareTestCase):
 def do(self, a, b, tags):        arr = np.asarray(a)        m, n = arr.shape        u, s, vt = linalg.svd(a, 0)        x, residuals, rank, sv = linalg.lstsq(a, b, rcond=-1) if m == 0:            assert_((x == 0).all()) if m <= n:            assert_almost_equal(b, dot(a, x))            assert_equal(rank, m) else:            assert_equal(rank, n)        assert_almost_equal(sv, sv.__array_wrap__(s)) if rank == n and m > n:            expect_resids = (                np.asarray(abs(np.dot(a, x) - b)) ** 2).sum(axis=0)            expect_resids = np.asarray(expect_resids) if np.asarray(b).ndim == 1:                expect_resids.shape = (1,)                assert_equal(residuals.shape, expect_resids.shape) else:            expect_resids = np.array([]).view(type(x))        assert_almost_equal(residuals, expect_resids)        assert_(np.issubdtype(residuals.dtype, np.floating))        assert_(consistent_subclass(x, b))        assert_(consistent_subclass(residuals, b))

class TestLstsq(LstsqCases): def test_future_rcond(self):        a = np.array([[0., 1.,  0.,  1.,  2.,  0.],                      [0., 2.,  0.,  0.,  1.,  0.],                      [1., 0.,  1.,  0.,  0.,  4.],                      [0., 0.,  0.,  2.,  3.,  0.]]).T
        b = np.array([1, 0, 0, 0, 0, 0]) with suppress_warnings() as sup:            w = sup.record(FutureWarning, ""`rcond` parameter will change"")            x, residuals, rank, s = linalg.lstsq(a, b)            assert_(rank == 4)            x, residuals, rank, s = linalg.lstsq(a, b, rcond=-1)            assert_(rank == 4)            x, residuals, rank, s = linalg.lstsq(a, b, rcond=None)            assert_(rank == 3) # Warning should be raised exactly once (first command)            assert_(len(w) == 1)
 @pytest.mark.parametrize([""m"", ""n"", ""n_rhs""], [        (4, 2, 2),        (0, 4, 1),        (0, 4, 2),        (4, 0, 1),        (4, 0, 2),        (4, 2, 0),        (0, 0, 0)    ]) def test_empty_a_b(self, m, n, n_rhs):        a = np.arange(m * n).reshape(m, n)        b = np.ones((m, n_rhs))        x, residuals, rank, s = linalg.lstsq(a, b, rcond=None) if m == 0:            assert_((x == 0).all())        assert_equal(x.shape, (n, n_rhs))        assert_equal(residuals.shape, ((n_rhs,) if m > n else (0,))) if m > n and n_rhs > 0: # residuals are exactly the squared norms of b's columns            r = b - np.dot(a, x)            assert_almost_equal(residuals, (r * r).sum(axis=-2))        assert_equal(rank, min(m, n))        assert_equal(s.shape, (min(m, n),))
 def test_incompatible_dims(self): # use modified version of docstring example        x = np.array([0, 1, 2, 3])        y = np.array([-1, 0.2, 0.9, 2.1, 3.3])        A = np.vstack([x, np.ones(len(x))]).T with assert_raises_regex(LinAlgError, ""Incompatible dimensions""):            linalg.lstsq(A, y, rcond=None)

@pytest.mark.parametrize('dt', [np.dtype(c) for c in '?bBhHiIqQefdgFDGO']) class TestMatrixPower(object):
    rshft_0 = np.eye(4)    rshft_1 = rshft_0[[3, 0, 1, 2]]    rshft_2 = rshft_0[[2, 3, 0, 1]]    rshft_3 = rshft_0[[1, 2, 3, 0]]    rshft_all = [rshft_0, rshft_1, rshft_2, rshft_3]    noninv = array([[1, 0], [0, 0]])    stacked = np.block([[[rshft_0]]]*2) #FIXME the 'e' dtype might work in future    dtnoinv = [object, np.dtype('e'), np.dtype('g'), np.dtype('G')]
 def test_large_power(self, dt):        rshft = self.rshft_1.astype(dt)        assert_equal(            matrix_power(rshft, 2**100 + 2**10 + 2**5 + 0), self.rshft_0)        assert_equal(            matrix_power(rshft, 2**100 + 2**10 + 2**5 + 1), self.rshft_1)        assert_equal(            matrix_power(rshft, 2**100 + 2**10 + 2**5 + 2), self.rshft_2)        assert_equal(            matrix_power(rshft, 2**100 + 2**10 + 2**5 + 3), self.rshft_3)
 def test_power_is_zero(self, dt): def tz(M):            mz = matrix_power(M, 0)            assert_equal(mz, identity_like_generalized(M))            assert_equal(mz.dtype, M.dtype)  for mat in self.rshft_all:            tz(mat.astype(dt)) if dt != object:                tz(self.stacked.astype(dt))
 def test_power_is_one(self, dt): def tz(mat):            mz = matrix_power(mat, 1)            assert_equal(mz, mat)            assert_equal(mz.dtype, mat.dtype)
 for mat in self.rshft_all:            tz(mat.astype(dt)) if dt != object:                tz(self.stacked.astype(dt))
 def test_power_is_two(self, dt): def tz(mat):            mz = matrix_power(mat, 2)            mmul = matmul if mat.dtype != object else dot            assert_equal(mz, mmul(mat, mat))            assert_equal(mz.dtype, mat.dtype)
 for mat in self.rshft_all:            tz(mat.astype(dt)) if dt != object:                tz(self.stacked.astype(dt))
 def test_power_is_minus_one(self, dt): def tz(mat):            invmat = matrix_power(mat, -1)            mmul = matmul if mat.dtype != object else dot            assert_almost_equal(                mmul(invmat, mat), identity_like_generalized(mat))
 for mat in self.rshft_all: if dt not in self.dtnoinv:                tz(mat.astype(dt))
 def test_exceptions_bad_power(self, dt):        mat = self.rshft_0.astype(dt)        assert_raises(TypeError, matrix_power, mat, 1.5)        assert_raises(TypeError, matrix_power, mat, [1])
 def test_exceptions_non_square(self, dt):        assert_raises(LinAlgError, matrix_power, np.array([1], dt), 1)        assert_raises(LinAlgError, matrix_power, np.array([[1], [2]], dt), 1)        assert_raises(LinAlgError, matrix_power, np.ones((4, 3, 2), dt), 1)
 def test_exceptions_not_invertible(self, dt): if dt in self.dtnoinv: return        mat = self.noninv.astype(dt)        assert_raises(LinAlgError, matrix_power, mat, -1)


class TestEigvalshCases(HermitianTestCase, HermitianGeneralizedTestCase):
 def do(self, a, b, tags): # note that eigenvalue arrays returned by eig must be sorted since # their order isn't guaranteed.        ev = linalg.eigvalsh(a, 'L')        evalues, evectors = linalg.eig(a)        evalues.sort(axis=-1)        assert_allclose(ev, evalues, rtol=get_rtol(ev.dtype))
        ev2 = linalg.eigvalsh(a, 'U')        assert_allclose(ev2, evalues, rtol=get_rtol(ev.dtype))

class TestEigvalsh(object): @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble]) def test_types(self, dtype):        x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)        w = np.linalg.eigvalsh(x)        assert_equal(w.dtype, get_real_dtype(dtype))
 def test_invalid(self):        x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)        assert_raises(ValueError, np.linalg.eigvalsh, x, UPLO=""lrong"")        assert_raises(ValueError, np.linalg.eigvalsh, x, ""lower"")        assert_raises(ValueError, np.linalg.eigvalsh, x, ""upper"")
 def test_UPLO(self):        Klo = np.array([[0, 0], [1, 0]], dtype=np.double)        Kup = np.array([[0, 1], [0, 0]], dtype=np.double)        tgt = np.array([-1, 1], dtype=np.double)        rtol = get_rtol(np.double)
 # Check default is 'L'        w = np.linalg.eigvalsh(Klo)        assert_allclose(w, tgt, rtol=rtol) # Check 'L'        w = np.linalg.eigvalsh(Klo, UPLO='L')        assert_allclose(w, tgt, rtol=rtol) # Check 'l'        w = np.linalg.eigvalsh(Klo, UPLO='l')        assert_allclose(w, tgt, rtol=rtol) # Check 'U'        w = np.linalg.eigvalsh(Kup, UPLO='U')        assert_allclose(w, tgt, rtol=rtol) # Check 'u'        w = np.linalg.eigvalsh(Kup, UPLO='u')        assert_allclose(w, tgt, rtol=rtol)
 def test_0_size(self): # Check that all kinds of 0-sized arrays work class ArraySubclass(np.ndarray): pass        a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)        res = linalg.eigvalsh(a)        assert_(res.dtype.type is np.float64)        assert_equal((0, 1), res.shape) # This is just for documentation, it might make sense to change:        assert_(isinstance(res, np.ndarray))
        a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)        res = linalg.eigvalsh(a)        assert_(res.dtype.type is np.float32)        assert_equal((0,), res.shape) # This is just for documentation, it might make sense to change:        assert_(isinstance(res, np.ndarray))

class TestEighCases(HermitianTestCase, HermitianGeneralizedTestCase):
 def do(self, a, b, tags): # note that eigenvalue arrays returned by eig must be sorted since # their order isn't guaranteed.        ev, evc = linalg.eigh(a)        evalues, evectors = linalg.eig(a)        evalues.sort(axis=-1)        assert_almost_equal(ev, evalues)
        assert_allclose(dot_generalized(a, evc),                        np.asarray(ev)[..., None, :] * np.asarray(evc), rtol=get_rtol(ev.dtype))
        ev2, evc2 = linalg.eigh(a, 'U')        assert_almost_equal(ev2, evalues)
        assert_allclose(dot_generalized(a, evc2),                        np.asarray(ev2)[..., None, :] * np.asarray(evc2), rtol=get_rtol(ev.dtype), err_msg=repr(a))

class TestEigh(object): @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble]) def test_types(self, dtype):        x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)        w, v = np.linalg.eigh(x)        assert_equal(w.dtype, get_real_dtype(dtype))        assert_equal(v.dtype, dtype)
 def test_invalid(self):        x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)        assert_raises(ValueError, np.linalg.eigh, x, UPLO=""lrong"")        assert_raises(ValueError, np.linalg.eigh, x, ""lower"")        assert_raises(ValueError, np.linalg.eigh, x, ""upper"")
 def test_UPLO(self):        Klo = np.array([[0, 0], [1, 0]], dtype=np.double)        Kup = np.array([[0, 1], [0, 0]], dtype=np.double)        tgt = np.array([-1, 1], dtype=np.double)        rtol = get_rtol(np.double)
 # Check default is 'L'        w, v = np.linalg.eigh(Klo)        assert_allclose(w, tgt, rtol=rtol) # Check 'L'        w, v = np.linalg.eigh(Klo, UPLO='L')        assert_allclose(w, tgt, rtol=rtol) # Check 'l'        w, v = np.linalg.eigh(Klo, UPLO='l')        assert_allclose(w, tgt, rtol=rtol) # Check 'U'        w, v = np.linalg.eigh(Kup, UPLO='U')        assert_allclose(w, tgt, rtol=rtol) # Check 'u'        w, v = np.linalg.eigh(Kup, UPLO='u')        assert_allclose(w, tgt, rtol=rtol)
 def test_0_size(self): # Check that all kinds of 0-sized arrays work class ArraySubclass(np.ndarray): pass        a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)        res, res_v = linalg.eigh(a)        assert_(res_v.dtype.type is np.float64)        assert_(res.dtype.type is np.float64)        assert_equal(a.shape, res_v.shape)        assert_equal((0, 1), res.shape) # This is just for documentation, it might make sense to change:        assert_(isinstance(a, np.ndarray))
        a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)        res, res_v = linalg.eigh(a)        assert_(res_v.dtype.type is np.complex64)        assert_(res.dtype.type is np.float32)        assert_equal(a.shape, res_v.shape)        assert_equal((0,), res.shape) # This is just for documentation, it might make sense to change:        assert_(isinstance(a, np.ndarray))

class _TestNormBase(object):    dt = None    dec = None

class _TestNormGeneral(_TestNormBase):
 def test_empty(self):        assert_equal(norm([]), 0.0)        assert_equal(norm(array([], dtype=self.dt)), 0.0)        assert_equal(norm(atleast_2d(array([], dtype=self.dt))), 0.0)
 def test_vector_return_type(self):        a = np.array([1, 0, 1])
        exact_types = np.typecodes['AllInteger']        inexact_types = np.typecodes['AllFloat']
        all_types = exact_types + inexact_types
 for each_inexact_types in all_types:            at = a.astype(each_inexact_types)
            an = norm(at, -np.inf)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 0.0)
 with suppress_warnings() as sup:                sup.filter(RuntimeWarning, ""divide by zero encountered"")                an = norm(at, -1)                assert_(issubclass(an.dtype.type, np.floating))                assert_almost_equal(an, 0.0)
            an = norm(at, 0)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2)
            an = norm(at, 1)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2.0)
            an = norm(at, 2)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, an.dtype.type(2.0)**an.dtype.type(1.0/2.0))
            an = norm(at, 4)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, an.dtype.type(2.0)**an.dtype.type(1.0/4.0))
            an = norm(at, np.inf)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 1.0)
 def test_vector(self):        a = [1, 2, 3, 4]        b = [-1, -2, -3, -4]        c = [-1, 2, -3, 4]
 def _test(v):            np.testing.assert_almost_equal(norm(v), 30 ** 0.5, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, inf), 4.0, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, -inf), 1.0, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, 1), 10.0, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, -1), 12.0 / 25, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, 2), 30 ** 0.5, decimal=self.dec)            np.testing.assert_almost_equal(norm(v, -2), ((205. / 144) ** -0.5), decimal=self.dec)            np.testing.assert_almost_equal(norm(v, 0), 4, decimal=self.dec)
 for v in (a, b, c,):            _test(v)
 for v in (array(a, dtype=self.dt), array(b, dtype=self.dt),                  array(c, dtype=self.dt)):            _test(v)
 def test_axis(self): # Vector norms. # Compare the use of `axis` with computing the norm of each row # or column separately.        A = array([[1, 2, 3], [4, 5, 6]], dtype=self.dt) for order in [None, -1, 0, 1, 2, 3, np.Inf, -np.Inf]:            expected0 = [norm(A[:, k], ord=order) for k in range(A.shape[1])]            assert_almost_equal(norm(A, ord=order, axis=0), expected0)            expected1 = [norm(A[k, :], ord=order) for k in range(A.shape[0])]            assert_almost_equal(norm(A, ord=order, axis=1), expected1)
 # Matrix norms.        B = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)        nd = B.ndim for order in [None, -2, 2, -1, 1, np.Inf, -np.Inf, 'fro']: for axis in itertools.combinations(range(-nd, nd), 2):                row_axis, col_axis = axis if row_axis < 0:                    row_axis += nd if col_axis < 0:                    col_axis += nd if row_axis == col_axis:                    assert_raises(ValueError, norm, B, ord=order, axis=axis) else:                    n = norm(B, ord=order, axis=axis)
 # The logic using k_index only works for nd = 3. # This has to be changed if nd is increased.                    k_index = nd - (row_axis + col_axis) if row_axis < col_axis:                        expected = [norm(B[:].take(k, axis=k_index), ord=order) for k in range(B.shape[k_index])] else:                        expected = [norm(B[:].take(k, axis=k_index).T, ord=order) for k in range(B.shape[k_index])]                    assert_almost_equal(n, expected)
 def test_keepdims(self):        A = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
        allclose_err = 'order {0}, axis = {1}'        shape_err = 'Shape mismatch found {0}, expected {1}, order={2}, axis={3}'
 # check the order=None, axis=None case        expected = norm(A, ord=None, axis=None)        found = norm(A, ord=None, axis=None, keepdims=True)        assert_allclose(np.squeeze(found), expected, err_msg=allclose_err.format(None, None))        expected_shape = (1, 1, 1)        assert_(found.shape == expected_shape,                shape_err.format(found.shape, expected_shape, None, None))
 # Vector norms. for order in [None, -1, 0, 1, 2, 3, np.Inf, -np.Inf]: for k in range(A.ndim):                expected = norm(A, ord=order, axis=k)                found = norm(A, ord=order, axis=k, keepdims=True)                assert_allclose(np.squeeze(found), expected, err_msg=allclose_err.format(order, k))                expected_shape = list(A.shape)                expected_shape[k] = 1                expected_shape = tuple(expected_shape)                assert_(found.shape == expected_shape,                        shape_err.format(found.shape, expected_shape, order, k))
 # Matrix norms. for order in [None, -2, 2, -1, 1, np.Inf, -np.Inf, 'fro', 'nuc']: for k in itertools.permutations(range(A.ndim), 2):                expected = norm(A, ord=order, axis=k)                found = norm(A, ord=order, axis=k, keepdims=True)                assert_allclose(np.squeeze(found), expected, err_msg=allclose_err.format(order, k))                expected_shape = list(A.shape)                expected_shape[k[0]] = 1                expected_shape[k[1]] = 1                expected_shape = tuple(expected_shape)                assert_(found.shape == expected_shape,                        shape_err.format(found.shape, expected_shape, order, k))

class _TestNorm2D(_TestNormBase): # Define the part for 2d arrays separately, so we can subclass this # and run the tests using np.matrix in matrixlib.tests.test_matrix_linalg.    array = np.array
 def test_matrix_empty(self):        assert_equal(norm(self.array([[]], dtype=self.dt)), 0.0)
 def test_matrix_return_type(self):        a = self.array([[1, 0, 1], [0, 1, 1]])
        exact_types = np.typecodes['AllInteger']
 # float32, complex64, float64, complex128 types are the only types # allowed by `linalg`, which performs the matrix operations used # within `norm`.        inexact_types = 'fdFD'
        all_types = exact_types + inexact_types
 for each_inexact_types in all_types:            at = a.astype(each_inexact_types)
            an = norm(at, -np.inf)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2.0)
 with suppress_warnings() as sup:                sup.filter(RuntimeWarning, ""divide by zero encountered"")                an = norm(at, -1)                assert_(issubclass(an.dtype.type, np.floating))                assert_almost_equal(an, 1.0)
            an = norm(at, 1)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2.0)
            an = norm(at, 2)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 3.0**(1.0/2.0))
            an = norm(at, -2)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 1.0)
            an = norm(at, np.inf)            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2.0)
            an = norm(at, 'fro')            assert_(issubclass(an.dtype.type, np.floating))            assert_almost_equal(an, 2.0)
            an = norm(at, 'nuc')            assert_(issubclass(an.dtype.type, np.floating)) # Lower bar needed to support low precision floats. # They end up being off by 1 in the 7th place.            np.testing.assert_almost_equal(an, 2.7320508075688772, decimal=6)
 def test_matrix_2x2(self):        A = self.array([[1, 3], [5, 7]], dtype=self.dt)        assert_almost_equal(norm(A), 84 ** 0.5)        assert_almost_equal(norm(A, 'fro'), 84 ** 0.5)        assert_almost_equal(norm(A, 'nuc'), 10.0)        assert_almost_equal(norm(A, inf), 12.0)        assert_almost_equal(norm(A, -inf), 4.0)        assert_almost_equal(norm(A, 1), 10.0)        assert_almost_equal(norm(A, -1), 6.0)        assert_almost_equal(norm(A, 2), 9.1231056256176615)        assert_almost_equal(norm(A, -2), 0.87689437438234041)
        assert_raises(ValueError, norm, A, 'nofro')        assert_raises(ValueError, norm, A, -3)        assert_raises(ValueError, norm, A, 0)
 def test_matrix_3x3(self): # This test has been added because the 2x2 example # happened to have equal nuclear norm and induced 1-norm. # The 1/10 scaling factor accommodates the absolute tolerance # used in assert_almost_equal.        A = (1 / 10) * \ self.array([[1, 2, 3], [6, 0, 5], [3, 2, 1]], dtype=self.dt)        assert_almost_equal(norm(A), (1 / 10) * 89 ** 0.5)        assert_almost_equal(norm(A, 'fro'), (1 / 10) * 89 ** 0.5)        assert_almost_equal(norm(A, 'nuc'), 1.3366836911774836)        assert_almost_equal(norm(A, inf), 1.1)        assert_almost_equal(norm(A, -inf), 0.6)        assert_almost_equal(norm(A, 1), 1.0)        assert_almost_equal(norm(A, -1), 0.4)        assert_almost_equal(norm(A, 2), 0.88722940323461277)        assert_almost_equal(norm(A, -2), 0.19456584790481812)
 def test_bad_args(self): # Check that bad arguments raise the appropriate exceptions.
        A = self.array([[1, 2, 3], [4, 5, 6]], dtype=self.dt)        B = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
 # Using `axis=<integer>` or passing in a 1-D array implies vector # norms are being computed, so also using `ord='fro'` # or `ord='nuc'` raises a ValueError.        assert_raises(ValueError, norm, A, 'fro', 0)        assert_raises(ValueError, norm, A, 'nuc', 0)        assert_raises(ValueError, norm, [3, 4], 'fro', None)        assert_raises(ValueError, norm, [3, 4], 'nuc', None)
 # Similarly, norm should raise an exception when ord is any finite # number other than 1, 2, -1 or -2 when computing matrix norms. for order in [0, 3]:            assert_raises(ValueError, norm, A, order, None)            assert_raises(ValueError, norm, A, order, (0, 1))            assert_raises(ValueError, norm, B, order, (1, 2))
 # Invalid axis        assert_raises(np.AxisError, norm, B, None, 3)        assert_raises(np.AxisError, norm, B, None, (2, 3))        assert_raises(ValueError, norm, B, None, (0, 1, 2))

class _TestNorm(_TestNorm2D, _TestNormGeneral): pass

class TestNorm_NonSystematic(object):
 def test_longdouble_norm(self): # Non-regression test: p-norm of longdouble would previously raise # UnboundLocalError.        x = np.arange(10, dtype=np.longdouble)        old_assert_almost_equal(norm(x, ord=3), 12.65, decimal=2)
 def test_intmin(self): # Non-regression test: p-norm of signed integer would previously do # float cast and abs in the wrong order.        x = np.array([-2 ** 31], dtype=np.int32)        old_assert_almost_equal(norm(x, ord=3), 2 ** 31, decimal=5)
 def test_complex_high_ord(self): # gh-4156        d = np.empty((2,), dtype=np.clongdouble)        d[0] = 6 + 7j        d[1] = -6 + 7j        res = 11.615898132184        old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=10)        d = d.astype(np.complex128)        old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=9)        d = d.astype(np.complex64)        old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=5)

# Separate definitions so we can use them for matrix tests.class _TestNormDoubleBase(_TestNormBase):    dt = np.double    dec = 12

class _TestNormSingleBase(_TestNormBase):    dt = np.float32    dec = 6

class _TestNormInt64Base(_TestNormBase):    dt = np.int64    dec = 12

class TestNormDouble(_TestNorm, _TestNormDoubleBase): pass

class TestNormSingle(_TestNorm, _TestNormSingleBase): pass

class TestNormInt64(_TestNorm, _TestNormInt64Base): pass

class TestMatrixRank(object):
 def test_matrix_rank(self): # Full rank matrix        assert_equal(4, matrix_rank(np.eye(4))) # rank deficient matrix        I = np.eye(4)        I[-1, -1] = 0.        assert_equal(matrix_rank(I), 3) # All zeros - zero rank        assert_equal(matrix_rank(np.zeros((4, 4))), 0) # 1 dimension - rank 1 unless all 0        assert_equal(matrix_rank([1, 0, 0, 0]), 1)        assert_equal(matrix_rank(np.zeros((4,))), 0) # accepts array-like        assert_equal(matrix_rank([1]), 1) # greater than 2 dimensions treated as stacked matrices        ms = np.array([I, np.eye(4), np.zeros((4,4))])        assert_equal(matrix_rank(ms), np.array([3, 4, 0])) # works on scalar        assert_equal(matrix_rank(1), 1)
 def test_symmetric_rank(self):        assert_equal(4, matrix_rank(np.eye(4), hermitian=True))        assert_equal(1, matrix_rank(np.ones((4, 4)), hermitian=True))        assert_equal(0, matrix_rank(np.zeros((4, 4)), hermitian=True)) # rank deficient matrix        I = np.eye(4)        I[-1, -1] = 0.        assert_equal(3, matrix_rank(I, hermitian=True)) # manually supplied tolerance        I[-1, -1] = 1e-8        assert_equal(4, matrix_rank(I, hermitian=True, tol=0.99e-8))        assert_equal(3, matrix_rank(I, hermitian=True, tol=1.01e-8))

",,
test_reduced_rank():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
test_byteorder_check():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
test_generalized_raise_multiloop():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
test_xerbla_override():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,,,
test_sdot_bug_8577():,https://github.com//numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py,"    template = textwrap.dedent(    import sys {before}    try:        import {bad_lib}    except ImportError:        sys.exit(0) {after}    x = np.ones(2, dtype=np.float32)    sys.exit(0 if np.allclose(x.dot(x), 2.0) else 1)",,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,None,
_determine_error_states():,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_raise_linalgerror_singular(err, flag):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_raise_linalgerror_nonposdef(err, flag):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_raise_linalgerror_eigenvalues_nonconvergence(err, flag):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_raise_linalgerror_svd_nonconvergence(err, flag):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_raise_linalgerror_lstsq(err, flag):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
get_linalg_error_extobj(callback):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_makearray(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
isComplexType(t):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_realType(t, default=double):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_complexType(t, default=cdouble):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_linalgRealType(t):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py," Cast the type t to either double or cdouble. return double
",,
_commonType(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_to_native_byte_order(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"_fastCopyAndTranspose(type, *arrays):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_assertRank2(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_assertRankAtLeast2(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_assertNdSquareness(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_assertFinite(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_isEmpty2d(arr):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
_assertNoEmpty2d(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
transpose(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Transpose each matrix in a stack of matrices.    Unlike np.transpose, this only swaps the last two axes, rather than all of    them","a : (...,M,N) array_like","aT : (...,N,M) ndarray """""" return swapaxes(a, -1, -2)
# Linear equations
"
"_tensorsolve_dispatcher(a, b, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"tensorsolve(a, b, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Solve the tensor equation ``a x = b`` for x.    It is assumed that all indices of `x` are summed over in the product,    together with the rightmost indices of `a`, as is done in, for example,    ``tensordot(a, x, axes=b.ndim)``.","a : array_like        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals        the shape of that sub-tensor of `a` consisting of the appropriate        number of its rightmost indices, and must be such that        ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be        'square').    b : array_like        Right-hand tensor, which can be of any shape.    axes : tuple of ints, optional        Axes in `a` to reorder to the right, before inversion.        If None (default), no reordering is done.","x : ndarray, shape Q"
"_solve_dispatcher(a, b):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"solve(a, b):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Solve a linear matrix equation, or system of linear scalar equations.    Computes the ""exact"" solution, `x`, of the well-determined, i.e., full    rank, linear matrix equation `ax = b`.","a : (..., M, M) array_like        Coefficient matrix.    b : {(..., M,), (..., M, K)}, array_like        Ordinate or ""dependent variable"" values.","x : {(..., M,), (..., M, K)} ndarray        Solution to the system a x = b.  Returned shape is identical to `b`."
"_tensorinv_dispatcher(a, ind=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"tensorinv(a, ind=2):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the 'inverse' of an N-dimensional array.    The result is an inverse for `a` relative to the tensordot operation    ``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,    ``tensordot(tensorinv(a), a, ind)`` is the ""identity"" tensor for the    tensordot operation.","a : array_like        Tensor to 'invert'. Its shape must be 'square', i. e.,        ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.    ind : int, optional        Number of first indices that are involved in the inverse sum.        Must be a positive integer, default is 2.","b : ndarray        `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``."
_unary_dispatcher(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
inv(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the (multiplicative) inverse of a matrix.    Given a square matrix `a`, return the matrix `ainv` satisfying    ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.","a : (..., M, M) array_like        Matrix to be inverted.","ainv : (..., M, M) ndarray or matrix        (Multiplicative) inverse of the matrix `a`."
"_matrix_power_dispatcher(a, n):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"matrix_power(a, n):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Raise a square matrix to the (integer) power `n`.    For positive integers `n`, the power is computed by repeated matrix    squarings and matrix multiplications. If ``n == 0``, the identity matrix    of the same shape as M is returned. If ``n < 0``, the inverse    is computed and then raised to the ``abs(n)``.    .. note:: Stacks of object matrices are not currently supported.","a : (..., M, M) array_like        Matrix to be ""powered"".    n : int        The exponent can be any integer or long integer, positive,        negative, or zero.","a**n : (..., M, M) ndarray or matrix object        The return value is the same shape and type as `M`;        if the exponent is positive or zero then the type of the        elements is the same as those of `M`. If the exponent is        negative the elements are floating-point."
cholesky(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Cholesky decomposition.    Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,    where `L` is lower-triangular and .H is the conjugate transpose operator    (which is the ordinary transpose if `a` is real-valued).  `a` must be    Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is    actually returned.","a : (..., M, M) array_like        Hermitian (symmetric if all elements are real), positive-definite        input matrix.","L : (..., M, M) array_like        Upper or lower-triangular Cholesky factor of `a`.  Returns a        matrix object if `a` is a matrix object."
"_qr_dispatcher(a, mode=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"qr(a, mode='reduced'):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the qr factorization of a matrix.    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is    upper-triangular.","a : array_like, shape (M, N)        Matrix to be factored.    mode : {'reduced', 'complete', 'r', 'raw', 'full', 'economic'}, optional        If K = min(M, N), then","q : ndarray of float or complex, optional        A matrix with orthonormal columns. When mode = 'complete' the        result is an orthogonal/unitary matrix depending on whether or not        a is real/complex. The determinant may be either +/- 1 in that        case.    r : ndarray of float or complex, optional        The upper-triangular matrix.    (h, tau) : ndarrays of np.double or np.cdouble, optional        The array h contains the Householder reflectors that generate q        along with r. The tau array contains scaling factors for the        reflectors. In the deprecated  'economic' mode only h is returned."
eigvals(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Compute the eigenvalues of a general matrix.    Main difference between `eigvals` and `eig`: the eigenvectors aren't    returned.,"a : (..., M, M) array_like        A complex- or real-valued matrix whose eigenvalues will be computed.","w : (..., M,) ndarray        The eigenvalues, each repeated according to its multiplicity.        They are not necessarily ordered, nor are they necessarily        real for real matrices."
"_eigvalsh_dispatcher(a, UPLO=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"eigvalsh(a, UPLO='L'):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Compute the eigenvalues of a complex Hermitian or real symmetric matrix.    Main difference from eigh: the eigenvectors are not computed.,"a : (..., M, M) array_like        A complex- or real-valued matrix whose eigenvalues are to be        computed.    UPLO : {'L', 'U'}, optional        Specifies whether the calculation is done with the lower triangular        part of `a` ('L', default) or the upper triangular part ('U').        Irrespective of this value only the real parts of the diagonal will        be considered in the computation to preserve the notion of a Hermitian        matrix. It therefore follows that the imaginary part of the diagonal        will always be treated as zero.","w : (..., M,) ndarray        The eigenvalues in ascending order, each repeated according to        its multiplicity."
_convertarray(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
eig(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Compute the eigenvalues and right eigenvectors of a square array.,"a : (..., M, M) array        Matrices for which the eigenvalues and right eigenvectors will        be computed","w : (..., M) array        The eigenvalues, each repeated according to its multiplicity.        The eigenvalues are not necessarily ordered. The resulting        array will be of complex type, unless the imaginary part is        zero in which case it will be cast to a real type. When `a`        is real the resulting eigenvalues will be real (0 imaginary        part) or occur in conjugate pairs"
"eigh(a, UPLO='L'):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Return the eigenvalues and eigenvectors of a complex Hermitian    (conjugate symmetric) or a real symmetric matrix.    Returns two objects, a 1-D array containing the eigenvalues of `a`, and    a 2-D square array or matrix (depending on the input type) of the    corresponding eigenvectors (in columns).","a : (..., M, M) array        Hermitian or real symmetric matrices whose eigenvalues and        eigenvectors are to be computed.    UPLO : {'L', 'U'}, optional        Specifies whether the calculation is done with the lower triangular        part of `a` ('L', default) or the upper triangular part ('U').        Irrespective of this value only the real parts of the diagonal will        be considered in the computation to preserve the notion of a Hermitian        matrix. It therefore follows that the imaginary part of the diagonal        will always be treated as zero.","w : (..., M) ndarray        The eigenvalues in ascending order, each repeated according to        its multiplicity.    v : {(..., M, M) ndarray, (..., M, M) matrix}        The column ``v[:, i]`` is the normalized eigenvector corresponding        to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is        a matrix object."
"_svd_dispatcher(a, full_matrices=None, compute_uv=None, hermitian=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"svd(a, full_matrices=True, compute_uv=True, hermitian=False):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Singular Value Decomposition.    When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh    = (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D    array of `a`'s singular values. When `a` is higher-dimensional, SVD is    applied in stacked mode as explained below.","a : (..., M, N) array_like        A real or complex array with ``a.ndim >= 2``.    full_matrices : bool, optional        If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and        ``(..., N, N)``, respectively.  Otherwise, the shapes are        ``(..., M, K)`` and ``(..., K, N)``, respectively, where        ``K = min(M, N)``.    compute_uv : bool, optional        Whether or not to compute `u` and `vh` in addition to `s`.  True        by default.","u : { (..., M, M), (..., M, K) } array        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same        size as those of the input `a`. The size of the last two dimensions        depends on the value of `full_matrices`. Only returned when        `compute_uv` is True.    s : (..., K) array        Vector(s) with the singular values, within each vector sorted in        descending order. The first ``a.ndim - 2`` dimensions have the same        size as those of the input `a`.    vh : { (..., N, N), (..., K, N) } array        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same        size as those of the input `a`. The size of the last two dimensions        depends on the value of `full_matrices`. Only returned when        `compute_uv` is True.    hermitian : bool, optional        If True, `a` is assumed to be Hermitian (symmetric if real-valued),        enabling a more efficient method for finding singular values.        Defaults to False."
"_cond_dispatcher(x, p=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"cond(x, p=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the condition number of a matrix.    This function is capable of returning the condition number using    one of seven different norms, depending on the value of `p` (see    Parameters below).","x : (..., M, N) array_like        The matrix whose condition number is sought.    p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional        Order of the norm:","c : {float, inf}        The condition number of the matrix. May be infinite."
"_matrix_rank_dispatcher(M, tol=None, hermitian=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"matrix_rank(M, tol=None, hermitian=False):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Return matrix rank of array using SVD method    Rank of the array is the number of singular values of the array that are    greater than `tol`.    .. versionchanged:: 1.14       Can now operate on stacks of matrices,"M : {(M,), (..., M, N)} array_like        Input vector or stack of matrices.    tol : (...) array_like, float, optional        Threshold below which SVD values are considered zero. If `tol` is        None, and ``S`` is an array with singular values for `M`, and        ``eps`` is the epsilon value for datatype of ``S``, then `tol` is        set to ``S.max() * max(M.shape) * eps``.",rank : (...) array_like        Rank of M.
"_pinv_dispatcher(a, rcond=None, hermitian=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"pinv(a, rcond=1e-15, hermitian=False):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Compute the (Moore-Penrose) pseudo-inverse of a matrix.    Calculate the generalized inverse of a matrix using its    singular-value decomposition (SVD) and including all    *large* singular values.    .. versionchanged:: 1.14       Can now operate on stacks of matrices,"a : (..., M, N) array_like        Matrix or stack of matrices to be pseudo-inverted.    rcond : (...) array_like of float        Cutoff for small singular values.        Singular values less than or equal to        ``rcond * largest_singular_value`` are set to zero.        Broadcasts against the stack of matrices.    hermitian : bool, optional        If True, `a` is assumed to be Hermitian (symmetric if real-valued),        enabling a more efficient method for finding singular values.        Defaults to False.","B : (..., N, M) ndarray        The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so        is `B`."
slogdet(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the sign and (natural) logarithm of the determinant of an array.    If an array has a very small or very large determinant, then a call to    `det` may overflow or underflow. This routine is more robust against such    issues, because it computes the logarithm of the determinant rather than    the determinant itself.","a : (..., M, M) array_like        Input array, has to be a square 2-D array.","sign : (...) array_like        A number representing the sign of the determinant. For a real matrix,        this is 1, 0, or -1. For a complex matrix, this is a complex number        with absolute value 1 (i.e., it is on the unit circle), or else 0.    logdet : (...) array_like        The natural log of the absolute value of the determinant."
det(a):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Compute the determinant of an array.,"a : (..., M, M) array_like        Input array to compute determinants for.",det : (...) array_like        Determinant of `a`.
"_lstsq_dispatcher(a, b, rcond=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"lstsq(a, b, rcond=""warn""):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py," r    Return the least-squares solution to a linear matrix equation.    Solves the equation :math:`a x = b` by computing a vector `x` that    minimizes the squared Euclidean 2-norm :math:`\| b - a x \|^2_2`.    The equation may be under-, well-, or over-determined (i.e., the    number of linearly independent rows of `a` can be less than, equal    to, or greater than its number of linearly independent columns).    If `a` is square and of full rank, then `x` (but for round-off error)    is the ""exact"" solution of the equation.","a : (M, N) array_like        ""Coefficient"" matrix.    b : {(M,), (M, K)} array_like        Ordinate or ""dependent variable"" values. If `b` is two-dimensional,        the least-squares solution is calculated for each of the `K` columns        of `b`.    rcond : float, optional        Cut-off ratio for small singular values of `a`.        For the purposes of rank determination, singular values are treated        as zero if they are smaller than `rcond` times the largest singular        value of `a`.","x : {(N,), (N, K)} ndarray        Least-squares solution. If `b` is two-dimensional,        the solutions are in the `K` columns of `x`.    residuals : {(1,), (K,), (0,)} ndarray        Sums of residuals; squared Euclidean 2-norm for each column in        ``b - a*x``.        If the rank of `a` is < N or M <= N, this is an empty array.        If `b` is 1-dimensional, this is a (1,) shape array.        Otherwise the shape is (K,).    rank : int        Rank of matrix `a`.    s : (min(M, N),) ndarray        Singular values of `a`."
"_multi_svd_norm(x, row_axis, col_axis, op):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py, Compute a function of the singular values of the 2-D matrices in `x`.    This is a private utility function used by `numpy.linalg.norm()`.,"x : ndarray    row_axis, col_axis : int        The axes of `x` that hold the 2-D matrices.    op : callable        This should be either numpy.amin or `numpy.amax` or `numpy.sum`.","result : float or ndarray        If `x` is 2-D, the return values is a float.        Otherwise, it is an array with ``x.ndim - 2`` dimensions.        The return values are either the minimum or maximum or sum of the        singular values of the matrices, depending on whether `op`        is `numpy.amin` or `numpy.amax` or `numpy.sum`."
"_norm_dispatcher(x, ord=None, axis=None, keepdims=None):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
"norm(x, ord=None, axis=None, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Matrix or vector norm.    This function is able to return one of eight different matrix norms,    or one of an infinite number of vector norms (described below), depending    on the value of the ``ord`` parameter.","x : array_like        Input array.  If `axis` is None, `x` must be 1-D or 2-D.    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional        Order of the norm (see table under ``Notes``). inf means numpy's        `inf` object.    axis : {int, 2-tuple of ints, None}, optional        If `axis` is an integer, it specifies the axis of `x` along which to        compute the vector norms.  If `axis` is a 2-tuple, it specifies the        axes that hold 2-D matrices, and the matrix norms of these matrices        are computed.  If `axis` is None then either a vector norm (when `x`        is 1-D) or a matrix norm (when `x` is 2-D) is returned.",n : float or ndarray        Norm of the matrix or vector(s).
_multidot_dispatcher(arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,,,
multi_dot(arrays):,https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Compute the dot product of two or more arrays in a single function call,    while automatically selecting the fastest evaluation order.    `multi_dot` chains `numpy.dot` and uses optimal parenthesization    of the matrices [1]_ [2]_. Depending on the shapes of the matrices,    this can speed up the multiplication a lot.    If the first argument is 1-D it is treated as a row vector.    If the last argument is 1-D it is treated as a column vector.    The other arguments must be 2-D.    Think of `multi_dot` as::        def multi_dot(arrays): return functools.reduce(np.dot, arrays)",arrays : sequence of array_like        If the first argument is 1-D it is treated as row vector.        If the last argument is 1-D it is treated as column vector.        The other arguments must be 2-D.,output : ndarray        Returns the dot product of the supplied arrays.
"_multi_dot_three(A, B, C):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,     Find the best order for three arrays and do the multiplication.    For three arguments `_multi_dot_three` is approximately 15 times faster    than `_multi_dot_matrix_chain_order`,,
"_multi_dot_matrix_chain_order(arrays, return_costs=False):",https://github.com//numpy/numpy/blob/master/numpy/linalg/linalg.py,"     Return a np.array that encodes the optimal order of mutiplications.    The optimal order array is then used by `_multi_dot()` to do the    multiplication.    Also return the cost matrix if `return_costs` is `True`    The implementation CLOSELY follows Cormen, ""Introduction to Algorithms"",    Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.        cost[i, j] = min([            cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)            for k in range(i, j)])",,
,https://github.com//numpy/numpy/blob/master/numpy/linalg/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,Tests suite for MaskedArray & subclassing.:author: Pierre Gerard-Marchant:contact: pierregm_at_uga_dot_edu,,
test_masked_array():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_append_masked_array():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_append_masked_array_along_axis():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_default_fill_value_complex():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_ufunc_with_output():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_ufunc_with_out_varied():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,"  Test that masked arrays are immune to gh-10459  # the mask of the output should not affect the result, however it is passed    a        = array([ 1,  2,  3], mask=[1, 0, 0])    b        = array([10, 20, 30], mask=[1, 0, 0])    out      = array([ 0,  0,  0], mask=[0, 0, 1])    expected = array([11, 22, 33], mask=[1, 0, 0])
    out_pos = out.copy()    res_pos = np.add(a, b, out_pos)
    out_kw = out.copy()    res_kw = np.add(a, b, out=out_kw)
    out_tup = out.copy()    res_tup = np.add(a, b, out=(out_tup,))
    assert_equal(res_kw.mask,  expected.mask)    assert_equal(res_kw.data,  expected.data)    assert_equal(res_tup.mask, expected.mask)    assert_equal(res_tup.data, expected.data)    assert_equal(res_pos.mask, expected.mask)    assert_equal(res_pos.data, expected.data)

",,
test_astype_mask_ordering():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
"test_astype_basic(dt1, dt2):",https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
test_fieldless_void():,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_core.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_mrecords.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_old_ma.py,,,
"eq(v, w, msg=''):",https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_old_ma.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/tests/test_subclassing.py,Tests suite for MaskedArray & subclassing.:author: Pierre Gerard-Marchant:contact: pierregm_at_uga_dot_edu:version: $Id: test_subclassing.py 3473 2007-10-29 15:18:13Z jarrod.millman $,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/bench.py,,,
"timer(s, v='', nloop=500, nrep=3):",https://github.com//numpy/numpy/blob/master/numpy/ma/bench.py,,,
"compare_functions_1v(func, nloop=500,",https://github.com//numpy/numpy/blob/master/numpy/ma/bench.py,,,
"compare_methods(methodname, args, vars='x', nloop=500, test=True,",https://github.com//numpy/numpy/blob/master/numpy/ma/bench.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"numpy.ma : a package to handle missing or invalid values.This package was initially written for numarray by Paul F. Duboisat Lawrence Livermore National Laboratory.In 2006, the package was completely rewritten by Pierre Gerard-Marchant(University of Georgia) to make the MaskedArray class a subclass of ndarray,and to improve support of structured arrays.Copyright 1999, 2000, 2001 Regents of the University of California.Released for unlimited redistribution.* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant  (pgmdevlist_AT_gmail_DOT_com)* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com).. moduleauthor:: Pierre Gerard-Marchant",,
_deprecate_argsort_axis(arr):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Adjust the axis passed to argsort, warning if necessary",arr        The array which argsort was called on,
"doc_note(initialdoc, note):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Adds a Notes section to an existing docstring.,,
get_object_signature(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Get the signature from obj,,
"_recursive_fill_value(dtype, f):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Recursively produce a fill value for `dtype`, calling f on scalar dtypes",,
_get_dtype_of(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"  Convert the argument for *_fill_value into a dtype  if isinstance(obj, np.dtype): return obj elif hasattr(obj, 'dtype'): return obj.dtype else: return np.asanyarray(obj).dtype

",,
default_fill_value(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the default fill value for the argument object.    The default filling value depends on the datatype of the input    array or the type of the input scalar:       ========  ========       datatype  default       ========  ========       bool      True       int       999999       float     1.e20       complex   1.e20+0j       object    '?'       string    'N/A'       ========  ========    For structured types, a structured scalar is returned, with each field the    default fill value for its type.    For subarray types, the fill value is an array of the same size containing    the default scalar fill value.","obj : ndarray, dtype or scalar        The array data-type or scalar for which the default fill value        is returned.",fill_value : scalar        The default fill value.
"_extremum_fill_value(obj, extremum, extremum_name):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
minimum_fill_value(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Return the maximum value that can be represented by the dtype of an object.    This function is useful for calculating a fill value suitable for    taking the minimum of an array with a given dtype.,"obj : ndarray, dtype or scalar        An object that can be queried for it's numeric type.",val : scalar        The maximum representable value.
maximum_fill_value(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Return the minimum value that can be represented by the dtype of an object.    This function is useful for calculating a fill value suitable for    taking the maximum of an array with a given dtype.,"obj : ndarray, dtype or scalar        An object that can be queried for it's numeric type.",val : scalar        The minimum representable value.
"_recursive_set_fill_value(fillvalue, dt):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Create a fill value for a structured dtype.,"fillvalue: scalar or array_like        Scalar or array representing the fill value. If it is of shorter        length than the number of fields in dt, it will be resized.    dt: dtype        The structured dtype for which to create the fill value.",val: tuple        A tuple of values corresponding to the structured fill value.
"_check_fill_value(fill_value, ndtype):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Private function validating the given `fill_value` for the given dtype.    If fill_value is None, it is set to the default corresponding to the dtype.    If fill_value is not None, its value is forced to the given dtype.    The result is always a 0d array.",,
"set_fill_value(a, fill_value):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Set the filling value of a, if a is a masked array.    This function changes the fill value of the masked array `a` in place.    If `a` is not a masked array, the function returns silently, without    doing anything.",a : array_like        Input array.    fill_value : dtype        Filling value. A consistency test is performed to make sure        the value is compatible with the dtype of `a`.,None        Nothing returned by this function.
get_fill_value(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the filling value of a, if any.  Otherwise, returns the    default filling value for that type.",,
"common_fill_value(a, b):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the common filling value of two masked arrays, if any.    If ``a.fill_value == b.fill_value``, return the fill value,    otherwise return None.","a, b : MaskedArray        The masked arrays for which to compare fill values.","fill_value : scalar or None        The common fill value, or None."
"filled(a, fill_value=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return input as an array with masked data replaced by a fill value.    If `a` is not a `MaskedArray`, `a` itself is returned.    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to    ``a.fill_value``.","a : MaskedArray or array_like        An input object.    fill_value : scalar, optional        Filling value. Default is None.",a : ndarray        The filled array.
get_masked_subclass(*arrays):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the youngest subclass of MaskedArray from a list of (masked) arrays.    In case of siblings, the first listed takes over.",,
"getdata(a, subok=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the data of a masked array as an ndarray.    Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,    else return `a` as a ndarray or subclass (depending on `subok`) if not.","a : array_like        Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.    subok : bool        Whether to force the output to be a `pure` ndarray (False) or to        return a subclass of ndarray if appropriate (True, default).",
"fix_invalid(a, mask=nomask, copy=True, fill_value=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return input with invalid data masked and replaced by a fill value.    Invalid data means values of `nan`, `inf`, etc.","a : array_like        Input array, a (subclass of) ndarray.    mask : sequence, optional        Mask. Must be convertible to an array of booleans with the same        shape as `data`. True indicates a masked (i.e. invalid) data.    copy : bool, optional        Whether to use a copy of `a` (True) or to fix `a` in place (False).        Default is True.    fill_value : scalar, optional        Value used for fixing invalid data. Default is None, in which case        the ``a.fill_value`` is used.",b : MaskedArray        The input array with invalid entries fixed.
is_string_or_list_of_strings(val):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Define a valid interval, so that :    ``domain_check_interval(a,b)(x) == True`` where    ``x < a`` or ``x > b``.","mufunc : callable        The function for which to define a masked version. Made available        as ``_MaskedUnaryOperation.f``.    fill : scalar, optional        Filling value, default is 0.    domain : class instance        Domain for the function. Should be one of the ``_Domain*``        classes. Default is None.mbfunc : function        The function for which to define a masked version. Made available        as ``_MaskedBinaryOperation.f``.    domain : class instance        Default domain for the function. Should be one of the ``_Domain*``        classes. Default is None.    fillx : scalar, optional        Filling value for the first argument, default is 0.    filly : scalar, optional        Filling value for the second argument, default is 0.mbfunc : function        The function for which to define a masked version. Made available        as ``_DomainedBinaryOperation.f``.    domain : class instance        Default domain for the function. Should be one of the ``_Domain*``        classes.    fillx : scalar, optional        Filling value for the first argument, default is 0.    filly : scalar, optional        Filling value for the second argument, default is 0.",
"_replace_dtype_fields_recursive(dtype, primitive_dtype):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"_replace_dtype_fields(dtype, primitive_dtype):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Construct a dtype description list from a given dtype.    Returns a new dtype object, with all fields and subtypes in the given type    recursively replaced with `primitive_dtype`.    Arguments are coerced to dtypes first.",,
make_mask_descr(ndtype):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Construct a dtype description list from a given dtype.    Returns a new dtype object, with the type of all fields in `ndtype` to a    boolean type. Field names are not altered.",ndtype : dtype        The dtype to convert.,"result : dtype        A dtype that looks like `ndtype`, the type of all fields is boolean."
getmask(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the mask of a masked array, or nomask.    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the    mask is not `nomask`, else return `nomask`. To guarantee a full array    of booleans of the same shape as a, use `getmaskarray`.",a : array_like        Input `MaskedArray` for which the mask is required.,
getmaskarray(arr):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the mask of a masked array, or full boolean array of False.    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and    the mask is not `nomask`, else return a full boolean array of False of    the same shape as `arr`.",arr : array_like        Input `MaskedArray` for which the mask is required.,
is_mask(m):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return True if m is a valid, standard mask.    This function does not check the contents of the input, only that the    type is MaskType. In particular, this function returns False if the    mask has a flexible dtype.",m : array_like        Array to test.,"result : bool        True if `m.dtype.type` is MaskType, False otherwise."
_shrink_mask(m):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Shrink a mask to nomask if possible,,
"make_mask(m, copy=False, shrink=True, dtype=MaskType):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Create a boolean mask from an array.    Return `m` as a boolean mask, creating a copy if necessary or requested.    The function can accept any sequence that is convertible to integers,    or ``nomask``.  Does not require that contents must be 0s and 1s, values    of 0 are interepreted as False, everything else as True.","m : array_like        Potential mask.    copy : bool, optional        Whether to return a copy of `m` (True) or `m` itself (False).    shrink : bool, optional        Whether to shrink `m` to ``nomask`` if all its values are False.    dtype : dtype, optional        Data-type of the output mask. By default, the output mask has a        dtype of MaskType (bool). If the dtype is flexible, each field has        a boolean dtype. This is ignored when `m` is ``nomask``, in which        case ``nomask`` is always returned.",result : ndarray        A boolean mask derived from `m`.
"make_mask_none(newshape, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return a boolean mask of the given shape, filled with False.    This function returns a boolean ndarray with all entries False, that can    be used in common mask manipulations. If a complex dtype is specified, the    type of each field is converted to a boolean type.","newshape : tuple        A tuple indicating the shape of the mask.    dtype : {None, dtype}, optional        If None, use a MaskType instance. Otherwise, use a new datatype with        the same fields as `dtype`, converted to boolean types.","result : ndarray        An ndarray of appropriate shape and dtype, filled with False."
"mask_or(m1, m2, copy=False, shrink=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Combine two masks with the ``logical_or`` operator.    The result may be a view on `m1` or `m2` if the other is `nomask`    (i.e. False).,"m1, m2 : array_like        Input masks.    copy : bool, optional        If copy is False and one of the inputs is `nomask`, return a view        of the other input mask. Defaults to False.    shrink : bool, optional        Whether to shrink the output to `nomask` if all its values are        False. Defaults to True.",mask : output mask        The result masks values that are masked in either `m1` or `m2`.
flatten_mask(mask):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Returns a completely flattened version of the mask, where nested fields    are collapsed.","mask : array_like        Input array, which will be interpreted as booleans.",flattened_mask : ndarray of bools        The flattened input.
"_check_mask_axis(mask, axis, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"masked_where(condition, a, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Mask an array where a condition is met.    Return `a` as an array masked where `condition` is True.    Any masked values of `a` or `condition` are also masked in the output.,"condition : array_like        Masking condition.  When `condition` tests floating point values for        equality, consider using ``masked_values`` instead.    a : array_like        Array to mask.    copy : bool        If True (default) make a copy of `a` in the result.  If False modify        `a` in place and return a view.",result : MaskedArray        The result of masking `a` where `condition` is True.
"masked_greater(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where greater than a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x > value).    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_greater(a, 2)    masked_array(data=[0, 1, 2, --],                 mask=[False, False, False,  True],           fill_value=999999)",,
"masked_greater_equal(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where greater than or equal to a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x >= value).    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_greater_equal(a, 2)    masked_array(data=[0, 1, --, --],                 mask=[False, False,  True,  True],           fill_value=999999)",,
"masked_less(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where less than a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x < value).    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_less(a, 2)    masked_array(data=[--, --, 2, 3],                 mask=[ True,  True, False, False],           fill_value=999999)",,
"masked_less_equal(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where less than or equal to a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x <= value).    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_less_equal(a, 2)    masked_array(data=[--, --, --, 3],                 mask=[ True,  True,  True, False],           fill_value=999999)",,
"masked_not_equal(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where `not` equal to a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x != value).    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_not_equal(a, 2)    masked_array(data=[--, --, 2, --],                 mask=[ True,  True, False,  True],           fill_value=999999)",,
"masked_equal(x, value, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where equal to a given value.    This function is a shortcut to ``masked_where``, with    `condition` = (x == value).  For floating point arrays,    consider using ``masked_values(x, value)``.    See Also    --------    masked_where : Mask where a condition is met.    masked_values : Mask using floating point equality.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(4) >>> a    array([0, 1, 2, 3]) >>> ma.masked_equal(a, 2)    masked_array(data=[0, 1, --, 3],                 mask=[False, False,  True, False],           fill_value=2)",,
"masked_inside(x, v1, v2, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array inside a given interval.    Shortcut to ``masked_where``, where `condition` is True for `x` inside    the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`    can be given in either order.    See Also    --------    masked_where : Mask where a condition is met.    Notes    -----    The array `x` is prefilled with its filling value.    Examples    -------- >>> import numpy.ma as ma >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1] >>> ma.masked_inside(x, -0.3, 0.3)    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],                 mask=[False, False,  True,  True, False, False],           fill_value=1e+20)    The order of `v1` and `v2` doesn't matter. >>> ma.masked_inside(x, 0.3, -0.3)    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],                 mask=[False, False,  True,  True, False, False],           fill_value=1e+20)",,
"masked_outside(x, v1, v2, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array outside a given interval.    Shortcut to ``masked_where``, where `condition` is True for `x` outside    the interval [v1,v2] (x < v1)|(x > v2).    The boundaries `v1` and `v2` can be given in either order.    See Also    --------    masked_where : Mask where a condition is met.    Notes    -----    The array `x` is prefilled with its filling value.    Examples    -------- >>> import numpy.ma as ma >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1] >>> ma.masked_outside(x, -0.3, 0.3)    masked_array(data=[--, --, 0.01, 0.2, --, --],                 mask=[ True,  True, False, False,  True,  True],           fill_value=1e+20)    The order of `v1` and `v2` doesn't matter. >>> ma.masked_outside(x, 0.3, -0.3)    masked_array(data=[--, --, 0.01, 0.2, --, --],                 mask=[ True,  True, False, False,  True,  True],           fill_value=1e+20)",,
"masked_object(x, value, copy=True, shrink=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask the array `x` where the data are exactly equal to value.    This function is similar to `masked_values`, but only suitable    for object arrays: for floating point, use `masked_values` instead.","x : array_like        Array to mask    value : object        Comparison value    copy : {True, False}, optional        Whether to return a copy of `x`.    shrink : {True, False}, optional        Whether to collapse a mask full of False to nomask",result : MaskedArray        The result of masking `x` where equal to `value`.
"masked_values(x, value, rtol=1e-5, atol=1e-8, copy=True, shrink=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask using floating point equality.    Return a MaskedArray, masked where the data in array `x` are approximately    equal to `value`, determined using `isclose`. The default tolerances for    `masked_values` are the same as those for `isclose`.    For integer types, exact equality is used, in the same way as    `masked_equal`.    The fill_value is set to `value` and the mask is set to ``nomask`` if    possible.","x : array_like        Array to mask.    value : float        Masking value.    rtol, atol : float, optional        Tolerance parameters passed on to `isclose`    copy : bool, optional        Whether to return a copy of `x`.    shrink : bool, optional        Whether to collapse a mask full of False to ``nomask``.",result : MaskedArray        The result of masking `x` where approximately equal to `value`.
"masked_invalid(a, copy=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask an array where invalid values occur (NaNs or infs).    This function is a shortcut to ``masked_where``, with    `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.    Only applies to arrays with a dtype where NaNs or infs make sense    (i.e. floating point types), but accepts any array_like object.    See Also    --------    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.arange(5, dtype=float) >>> a[2] = np.NaN >>> a[3] = np.PINF >>> a    array([ 0.,  1., nan, inf,  4.]) >>> ma.masked_invalid(a)    masked_array(data=[0.0, 1.0, --, --, 4.0],                 mask=[False, False,  True,  True, False],           fill_value=1e+20)",,
"_recursive_printoption(result, mask, printopt):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Puts printoptions in result where mask is True.    Private function allowing for recursion,,
"_recursive_filled(a, mask, fill_value):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Recursively fill `a` with `fill_value`.,,
flatten_structured_array(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Flatten a structured array.    The data type of the output is chosen such that it can represent all of the    (nested) fields.,a : structured array,"output : masked array or ndarray        A flattened masked array if the input is a masked array, otherwise a        standard ndarray."
"_arraymethod(funcname, onmask=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return a class method wrapper around a basic array method.    Creates a class method which returns a masked array, where the new    ``_data`` array is the output of the corresponding basic method called    on the original ``_data``.    If `onmask` is True, the new mask is the output of the method called    on the initial mask. Otherwise, the new mask is just a reference    to the initial mask.","funcname : str        Name of the function to apply on data.    onmask : bool        Whether the mask must be processed also (True) or left        alone (False). Default is True. Make available as `_onmask`        attribute.data : array_like        Input data.    mask : sequence, optional        Mask. Must be convertible to an array of booleans with the same        shape as `data`. True indicates a masked (i.e. invalid) data.    dtype : dtype, optional        Data type of the output.        If `dtype` is None, the type of the data argument (``data.dtype``)        is used. If `dtype` is not None and different from ``data.dtype``,        a copy is performed.    copy : bool, optional        Whether to copy the input data (True), or to use a reference instead.        Default is False.    subok : bool, optional        Whether to return a subclass of `MaskedArray` if possible (True) or a        plain `MaskedArray`. Default is True.    ndmin : int, optional        Minimum number of dimensions. Default is 0.    fill_value : scalar, optional        Value used to fill in the masked values when necessary.        If None, a default based on the data-type is used.    keep_mask : bool, optional        Whether to combine `mask` with the mask of the input data, if any        (True), or to use only `mask` for the output (False). Default is True.    hard_mask : bool, optional        Whether to use a hard mask or not. With a hard mask, masked values        cannot be unmasked. Default is False.    shrink : bool, optional        Whether to force compression of an empty mask. Default is True.    order : {'C', 'F', 'A'}, optional        Specify the order of the array.  If order is 'C', then the array        will be in C-contiguous order (last-index varies the fastest).        If order is 'F', then the returned array will be in        Fortran-contiguous order (first-index varies the fastest).        If order is 'A' (default), then the returned array may be        in any order (either C-, Fortran-contiguous, or even discontiguous),        unless a copy is required, in which case it will be C-contiguous.",method : instancemethod        Class method wrapper of the specified basic array method.
"_mareconstruct(subtype, baseclass, baseshape, basetype,):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py, Internal function that builds a new MaskedArray from the    information stored in a pickle.,,"returned_tuple        Tuple of fields """"""        _mask = self._mask if _mask is nomask: return self._data.tolist()        result = [] for (d, m) in zip(self._data, self._mask): if m:                result.append(None) else: # .item() makes sure we return a standard Python object                result.append(d.item()) return tuple(result)

###############################################################################                                Shortcuts                                   ###############################################################################

"
isMaskedArray(x):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Test whether input is an instance of MaskedArray.    This function returns True if `x` is an instance of MaskedArray    and returns False otherwise.  Any object is accepted as input.,x : object        Object to test.,result : bool        True if `x` is a MaskedArray.
"array(data, dtype=None, copy=False, order=None,",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Shortcut to MaskedArray.    The options are in a different order for convenience and backwards    compatibility.,,
is_masked(x):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Determine whether input has masked values.    Accepts any object as input, but always returns False unless the    input is a MaskedArray containing masked values.",x : array_like        Array to check for masked values.,"result : bool        True if `x` is a MaskedArray with masked values, False otherwise."
"min(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"max(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"ptp(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Define functions from existing MaskedArray methods.,methodname : str        Name of the method to transform.,
"take(a, indices, axis=None, out=None, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py, ,,
"power(a, b, third=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Returns element-wise base array raised to power from second array.    This is the masked array version of `numpy.power`. For details see    `numpy.power`.    See Also    --------    numpy.power    Notes    -----    The *out* argument to `numpy.power` is not supported, `third` has to be    None.",,
"argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True, fill_value=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
compressed(x):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return all the non-masked data as a 1-D array.    This function is equivalent to calling the ""compressed"" method of a    `MaskedArray`, see `MaskedArray.compressed` for details.    See Also    --------    MaskedArray.compressed        Equivalent method.",,
"concatenate(arrays, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Concatenate a sequence of arrays along the given axis.,"arrays : sequence of array_like        The arrays must have the same shape, except in the dimension        corresponding to `axis` (the first, by default).    axis : int, optional        The axis along which the arrays will be joined. Default is 0.",result : MaskedArray        The concatenated array with any masked entries preserved.
"diag(v, k=0):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Extract a diagonal or construct a diagonal array.    This function is the equivalent of `numpy.diag` that takes masked    values into account, see `numpy.diag` for details.    See Also    --------    numpy.diag : Equivalent function for ndarrays.",,
"left_shift(a, n):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Shift the bits of an integer to the left.    This is the masked array version of `numpy.left_shift`, for details    see that function.    See Also    --------    numpy.left_shift",,
"right_shift(a, n):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Shift the bits of an integer to the right.    This is the masked array version of `numpy.right_shift`, for details    see that function.    See Also    --------    numpy.right_shift",,
"put(a, indices, values, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Set storage-indexed locations to corresponding values.    This function is equivalent to `MaskedArray.put`, see that method    for details.    See Also    --------    MaskedArray.put",,
"putmask(a, mask, values):  # , mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Changes elements of an array based on conditional and input values.    This is the masked array version of `numpy.putmask`, for details see    `numpy.putmask`.    See Also    --------    numpy.putmask    Notes    -----    Using a masked array as `values` will **not** transform a `ndarray` into    a `MaskedArray`.",,
"transpose(a, axes=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Permute the dimensions of an array.    This function is exactly equivalent to `numpy.transpose`.    See Also    --------    numpy.transpose : Equivalent function in top-level NumPy module.    Examples    -------- >>> import numpy.ma as ma >>> x = ma.arange(4).reshape((2,2)) >>> x[1, 1] = ma.masked >>> x    masked_array(      data=[[0, 1],            [2, --]],      mask=[[False, False],            [False,  True]],      fill_value=999999) >>> ma.transpose(x)    masked_array(      data=[[0, 2],            [1, --]],      mask=[[False, False],            [False,  True]],      fill_value=999999)",,
"reshape(a, new_shape, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Returns an array containing the same data with a new shape.    Refer to `MaskedArray.reshape` for full documentation.    See Also    --------    MaskedArray.reshape : equivalent function,,
"resize(x, new_shape):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return a new masked array with the specified size and shape.    This is the masked equivalent of the `numpy.resize` function. The new    array is filled with repeated copies of `x` (in the order that the    data are stored in memory). If `x` is masked, the new array will be    masked, and the new mask will be a repetition of the old one.    See Also    --------    numpy.resize : Equivalent function in the top level NumPy module.    Examples    -------- >>> import numpy.ma as ma >>> a = ma.array([[1, 2] ,[3, 4]]) >>> a[0, 1] = ma.masked >>> a    masked_array(      data=[[1, --],            [3, 4]],      mask=[[False,  True],            [False, False]],      fill_value=999999) >>> np.resize(a, (3, 3))    masked_array(      data=[[1, 2, 3],            [4, 1, 2],            [3, 4, 1]],      mask=False,      fill_value=999999) >>> ma.resize(a, (3, 3))    masked_array(      data=[[1, --, 3],            [4, 1, --],            [3, 4, 1]],      mask=[[False,  True, False],            [False, False,  True],            [False, False, False]],      fill_value=999999)    A MaskedArray is always returned, regardless of the input type. >>> a = np.array([[1, 2] ,[3, 4]]) >>> ma.resize(a, (3, 3))    masked_array(      data=[[1, 2, 3],            [4, 1, 2],            [3, 4, 1]],      mask=False,      fill_value=999999)",,
rank(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     maskedarray version of the numpy function.    .. note::        Deprecated since 1.10.0,,
ndim(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     maskedarray version of the numpy function.,,
shape(obj):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"size(obj, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"where(condition, x=_NoValue, y=_NoValue):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return a masked array with elements from `x` or `y`, depending on condition.    .. note::        When only `condition` is provided, this function is identical to        `nonzero`. The rest of this documentation covers only the case where        all three arguments are provided.","condition : array_like, bool        Where True, yield `x`, otherwise yield `y`.    x, y : array_like, optional        Values from which to choose. `x`, `y` and `condition` need to be        broadcastable to some shape.","out : MaskedArray        An masked array with `masked` elements where the condition is masked,        elements from `x` where `condition` is True, and elements from `y`        elsewhere."
"choose(indices, choices, out=None, mode='raise'):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Use an index array to construct a new array from a set of choices.    Given an array of integers and a set of n choice arrays, this method    will create a new array that merges each of the choice arrays.  Where a    value in `a` is i, the new array will have the value that choices[i]    contains in the same place.","a : ndarray of ints        This array must contain integers in ``[0, n-1]``, where n is the        number of choices.    choices : sequence of arrays        Choice arrays. The index array and all of the choices should be        broadcastable to the same shape.    out : array, optional        If provided, the result will be inserted into this array. It should        be of the appropriate shape and `dtype`.    mode : {'raise', 'wrap', 'clip'}, optional        Specifies how out-of-bounds indices will behave.",merged_array : array
"round_(a, decimals=0, out=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return a copy of a, rounded to 'decimals' places.    When 'decimals' is negative, it specifies the number of positions    to the left of the decimal point.  The real and imaginary parts of    complex numbers are rounded separately. Nothing is done if the    array is not of float type and 'decimals' is greater than or equal    to 0.","decimals : int        Number of decimals to round to. May be negative.    out : array_like        Existing array to use for output.        If not given, returns a default copy of a.",
"mask_rowcols(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Mask rows and/or columns of a 2D array that contain masked values.    Mask whole rows and/or columns of a 2D array that contain    masked values.  The masking behavior is selected using the    `axis` parameter.      - If `axis` is None, rows *and* columns are masked.      - If `axis` is 0, only rows are masked.      - If `axis` is 1 or -1, only columns are masked.","a : array_like, MaskedArray        The array to mask.  If not a MaskedArray instance (or if no array        elements are masked).  The result is a MaskedArray with `mask` set        to `nomask` (False). Must be a 2D array.    axis : int, optional        Axis along which to perform the operation. If None, applies to a        flattened version of the array.","a : MaskedArray        A modified version of the input array, masked depending on the value        of the `axis` parameter."
"dot(a, b, strict=False, out=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return the dot product of two arrays.    This function is the equivalent of `numpy.dot` that takes masked values    into account. Note that `strict` and `out` are in different position    than in the method version. In order to maintain compatibility with the    corresponding method, it is recommended that the optional arguments be    treated as keyword only.  At some point that may be mandatory.    .. note::      Works only with 2-D arrays at the moment.","a, b : masked_array_like        Inputs arrays.    strict : bool, optional        Whether masked data are propagated (True) or set to 0 (False) for        the computation. Default is False.  Propagating the mask means that        if a masked value appears in a row or column, the whole row or        column is considered masked.    out : masked_array, optional        Output argument. This must have the exact kind that would be returned        if it was not used. In particular, it must have the right type, must be        C-contiguous, and its dtype must be the dtype that would be returned        for `dot(a,b)`. This is a performance feature. Therefore, if these        conditions are not met, an exception is raised, instead of attempting        to be flexible.",
"inner(a, b):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Returns the inner product of a and b for arrays of floating point types.    Like the generic NumPy equivalent the product sum is over the last dimension    of a and b. The first argument is not conjugated.,,
"outer(a, b):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"_convolve_or_correlate(f, a, v, mode, propagate_mask):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Helper function for ma.correlate and ma.convolve,,
"correlate(a, v, mode='valid', propagate_mask=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Cross-correlation of two 1-dimensional sequences.,"a, v : array_like        Input sequences.    mode : {'valid', 'same', 'full'}, optional        Refer to the `np.convolve` docstring.  Note that the default        is 'valid', unlike `convolve`, which uses 'full'.    propagate_mask : bool        If True, then a result element is masked if any masked element contributes towards it.        If False, then a result element is only masked if no non-masked element        contribute towards it",out : MaskedArray        Discrete cross-correlation of `a` and `v`.
"convolve(a, v, mode='full', propagate_mask=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Returns the discrete, linear convolution of two one-dimensional sequences.","a, v : array_like        Input sequences.    mode : {'valid', 'same', 'full'}, optional        Refer to the `np.convolve` docstring.    propagate_mask : bool        If True, then if any masked element is included in the sum for a result        element, then the result is masked.        If False, then the result element is only masked if no non-masked cells        contribute towards it","out : MaskedArray        Discrete, linear convolution of `a` and `v`."
"allequal(a, b, fill_value=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Return True if all entries of a and b are equal, using    fill_value as a truth value where either or both are masked.","a, b : array_like        Input arrays to compare.    fill_value : bool, optional        Whether masked values in a or b are considered equal (True) or not        (False).","y : bool        Returns True if the two arrays are equal within the given        tolerance, False otherwise. If either array contains NaN,        then False is returned."
"allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Returns True if two arrays are element-wise equal within a tolerance.    This function is equivalent to `allclose` except that masked values    are treated as equal (default) or unequal, depending on the `masked_equal`    argument.","a, b : array_like        Input arrays to compare.    masked_equal : bool, optional        Whether masked values in `a` and `b` are considered equal (True) or not        (False). They are considered equal by default.    rtol : float, optional        Relative tolerance. The relative difference is equal to ``rtol * b``.        Default is 1e-5.    atol : float, optional        Absolute tolerance. The absolute difference is equal to `atol`.        Default is 1e-8.","y : bool        Returns True if the two arrays are equal within the given        tolerance, False otherwise. If either array contains NaN, then        False is returned."
"asarray(a, dtype=None, order=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Convert the input to a masked array of the given data-type.    No copy is performed if the input is already an `ndarray`. If `a` is    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.","a : array_like        Input data, in any form that can be converted to a masked array. This        includes lists, lists of tuples, tuples, tuples of tuples, tuples        of lists, ndarrays and masked arrays.    dtype : dtype, optional        By default, the data-type is inferred from the input data.    order : {'C', 'F'}, optional        Whether to use row-major ('C') or column-major ('FORTRAN') memory        representation.  Default is 'C'.",out : MaskedArray        Masked array interpretation of `a`.
"asanyarray(a, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,"     Convert the input to a masked array, conserving subclasses.    If `a` is a subclass of `MaskedArray`, its class is conserved.    No copy is performed if the input is already an `ndarray`.","a : array_like        Input data, in any form that can be converted to an array.    dtype : dtype, optional        By default, the data-type is inferred from the input data.    order : {'C', 'F'}, optional        Whether to use row-major ('C') or column-major ('FORTRAN') memory        representation.  Default is 'C'.",out : MaskedArray        MaskedArray interpretation of `a`.
_pickle_warn(method):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
"dump(a, F):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Pickle a masked array to a file.    This is a wrapper around ``cPickle.dump``.,"a : MaskedArray        The array to be pickled.    F : str or file-like object        The file to pickle `a` to. If a string, the full path to the file.",
dumps(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Return a string corresponding to the pickling of a masked array.    This is a wrapper around ``cPickle.dumps``.,a : MaskedArray        The array for which the string representation of the pickle is        returned.,
load(F):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Wrapper around ``cPickle.load`` which accepts either a file-like object    or a filename.,F : str or file        The file or file name to load.,
loads(strg):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Load a pickle from the current string.    The result of ``cPickle.loads(strg)`` is returned.,strg : str        The string to load.,
"fromfile(file, dtype=float, count=-1, sep=''):",https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,,,
fromflex(fxarray):,https://github.com//numpy/numpy/blob/master/numpy/ma/core.py,     Build a masked array from a suitable flexible-type array.    The input array has to have a data-type with ``_data`` and ``_mask``    fields. This type of array is output by `MaskedArray.toflex`.,"fxarray : ndarray        The structured input array, containing ``_data`` and ``_mask``        fields. If present, other fields are discarded.    _methodname : string            Name of the method to transform.",result : MaskedArray        The constructed masked array.
,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,,,
issequence(seq):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Is seq a sequence (ndarray, list or tuple)?",,
"count_masked(arr, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Count the number of masked elements along the given axis.,"arr : array_like        An array with (possibly) masked elements.    axis : int, optional        Axis along which to count. If None (default), a flattened        version of the array is used.","count : int, ndarray        The total number of masked elements (axis=None) or the number        of masked elements along each slice of the given axis."
"masked_all(shape, dtype=float):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Empty masked array with all elements masked.    Return an empty masked array of the given shape and dtype, where all the    data are masked.","shape : tuple        Shape of the required MaskedArray.    dtype : dtype, optional        Data type of the output.",a : MaskedArray        A masked array with all data masked.
masked_all_like(arr):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Empty masked array with the properties of an existing array.    Return an empty masked array of the same shape and dtype as    the array `arr`, where all the data are masked.",arr : ndarray        An array describing the shape and dtype of the required MaskedArray.funcname : str        The name of the function to be adapted. The function should be        in the NumPy namespace (i.e. ``np.funcname``).,a : MaskedArray        A masked array with all data masked.
flatten_inplace(seq):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py," Flatten a sequence in place.    k = 0 while (k != len(seq)): while hasattr(seq[k], '__iter__'):            seq[k:(k + 1)] = seq[k]        k += 1 return seq

",,
"apply_along_axis(func1d, axis, arr, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     (This docstring should be overwritten),,
"apply_over_axes(func, a, axes):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     (This docstring will be overwritten),,
"average(a, axis=None, weights=None, returned=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Return the weighted average of array over the given axis.,"a : array_like        Data to be averaged.        Masked entries are not taken into account in the computation.    axis : int, optional        Axis along which to average `a`. If `None`, averaging is done over        the flattened array.    weights : array_like, optional        The importance that each element has in the computation of the average.        The weights array can either be 1-D (in which case its length must be        the size of `a` along the given axis) or of the same shape as `a`.        If ``weights=None``, then all data in `a` are assumed to have a        weight equal to one.   If `weights` is complex, the imaginary parts        are ignored.    returned : bool, optional        Flag indicating whether a tuple ``(result, sum of weights)``        should be returned as output (True), or just the result (False).        Default is False.","average, [sum_of_weights] : (tuple of) scalar or MaskedArray        The average along the specified axis. When returned is `True`,        return a tuple with the average as the first element and the sum        of the weights as the second element. The return type is `np.float64`        if `a` is of integer type and floats smaller than `float64`, or the        input data-type, otherwise. If returned, `sum_of_weights` is always        `float64`."
"median(a, axis=None, out=None, overwrite_input=False, keepdims=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Compute the median along the specified axis.    Returns the median of the array elements.,"a : array_like        Input array or object that can be converted to an array.    axis : int, optional        Axis along which the medians are computed. The default (None) is        to compute the median along a flattened version of the array.    out : ndarray, optional        Alternative output array in which to place the result. It must        have the same shape and buffer length as the expected output        but the type will be cast if necessary.    overwrite_input : bool, optional        If True, then allow use of memory of input array (a) for        calculations. The input array will be modified by the call to        median. This will save memory when you do not need to preserve        the contents of the input array. Treat the input as undefined,        but it will probably be fully or partially sorted. Default is        False. Note that, if `overwrite_input` is True, and the input        is not already an `ndarray`, an error will be raised.    keepdims : bool, optional        If this is set to True, the axes which are reduced are left        in the result as dimensions with size one. With this option,        the result will broadcast correctly against the input array.","median : ndarray        A new array holding the result is returned unless out is        specified, in which case a reference to out is returned.        Return data-type is `float64` for integers and floats smaller than        `float64`, or the input data-type, otherwise."
"_median(a, axis=None, out=None, overwrite_input=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,,,
"compress_nd(x, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py, Suppress slices from multiple dimensions which contain masked values.,"x : array_like, MaskedArray        The array to operate on. If not a MaskedArray instance (or if no array        elements are masked, `x` is interpreted as a MaskedArray with `mask`        set to `nomask`.    axis : tuple of ints or int, optional        Which dimensions to suppress slices from can be configured with this        parameter.        - If axis is a tuple of ints, those are the axes to suppress slices from.        - If axis is an int, then that is the only axis to suppress slices from.        - If axis is None, all axis are selected.","compress_array : ndarray        The compressed array. """"""    x = asarray(x)    m = getmask(x) # Set axis to tuple of ints if axis is None:        axis = tuple(range(x.ndim)) else:        axis = normalize_axis_tuple(axis, x.ndim)
 # Nothing is masked: return x if m is nomask or not m.any(): return x._data # All is masked: return empty if m.all(): return nxarray([]) # Filter elements through boolean indexing    data = x._data for ax in axis:        axes = tuple(list(range(ax)) + list(range(ax + 1, x.ndim)))        data = data[(slice(None),)*ax + (~m.any(axis=axes),)] return data
"
"compress_rowcols(x, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Suppress the rows and/or columns of a 2-D array that contain    masked values.    The suppression behavior is selected with the `axis` parameter.    - If axis is None, both rows and columns are suppressed.    - If axis is 0, only rows are suppressed.    - If axis is 1 or -1, only columns are suppressed.","x : array_like, MaskedArray        The array to operate on.  If not a MaskedArray instance (or if no array        elements are masked), `x` is interpreted as a MaskedArray with        `mask` set to `nomask`. Must be a 2D array.    axis : int, optional        Axis along which to perform the operation. Default is None.",compressed_array : ndarray        The compressed array.
compress_rows(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Suppress whole rows of a 2-D array that contain masked values.    This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see    `extras.compress_rowcols` for details.    See Also    --------    extras.compress_rowcols",,
compress_cols(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Suppress whole columns of a 2-D array that contain masked values.    This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see    `extras.compress_rowcols` for details.    See Also    --------    extras.compress_rowcols",,
"mask_rows(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Mask rows of a 2D array that contain masked values.    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.    See Also    --------    mask_rowcols : Mask rows and/or columns of a 2D array.    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.zeros((3, 3), dtype=int) >>> a[1, 1] = 1 >>> a    array([[0, 0, 0],           [0, 1, 0],           [0, 0, 0]]) >>> a = ma.masked_equal(a, 1) >>> a    masked_array(      data=[[0, 0, 0],            [0, --, 0],            [0, 0, 0]],      mask=[[False, False, False],            [False,  True, False],            [False, False, False]],      fill_value=1) >>> ma.mask_rows(a)    masked_array(      data=[[0, 0, 0],            [--, --, --],            [0, 0, 0]],      mask=[[False, False, False],            [ True,  True,  True],            [False, False, False]],      fill_value=1)",,
"mask_cols(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Mask columns of a 2D array that contain masked values.    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.    See Also    --------    mask_rowcols : Mask rows and/or columns of a 2D array.    masked_where : Mask where a condition is met.    Examples    -------- >>> import numpy.ma as ma >>> a = np.zeros((3, 3), dtype=int) >>> a[1, 1] = 1 >>> a    array([[0, 0, 0],           [0, 1, 0],           [0, 0, 0]]) >>> a = ma.masked_equal(a, 1) >>> a    masked_array(      data=[[0, 0, 0],            [0, --, 0],            [0, 0, 0]],      mask=[[False, False, False],            [False,  True, False],            [False, False, False]],      fill_value=1) >>> ma.mask_cols(a)    masked_array(      data=[[0, --, 0],            [0, --, 0],            [0, --, 0]],      mask=[[False,  True, False],            [False,  True, False],            [False,  True, False]],      fill_value=1)",,
"ediff1d(arr, to_end=None, to_begin=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Compute the differences between consecutive elements of an array.    This function is the equivalent of `numpy.ediff1d` that takes masked    values into account, see `numpy.ediff1d` for details.    See Also    --------    numpy.ediff1d : Equivalent function for ndarrays.",,
"unique(ar1, return_index=False, return_inverse=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Finds the unique elements of an array.    Masked values are considered the same element (masked). The output array    is always a masked array. See `numpy.unique` for more details.    See Also    --------    numpy.unique : Equivalent function for ndarrays.,,
"intersect1d(ar1, ar2, assume_unique=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Returns the unique elements common to both arrays.    Masked values are considered equal one to the other.    The output is always a masked array.    See `numpy.intersect1d` for more details.    See Also    --------    numpy.intersect1d : Equivalent function for ndarrays.    Examples    -------- >>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1]) >>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1]) >>> np.ma.intersect1d(x, y)    masked_array(data=[1, 3, --],                 mask=[False, False,  True],           fill_value=999999)",,
"setxor1d(ar1, ar2, assume_unique=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Set exclusive-or of 1-D arrays with unique elements.    The output is always a masked array. See `numpy.setxor1d` for more details.    See Also    --------    numpy.setxor1d : Equivalent function for ndarrays.,,
"in1d(ar1, ar2, assume_unique=False, invert=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Test whether each element of an array is also present in a second    array.    The output is always a masked array. See `numpy.in1d` for more details.    We recommend using :func:`isin` instead of `in1d` for new code.    See Also    --------    isin       : Version of this function that preserves the shape of ar1.    numpy.in1d : Equivalent function for ndarrays.    Notes    -----    .. versionadded:: 1.4.0,,
"isin(element, test_elements, assume_unique=False, invert=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Calculates `element in test_elements`, broadcasting over    `element` only.    The output is always a masked array of the same shape as `element`.    See `numpy.isin` for more details.    See Also    --------    in1d       : Flattened version of this function.    numpy.isin : Equivalent function for ndarrays.    Notes    -----    .. versionadded:: 1.13.0",,
"union1d(ar1, ar2):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Union of two arrays.    The output is always a masked array. See `numpy.union1d` for more details.    See also    --------    numpy.union1d : Equivalent function for ndarrays.,,
"setdiff1d(ar1, ar2, assume_unique=False):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Set difference of 1D arrays with unique elements.    The output is always a masked array. See `numpy.setdiff1d` for more    details.    See Also    --------    numpy.setdiff1d : Equivalent function for ndarrays.    Examples    -------- >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1]) >>> np.ma.setdiff1d(x, [1, 2])    masked_array(data=[3, --],                 mask=[False,  True],           fill_value=999999)",,
"_covhelper(x, y=None, rowvar=True, allow_masked=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Private function for the computation of covariance and correlation    coefficients.,,
"cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Estimate the covariance matrix.    Except for the handling of missing data this function does the same as    `numpy.cov`. For more details and examples, see `numpy.cov`.    By default, masked values are recognized as such. If `x` and `y` have the    same shape, a common mask is allocated: if ``x[i,j]`` is masked, then    ``y[i,j]`` will also be masked.    Setting `allow_masked` to False will raise an exception if values are    missing in either of the input arrays.","x : array_like        A 1-D or 2-D array containing multiple variables and observations.        Each row of `x` represents a variable, and each column a single        observation of all those variables. Also see `rowvar` below.    y : array_like, optional        An additional set of variables and observations. `y` has the same        form as `x`.    rowvar : bool, optional        If `rowvar` is True (default), then each row represents a        variable, with observations in the columns. Otherwise, the relationship        is transposed: each column represents a variable, while the rows        contain observations.    bias : bool, optional        Default normalization (False) is by ``(N-1)``, where ``N`` is the        number of observations given (unbiased estimate). If `bias` is True,        then normalization is by ``N``. This keyword can be overridden by        the keyword ``ddof`` in numpy versions >= 1.5.    allow_masked : bool, optional        If True, masked values are propagated pair-wise: if a value is masked        in `x`, the corresponding value is masked in `y`.        If False, raises a `ValueError` exception when some values are missing.    ddof : {None, int}, optional        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is        the number of observations; this overrides the value implied by        ``bias``. The default value is ``None``.",
"corrcoef(x, y=None, rowvar=True, bias=np._NoValue, allow_masked=True,",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Return Pearson product-moment correlation coefficients.    Except for the handling of missing data this function does the same as    `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.","x : array_like        A 1-D or 2-D array containing multiple variables and observations.        Each row of `x` represents a variable, and each column a single        observation of all those variables. Also see `rowvar` below.    y : array_like, optional        An additional set of variables and observations. `y` has the same        shape as `x`.    rowvar : bool, optional        If `rowvar` is True (default), then each row represents a        variable, with observations in the columns. Otherwise, the relationship        is transposed: each column represents a variable, while the rows        contain observations.    bias : _NoValue, optional        Has no effect, do not use.",
flatnotmasked_edges(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Find the indices of the first and last unmasked values.    Expects a 1-D `MaskedArray`, returns None if all values are masked.",a : array_like        Input 1-D `MaskedArray`,edges : ndarray or None        The indices of first and last non-masked value in the array.        Returns None if all values are masked.
"notmasked_edges(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Find the indices of the first and last unmasked values along an axis.    If all values are masked, return None.  Otherwise, return a list    of two tuples, corresponding to the indices of the first and last    unmasked values respectively.","a : array_like        The input array.    axis : int, optional        Axis along which to perform the operation.        If None (default), applies to a flattened version of the array.","edges : ndarray or list        An array of start and end indexes if there are any masked data in        the array. If there are no masked data in the array, `edges` is a        list of the first and last index."
flatnotmasked_contiguous(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Find contiguous unmasked data in a masked array along the given axis.,a : narray        The input array.,"slice_list : list        A sorted sequence of `slice` objects (start index, end index)."
"notmasked_contiguous(a, axis=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Find contiguous unmasked data in a masked array along the given axis.,"a : array_like        The input array.    axis : int, optional        Axis along which to perform the operation.        If None (default), applies to a flattened version of the array, and this        is the same as `flatnotmasked_contiguous`.",endpoints : list        A list of slices (start and end indexes) of unmasked indexes        in the array.
_ezclump(mask):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Finds the clumps (groups of data with the same values) for a 1D bool array.    Returns a series of slices.,,
clump_unmasked(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Return list of slices corresponding to the unmasked clumps of a 1-D array.    (A ""clump"" is defined as a contiguous region of the array).",a : ndarray        A one-dimensional masked array.,"slices : list of slice        The list of slices, one for each continuous region of unmasked        elements in `a`."
clump_masked(a):,https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,"     Returns a list of slices corresponding to the masked clumps of a 1-D array.    (A ""clump"" is defined as a contiguous region of the array).",a : ndarray        A one-dimensional masked array.,"slices : list of slice        The list of slices, one for each continuous region of masked elements        in `a`."
"vander(x, n=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/extras.py,     Masked values in the input array result in rows of zeros.,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,,,
"_checknames(descr, names=None):",https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,"     Checks that field names ``descr`` are not reserved keywords.    If this is the case, a default 'f%i' is substituted.  If the argument    `names` is not None, updates the field names to valid names.",,
_get_fieldmask(self):,https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,"     Attributes    ----------    _data : recarray        Underlying data, as a record array.    _mask : boolean array        Mask of the records. A record is masked when all its fields are        masked.    _fieldmask : boolean recarray        Record array of booleans, setting the mask of each individual field        of each record.    _fill_value : record        Filling values for each field.",,
"_mrreconstruct(subtype, baseclass, baseshape, basetype,):",https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,     Build a new MaskedArray from the information stored in a pickle.,,
"fromarrays(arraylist, dtype=None, shape=None, formats=None,",https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,     Creates a mrecarray from a (flat) list of masked arrays.,"arraylist : sequence        A list of (masked) arrays. Each element of the sequence is first converted        to a masked array if needed. If a 2D array is passed as argument, it is        processed line by line    dtype : {None, dtype}, optional        Data type descriptor.    shape : {None, integer}, optional        Number of records. If None, shape is defined from the shape of the        first array in the list.    formats : {None, sequence}, optional        Sequence of formats for each individual field. If None, the formats will        be autodetected by inspecting the fields and selecting the highest dtype        possible.    names : {None, sequence}, optional        Sequence of the names of each field.    fill_value : {None, sequence}, optional        Sequence of data to be used as filling values.",
"fromrecords(reclist, dtype=None, shape=None, formats=None, names=None,",https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,     Creates a MaskedRecords from a list of records.,"reclist : sequence        A list of records. Each element of the sequence is first converted        to a masked array if needed. If a 2D array is passed as argument, it is        processed line by line    dtype : {None, dtype}, optional        Data type descriptor.    shape : {None,int}, optional        Number of records. If None, ``shape`` is defined from the shape of the        first array in the list.    formats : {None, sequence}, optional        Sequence of formats for each individual field. If None, the formats will        be autodetected by inspecting the fields and selecting the highest dtype        possible.    names : {None, sequence}, optional        Sequence of the names of each field.    fill_value : {None, sequence}, optional        Sequence of data to be used as filling values.    mask : {nomask, sequence}, optional.        External mask to apply on the data.",
_guessvartypes(arr):,https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,"     Tries to guess the dtypes of the str_ ndarray `arr`.    Guesses by testing element-wise conversion. Returns a list of dtypes.    The array is first converted to ndarray. If the array is 2D, the test    is performed on the first line. An exception is raised if the file is    3D or more.",,
openfile(fname):,https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,     Opens the file handle of file `fname`.,,
"fromtextfile(fname, delimitor=None, commentchar='#', missingchar='',",https://github.com//numpy/numpy/blob/master/numpy/ma/mrecords.py,     Creates a mrecarray from data stored in the file `filename`.,"fname : {file name/handle}        Handle of an opened file.    delimitor : {None, string}, optional        Alphanumeric character used to separate columns in the file.        If None, any (group of) white spacestring(s) will be used.    commentchar : {'#', string}, optional        Alphanumeric character used to mark the start of a comment.    missingchar : {'', string}, optional        String indicating missing data, and used to create the masks.    varnames : {None, sequence}, optional        Sequence of the variable names. If None, a list will be created from        the first non empty line of the file.    vartypes : {None, sequence}, optional        Sequence of the variables dtypes. If None, it will be estimated from        the first non-commented line.",
,https://github.com//numpy/numpy/blob/master/numpy/ma/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,Miscellaneous functions for testing masked arrays and subclasses:author: Pierre Gerard-Marchant:contact: pierregm_at_uga_dot_edu:version: $Id: testutils.py 3529 2007-11-13 08:01:14Z jarrod.millman $,,
"approx(a, b, fill_value=True, rtol=1e-5, atol=1e-8):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,"     Returns true if all components of a and b are equal to given tolerances.    If fill_value is True, masked values considered equal. Otherwise,    masked values are considered unequal.  The relative error rtol should    be positive and << 1.0 The absolute error atol comes into play for    those elements of b that are very small or zero; it says how small a    must be also.",,
"almost(a, b, decimal=6, fill_value=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,"     Returns True if a and b are equal up to decimal places.    If fill_value is True, masked values considered equal. Otherwise,    masked values are considered unequal.",,
"_assert_equal_on_sequences(actual, desired, err_msg=''):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Asserts the equality of two non-array sequences.,,
"assert_equal_records(a, b):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Asserts that two records are equal.    Pretty crude for now.,,
"assert_equal(actual, desired, err_msg=''):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Asserts that two items are equal.,,
"fail_if_equal(actual, desired, err_msg='',):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Raises an assertion error if two items are equal.,,
"assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Asserts that two items are almost equal.    The test is equivalent to abs(desired-actual) < 0.5 * 10**(-decimal).,,
"assert_array_compare(comparison, x, y, err_msg='', verbose=True, header='',",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Asserts that comparison between two masked arrays is satisfied.    The comparison is elementwise.,,
"assert_array_equal(x, y, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Checks the elementwise equality of two masked arrays.,,
"fail_if_array_equal(x, y, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Raises an assertion error if two masked arrays are not equal elementwise.,,
"assert_array_approx_equal(x, y, decimal=6, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,"     Checks the equality of two masked arrays, up to given number odecimals.    The equality is checked elementwise.",,
"assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,"     Checks the equality of two masked arrays, up to given number odecimals.    The equality is checked elementwise.",,
"assert_array_less(x, y, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/ma/testutils.py,     Checks that x is smaller than y elementwise.,,
,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_fancy_indexing():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_polynomial_mapdomain():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_sort_matrix_none():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_partition_matrix_none():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_dot_scalar_and_matrix_of_objects():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_inner_scalar_and_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_inner_scalar_and_matrix_of_objects():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_iter_allocate_output_subtype():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
like_function():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_array_astype():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_stack():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_object_scalar_multiply():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_nanfunctions_matrices():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_nanfunctions_matrices_general():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_average_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_trapz_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_ediff1d_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_apply_along_axis_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_kron_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,,,
test_array_equal_error_message_matrix():,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_interaction.py,"        msg_reference = textwrap.dedent(\        Arrays are not equal        (shapes (2,), (1, 2) mismatch)         x: array([1, 2])",,
,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/tests/test_numeric.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/defmatrix.py,,,
_convert_from_string(data):,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/defmatrix.py,,,
"asmatrix(data, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/matrixlib/defmatrix.py,"     Interpret the input as a matrix.    Unlike `matrix`, `asmatrix` does not make a copy if the input is already    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.","data : array_like        Input data.    dtype : data-type       Data-type of the output matrix.data : array_like or string       If `data` is a string, it is interpreted as a matrix with commas       or spaces separating columns, and semicolons separating rows.    dtype : data-type       Data-type of the output matrix.    copy : bool       If `data` is already an `ndarray`, then this flag determines       whether the data is copied (the default), or whether a view is       constructed.",mat : matrix        `data` interpreted as a matrix.
"_from_string(str, gdict, ldict):",https://github.com//numpy/numpy/blob/master/numpy/matrixlib/defmatrix.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/matrixlib/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_chebyshev.py,Tests for chebyshev module.,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,Test inter-conversion of different polynomial classes.This tests the convert and cast methods of all the polynomial classes.,,
Poly(request):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
"assert_poly_almost_equal(p1, p2, msg=""""):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
"test_conversion(Poly1, Poly2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
"test_cast(Poly1, Poly2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_identity(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_basis(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_fromroots(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_fit(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_equal(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_not_equal(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_add(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_sub(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_mul(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_floordiv(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_truediv(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_mod(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_divmod(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_roots(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_degree(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_copy(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_integ(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_deriv(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_linspace(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_pow(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_call(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_cutdeg(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_truncate(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_trim(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
test_mapparms(Poly):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_classes.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_hermite.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_hermite_e.py,Tests for hermite_e module.,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_laguerre.py,Tests for laguerre module.,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_legendre.py,Tests for legendre module.,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/tests/test_polynomial.py,Tests for polynomial module.,,
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,,,
_cseries_to_zseries(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py, Covert Chebyshev series to z-series.    Covert a Chebyshev series to the equivalent z-series. The result is    never an empty array. The dtype of the return is the same as that of    the input. No checks are run on the arguments as this routine is for    internal use.,"c : 1-D ndarray        Chebyshev coefficients, ordered from low to high","zs : 1-D ndarray        Odd length symmetric z-series, ordered from  low to high."
_zseries_to_cseries(zs):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py, Covert z-series to a Chebyshev series.    Covert a z series to the equivalent Chebyshev series. The result is    never an empty array. The dtype of the return is the same as that of    the input. No checks are run on the arguments as this routine is for    internal use.,"zs : 1-D ndarray        Odd length symmetric z-series, ordered from  low to high.","c : 1-D ndarray        Chebyshev coefficients, ordered from  low to high."
"_zseries_mul(z1, z2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py, Multiply two z-series.    Multiply two z-series to produce a z-series.,"z1, z2 : 1-D ndarray        The arrays must be 1-D but this is not checked.",product : 1-D ndarray        The product z-series.
"_zseries_div(z1, z2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Divide the first z-series by the second.    Divide `z1` by `z2` and return the quotient and remainder as z-series.    Warning: this implementation only applies when both z1 and z2 have the    same symmetry, which is sufficient for present purposes.","z1, z2 : 1-D ndarray        The arrays must be 1-D and have the same symmetry, but this is not        checked.",    Returns    -------
_zseries_der(zs):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Differentiate a z-series.    The derivative is with respect to x, not z. This is achieved using the    chain rule and the value of dx/dz given in the module notes.",zs : z-series        The z-series to differentiate.,derivative : z-series        The derivative
_zseries_int(zs):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Integrate a z-series.    The integral is with respect to x, not z. This is achieved by a change    of variable using dx/dz given in the module notes.",zs : z-series        The z-series to integrate,integral : z-series        The indefinite integral
poly2cheb(pol):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Convert a polynomial to a Chebyshev series.    Convert an array representing the coefficients of a polynomial (relative    to the ""standard"" basis) ordered from lowest degree to highest, to an    array of the coefficients of the equivalent Chebyshev series, ordered    from lowest to highest degree.",pol : array_like        1-D array containing the polynomial coefficients,c : ndarray        1-D array containing the coefficients of the equivalent Chebyshev        series.
cheb2poly(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Convert a Chebyshev series to a polynomial.    Convert an array representing the coefficients of a Chebyshev series,    ordered from lowest degree to highest, to an array of the coefficients    of the equivalent polynomial (relative to the ""standard"" basis) ordered    from lowest to highest degree.","c : array_like        1-D array containing the Chebyshev series coefficients, ordered        from lowest order term to highest.","pol : ndarray        1-D array containing the coefficients of the equivalent polynomial        (relative to the ""standard"" basis) ordered from lowest order term        to highest."
"chebline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,     Chebyshev series whose graph is a straight line.,"off, scl : scalars        The specified line is given by ``off + scl*x``.",y : ndarray        This module's representation of the Chebyshev series for        ``off + scl*x``.
chebfromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Generate a Chebyshev series with given roots.    The function returns the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    in Chebyshev form, where the `r_n` are the roots specified in `roots`.    If a zero has multiplicity n, then it must appear in `roots` n times.    For instance, if 2 is a root of multiplicity three and 3 is a root of    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The    roots can appear in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * T_1(x) + ... +  c_n * T_n(x)    The coefficient of the last term is not generally 1 for monic    polynomials in Chebyshev form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of coefficients.  If all roots are real then `out` is a        real array, if some of the roots are complex, then `out` is complex        even if all the coefficients in the result are real (see Examples        below)."
"chebadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Add one Chebyshev series to another.    Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments    are sequences of coefficients ordered from lowest order term to    highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.","c1, c2 : array_like        1-D arrays of Chebyshev series coefficients ordered from low to        high.",out : ndarray        Array representing the Chebyshev series of their sum.
"chebsub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Subtract one Chebyshev series from another.    Returns the difference of two Chebyshev series `c1` - `c2`.  The    sequences of coefficients are from lowest order term to highest, i.e.,    [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.","c1, c2 : array_like        1-D arrays of Chebyshev series coefficients ordered from low to        high.",out : ndarray        Of Chebyshev series coefficients representing their difference.
chebmulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Multiply a Chebyshev series by x.    Multiply the polynomial `c` by x, where x is the independent    variable.",c : array_like        1-D array of Chebyshev series coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"chebmul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Multiply one Chebyshev series by another.    Returns the product of two Chebyshev series `c1` * `c2`.  The arguments    are sequences of coefficients, from lowest order ""term"" to highest,    e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.","c1, c2 : array_like        1-D arrays of Chebyshev series coefficients ordered from low to        high.",out : ndarray        Of Chebyshev series coefficients representing their product.
"chebdiv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Divide one Chebyshev series by another.    Returns the quotient-with-remainder of two Chebyshev series    `c1` / `c2`.  The arguments are sequences of coefficients from lowest    order ""term"" to highest, e.g., [1,2,3] represents the series    ``T_0 + 2*T_1 + 3*T_2``.","c1, c2 : array_like        1-D arrays of Chebyshev series coefficients ordered from low to        high.","[quo, rem] : ndarrays        Of Chebyshev series coefficients representing the quotient and        remainder."
"chebpow(c, pow, maxpower=16):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Raise a Chebyshev series to a power.    Returns the Chebyshev series `c` raised to the power `pow`. The    argument `c` is a sequence of coefficients ordered from low to high.    i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``","c : array_like        1-D array of Chebyshev series coefficients ordered from low to        high.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Chebyshev series of power.
"chebder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Differentiate a Chebyshev series.    Returns the Chebyshev series coefficients `c` differentiated `m` times    along `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable). The argument    `c` is an array of coefficients from low to high degree along each    axis, e.g., [1,2,3] represents the series ``1*T_0 + 2*T_1 + 3*T_2``    while [[1,2],[1,2]] represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) +    2*T_0(x)*T_1(y) + 2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is    ``y``.","c : array_like        Array of Chebyshev series coefficients. If c is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change of        variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Chebyshev series of the derivative.
"chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Integrate a Chebyshev series.    Returns the Chebyshev series coefficients `c` integrated `m` times from    `lbnd` along `axis`. At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.)  The argument `c` is an array of    coefficients from low to high degree along each axis, e.g., [1,2,3]    represents the series ``T_0 + 2*T_1 + 3*T_2`` while [[1,2],[1,2]]    represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) + 2*T_0(x)*T_1(y) +    2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.","c : array_like        Array of Chebyshev series coefficients. If c is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at zero        is the first value in the list, the value of the second integral        at zero is the second value, etc.  If ``k == []`` (the default),        all constants are set to zero.  If ``m == 1``, a single scalar can        be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        C-series coefficients of the integral.
"chebval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Evaluate a Chebyshev series at points x.    If `c` is of length `n + 1`, this function returns the value:    .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, algebra_like        The shape of the return value is described above."
"chebval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Evaluate a 2-D Chebyshev series at points (x, y).    This function returns the values:    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * T_i(x) * T_j(y)    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` is a 1-D array a one is implicitly appended to its shape to make    it 2-D. The shape of the result will be c.shape[2:] + x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and if it isn't an ndarray it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in ``c[i,j]``. If `c` has        dimension greater than 2 the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional Chebyshev series at points formed        from pairs of corresponding values from `x` and `y`."
"chebgrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * T_i(a) * T_j(b),    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape + y.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j is contained in `c[i,j]`. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional Chebyshev series at points in the        Cartesian product of `x` and `y`."
"chebval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Evaluate a 3-D Chebyshev series at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * T_i(x) * T_j(y) * T_k(z)    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimensional polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"chebgrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"chebvander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Pseudo-Vandermonde matrix of given degree.    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points    `x`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., i] = T_i(x),    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the degree of the Chebyshev polynomial.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    matrix ``V = chebvander(x, n)``, then ``np.dot(V, c)`` and    ``chebval(x, c)`` are the same up to roundoff.  This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of Chebyshev series of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray        The pseudo Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where The last index is the degree of the        corresponding Chebyshev polynomial.  The dtype will be the same as        the converted `x`."
"chebvander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = T_i(x) * T_j(y),    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the degrees of    the Chebyshev polynomials.    If ``V = chebvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``chebval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D Chebyshev    series of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to        1-D arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"chebvander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the degrees of the Chebyshev polynomials.    If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D Chebyshev    series of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"chebfit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Least squares fit of Chebyshev series to data.    Return the coefficients of a Chebyshev series of degree `deg` that is the    least squares fit to the data values `y` given at points `x`. If `y` is    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple    fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),    where `n` is `deg`.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer,        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (M,) or (M, K)        Chebyshev coefficients ordered from low to high. If `y` was 2-D,        the coefficients for the data in column k  of `y` are in column        `k`."
chebcompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py, Return the scaled companion matrix of c.    The basis polynomials are scaled so that the companion matrix is    symmetric when `c` is a Chebyshev basis polynomial. This provides    better eigenvalue estimates than the unscaled case and for basis    polynomials the eigenvalues are guaranteed to be real if    `numpy.linalg.eigvalsh` is used to obtain them.,c : array_like        1-D array of Chebyshev series coefficients ordered from low to high        degree.,"mat : ndarray        Scaled companion matrix of dimensions (deg, deg)."
chebroots(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Compute the roots of a Chebyshev series.    Return the roots (a.k.a. ""zeros"") of the polynomial    .. math:: p(x) = \\sum_i c[i] * T_i(x).",c : 1-D array_like        1-D array of coefficients.,"out : ndarray        Array of the roots of the series. If all the roots are real,        then `out` is also real, otherwise it is complex."
"chebinterpolate(func, deg, args=()):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py," Interpolate a function at the Chebyshev points of the first kind.    Returns the Chebyshev series that interpolates `func` at the Chebyshev    points of the first kind in the interval [-1, 1]. The interpolating    series tends to a minmax approximation to `func` with increasing `deg`    if the function is continuous in the interval.    .. versionadded:: 1.14.0","func : function        The function to be approximated. It must be a function of a single        variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are        extra arguments passed in the `args` parameter.    deg : int        Degree of the interpolating polynomial    args : tuple, optional        Extra arguments to be used in the function call. Default is no extra        arguments.","coef : ndarray, shape (deg + 1,)        Chebyshev coefficients of the interpolating series ordered from low to        high."
chebgauss(deg):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Gauss-Chebyshev quadrature.    Computes the sample points and weights for Gauss-Chebyshev quadrature.    These sample points and weights will correctly integrate polynomials of    degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with    the weight function :math:`f(x) = 1/\\sqrt{1 - x^2}`.",deg : int        Number of sample points and weights. It must be >= 1.,x : ndarray        1-D ndarray containing the sample points.    y : ndarray        1-D ndarray containing the weights.
chebweight(x):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     The weight function of the Chebyshev polynomials.    The weight function is :math:`1/\\sqrt{1 - x^2}` and the interval of    integration is :math:`[-1, 1]`. The Chebyshev polynomials are    orthogonal, but not normalized, with respect to this weight function.",x : array_like       Values at which the weight function will be computed.,w : ndarray       The weight function at `x`.
chebpts1(npts):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/chebyshev.py,"     Chebyshev points of the first kind.    The Chebyshev points of the first kind are the points ``cos(x)``,    where ``x = [pi*(k + .5)/npts for k in range(npts)]``.",npts : int        Number of sample points desired.,pts : ndarray        The Chebyshev points of the first kind.
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,,,
poly2herm(pol):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     poly2herm(pol)    Convert a polynomial to a Hermite series.    Convert an array representing the coefficients of a polynomial (relative    to the ""standard"" basis) ordered from lowest degree to highest, to an    array of the coefficients of the equivalent Hermite series, ordered    from lowest to highest degree.",pol : array_like        1-D array containing the polynomial coefficients,c : ndarray        1-D array containing the coefficients of the equivalent Hermite        series.
herm2poly(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Convert a Hermite series to a polynomial.    Convert an array representing the coefficients of a Hermite series,    ordered from lowest degree to highest, to an array of the coefficients    of the equivalent polynomial (relative to the ""standard"" basis) ordered    from lowest to highest degree.","c : array_like        1-D array containing the Hermite series coefficients, ordered        from lowest order term to highest.","pol : ndarray        1-D array containing the coefficients of the equivalent polynomial        (relative to the ""standard"" basis) ordered from lowest order term        to highest."
"hermline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,     Hermite series whose graph is a straight line.,"off, scl : scalars        The specified line is given by ``off + scl*x``.",y : ndarray        This module's representation of the Hermite series for        ``off + scl*x``.
hermfromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Generate a Hermite series with given roots.    The function returns the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    in Hermite form, where the `r_n` are the roots specified in `roots`.    If a zero has multiplicity n, then it must appear in `roots` n times.    For instance, if 2 is a root of multiplicity three and 3 is a root of    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The    roots can appear in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * H_1(x) + ... +  c_n * H_n(x)    The coefficient of the last term is not generally 1 for monic    polynomials in Hermite form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of coefficients.  If all roots are real then `out` is a        real array, if some of the roots are complex, then `out` is complex        even if all the coefficients in the result are real (see Examples        below)."
"hermadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Add one Hermite series to another.    Returns the sum of two Hermite series `c1` + `c2`.  The arguments    are sequences of coefficients ordered from lowest order term to    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Array representing the Hermite series of their sum.
"hermsub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Subtract one Hermite series from another.    Returns the difference of two Hermite series `c1` - `c2`.  The    sequences of coefficients are from lowest order term to highest, i.e.,    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Of Hermite series coefficients representing their difference.
hermmulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py," Multiply a Hermite series by x.    Multiply the Hermite series `c` by x, where x is the independent    variable.",c : array_like        1-D array of Hermite series coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"hermmul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Multiply one Hermite series by another.    Returns the product of two Hermite series `c1` * `c2`.  The arguments    are sequences of coefficients, from lowest order ""term"" to highest,    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Of Hermite series coefficients representing their product.
"hermdiv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Divide one Hermite series by another.    Returns the quotient-with-remainder of two Hermite series    `c1` / `c2`.  The arguments are sequences of coefficients from lowest    order ""term"" to highest, e.g., [1,2,3] represents the series    ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.","[quo, rem] : ndarrays        Of Hermite series coefficients representing the quotient and        remainder."
"hermpow(c, pow, maxpower=16):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py," Raise a Hermite series to a power.    Returns the Hermite series `c` raised to the power `pow`. The    argument `c` is a sequence of coefficients ordered from low to high.    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``","c : array_like        1-D array of Hermite series coefficients ordered from low to        high.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Hermite series of power.
"hermder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Differentiate a Hermite series.    Returns the Hermite series coefficients `c` differentiated `m` times    along `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable). The argument    `c` is an array of coefficients from low to high degree along each    axis, e.g., [1,2,3] represents the series ``1*H_0 + 2*H_1 + 3*H_2``    while [[1,2],[1,2]] represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +    2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is    ``y``.","c : array_like        Array of Hermite series coefficients. If `c` is multidimensional the        different axis correspond to different variables with the degree in        each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change of        variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Hermite series of the derivative.
"hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Integrate a Hermite series.    Returns the Hermite series coefficients `c` integrated `m` times from    `lbnd` along `axis`. At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.)  The argument `c` is an array of    coefficients from low to high degree along each axis, e.g., [1,2,3]    represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]    represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +    2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.","c : array_like        Array of Hermite series coefficients. If c is multidimensional the        different axis correspond to different variables with the degree in        each axis given by the corresponding index.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at        ``lbnd`` is the first value in the list, the value of the second        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the        default), all constants are set to zero.  If ``m == 1``, a single        scalar can be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        Hermite series coefficients of the integral.
"hermval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Evaluate an Hermite series at points x.    If `c` is of length `n + 1`, this function returns the value:    .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, algebra_like        The shape of the return value is described above."
"hermval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Evaluate a 2-D Hermite series at points (x, y).    This function returns the values:    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * H_i(x) * H_j(y)    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` is a 1-D array a one is implicitly appended to its shape to make    it 2-D. The shape of the result will be c.shape[2:] + x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and if it isn't an ndarray it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in ``c[i,j]``. If `c` has        dimension greater than two the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points formed with        pairs of corresponding values from `x` and `y`."
"hermgrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Evaluate a 2-D Hermite series on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"hermval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Evaluate a 3-D Hermite series at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * H_i(x) * H_j(y) * H_k(z)    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimensional polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"hermgrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"hermvander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py," Pseudo-Vandermonde matrix of given degree.    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points    `x`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., i] = H_i(x),    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the degree of the Hermite polynomial.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    array ``V = hermvander(x, n)``, then ``np.dot(V, c)`` and    ``hermval(x, c)`` are the same up to roundoff. This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of Hermite series of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray        The pseudo-Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where The last index is the degree of the        corresponding Hermite polynomial.  The dtype will be the same as        the converted `x`."
"hermvander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = H_i(x) * H_j(y),    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the degrees of    the Hermite polynomials.    If ``V = hermvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``hermval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D Hermite    series of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"hermvander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = H_i(x)*H_j(y)*H_k(z),    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the degrees of the Hermite polynomials.    If ``V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and  ``np.dot(V, c.flat)`` and ``hermval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D Hermite    series of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"hermfit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Least squares fit of Hermite series to data.    Return the coefficients of a Hermite series of degree `deg` that is the    least squares fit to the data values `y` given at points `x`. If `y` is    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple    fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * H_1(x) + ... + c_n * H_n(x),    where `n` is `deg`.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (M,) or (M, K)        Hermite coefficients ordered from low to high. If `y` was 2-D,        the coefficients for the data in column k  of `y` are in column        `k`."
hermcompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py, Return the scaled companion matrix of c.    The basis polynomials are scaled so that the companion matrix is    symmetric when `c` is an Hermite basis polynomial. This provides    better eigenvalue estimates than the unscaled case and for basis    polynomials the eigenvalues are guaranteed to be real if    `numpy.linalg.eigvalsh` is used to obtain them.,c : array_like        1-D array of Hermite series coefficients ordered from low to high        degree.,"mat : ndarray        Scaled companion matrix of dimensions (deg, deg)."
hermroots(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Compute the roots of a Hermite series.    Return the roots (a.k.a. ""zeros"") of the polynomial    .. math:: p(x) = \\sum_i c[i] * H_i(x).",c : 1-D array_like        1-D array of coefficients.,"out : ndarray        Array of the roots of the series. If all the roots are real,        then `out` is also real, otherwise it is complex."
"_normed_hermite_n(x, n):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,     Evaluate a normalized Hermite polynomial.    Compute the value of the normalized Hermite polynomial of degree ``n``    at the points ``x``.,x : ndarray of double.        Points at which to evaluate the function    n : int        Degree of the normalized Hermite function to be evaluated.,values : ndarray        The shape of the return value is described above.
hermgauss(deg):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite.py,"     Gauss-Hermite quadrature.    Computes the sample points and weights for Gauss-Hermite quadrature.    These sample points and weights will correctly integrate polynomials of    degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`    with the weight function :math:`f(x) = \\exp(-x^2)`.",deg : int        Number of sample points and weights. It must be >= 1.,x : ndarray        1-D ndarray containing the sample points.    y : ndarray        1-D ndarray containing the weights.
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,,,
poly2herme(pol):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     poly2herme(pol)    Convert a polynomial to a Hermite series.    Convert an array representing the coefficients of a polynomial (relative    to the ""standard"" basis) ordered from lowest degree to highest, to an    array of the coefficients of the equivalent Hermite series, ordered    from lowest to highest degree.",pol : array_like        1-D array containing the polynomial coefficients,c : ndarray        1-D array containing the coefficients of the equivalent Hermite        series.
herme2poly(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Convert a Hermite series to a polynomial.    Convert an array representing the coefficients of a Hermite series,    ordered from lowest degree to highest, to an array of the coefficients    of the equivalent polynomial (relative to the ""standard"" basis) ordered    from lowest to highest degree.","c : array_like        1-D array containing the Hermite series coefficients, ordered        from lowest order term to highest.","pol : ndarray        1-D array containing the coefficients of the equivalent polynomial        (relative to the ""standard"" basis) ordered from lowest order term        to highest."
"hermeline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,     Hermite series whose graph is a straight line.,"off, scl : scalars        The specified line is given by ``off + scl*x``.",y : ndarray        This module's representation of the Hermite series for        ``off + scl*x``.
hermefromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Generate a HermiteE series with given roots.    The function returns the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    in HermiteE form, where the `r_n` are the roots specified in `roots`.    If a zero has multiplicity n, then it must appear in `roots` n times.    For instance, if 2 is a root of multiplicity three and 3 is a root of    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The    roots can appear in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)    The coefficient of the last term is not generally 1 for monic    polynomials in HermiteE form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of coefficients.  If all roots are real then `out` is a        real array, if some of the roots are complex, then `out` is complex        even if all the coefficients in the result are real (see Examples        below)."
"hermeadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Add one Hermite series to another.    Returns the sum of two Hermite series `c1` + `c2`.  The arguments    are sequences of coefficients ordered from lowest order term to    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Array representing the Hermite series of their sum.
"hermesub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Subtract one Hermite series from another.    Returns the difference of two Hermite series `c1` - `c2`.  The    sequences of coefficients are from lowest order term to highest, i.e.,    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Of Hermite series coefficients representing their difference.
hermemulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py," Multiply a Hermite series by x.    Multiply the Hermite series `c` by x, where x is the independent    variable.",c : array_like        1-D array of Hermite series coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"hermemul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Multiply one Hermite series by another.    Returns the product of two Hermite series `c1` * `c2`.  The arguments    are sequences of coefficients, from lowest order ""term"" to highest,    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.",out : ndarray        Of Hermite series coefficients representing their product.
"hermediv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Divide one Hermite series by another.    Returns the quotient-with-remainder of two Hermite series    `c1` / `c2`.  The arguments are sequences of coefficients from lowest    order ""term"" to highest, e.g., [1,2,3] represents the series    ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Hermite series coefficients ordered from low to        high.","[quo, rem] : ndarrays        Of Hermite series coefficients representing the quotient and        remainder."
"hermepow(c, pow, maxpower=16):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py," Raise a Hermite series to a power.    Returns the Hermite series `c` raised to the power `pow`. The    argument `c` is a sequence of coefficients ordered from low to high.    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``","c : array_like        1-D array of Hermite series coefficients ordered from low to        high.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Hermite series of power.
"hermeder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Differentiate a Hermite_e series.    Returns the series coefficients `c` differentiated `m` times along    `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable). The argument    `c` is an array of coefficients from low to high degree along each    axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2``    while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)    + 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1    is ``y``.","c : array_like        Array of Hermite_e series coefficients. If `c` is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change of        variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Hermite series of the derivative.
"hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Integrate a Hermite_e series.    Returns the Hermite_e series coefficients `c` integrated `m` times from    `lbnd` along `axis`. At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.)  The argument `c` is an array of    coefficients from low to high degree along each axis, e.g., [1,2,3]    represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]    represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +    2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.","c : array_like        Array of Hermite_e series coefficients. If c is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at        ``lbnd`` is the first value in the list, the value of the second        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the        default), all constants are set to zero.  If ``m == 1``, a single        scalar can be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        Hermite_e series coefficients of the integral.
"hermeval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Evaluate an HermiteE series at points x.    If `c` is of length `n + 1`, this function returns the value:    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, algebra_like        The shape of the return value is described above."
"hermeval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Evaluate a 2-D HermiteE series at points (x, y).    This function returns the values:    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * He_i(x) * He_j(y)    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` is a 1-D array a one is implicitly appended to its shape to make    it 2-D. The shape of the result will be c.shape[2:] + x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and if it isn't an ndarray it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in ``c[i,j]``. If `c` has        dimension greater than two the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points formed with        pairs of corresponding values from `x` and `y`."
"hermegrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Evaluate a 2-D HermiteE series on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"hermeval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Evaluate a 3-D Hermite_e series at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimensional polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"hermegrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"hermevander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py," Pseudo-Vandermonde matrix of given degree.    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points    `x`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., i] = He_i(x),    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the degree of the HermiteE polynomial.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and    ``hermeval(x, c)`` are the same up to roundoff. This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of HermiteE series of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray        The pseudo-Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where The last index is the degree of the        corresponding HermiteE polynomial.  The dtype will be the same as        the converted `x`."
"hermevander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the degrees of    the HermiteE polynomials.    If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D HermiteE    series of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to        1-D arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"hermevander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then Hehe pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the degrees of the HermiteE polynomials.    If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D HermiteE    series of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"hermefit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Least squares fit of Hermite series to data.    Return the coefficients of a HermiteE series of degree `deg` that is    the least squares fit to the data values `y` given at points `x`. If    `y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D    multiple fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),    where `n` is `deg`.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (M,) or (M, K)        Hermite coefficients ordered from low to high. If `y` was 2-D,        the coefficients for the data in column k  of `y` are in column        `k`."
hermecompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,     Return the scaled companion matrix of c.    The basis polynomials are scaled so that the companion matrix is    symmetric when `c` is an HermiteE basis polynomial. This provides    better eigenvalue estimates than the unscaled case and for basis    polynomials the eigenvalues are guaranteed to be real if    `numpy.linalg.eigvalsh` is used to obtain them.,c : array_like        1-D array of HermiteE series coefficients ordered from low to high        degree.,"mat : ndarray        Scaled companion matrix of dimensions (deg, deg)."
hermeroots(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Compute the roots of a HermiteE series.    Return the roots (a.k.a. ""zeros"") of the polynomial    .. math:: p(x) = \\sum_i c[i] * He_i(x).",c : 1-D array_like        1-D array of coefficients.,"out : ndarray        Array of the roots of the series. If all the roots are real,        then `out` is also real, otherwise it is complex."
"_normed_hermite_e_n(x, n):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,     Evaluate a normalized HermiteE polynomial.    Compute the value of the normalized HermiteE polynomial of degree ``n``    at the points ``x``.,x : ndarray of double.        Points at which to evaluate the function    n : int        Degree of the normalized HermiteE function to be evaluated.,values : ndarray        The shape of the return value is described above.
hermegauss(deg):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/hermite_e.py,"     Gauss-HermiteE quadrature.    Computes the sample points and weights for Gauss-HermiteE quadrature.    These sample points and weights will correctly integrate polynomials of    degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`    with the weight function :math:`f(x) = \\exp(-x^2/2)`.",deg : int        Number of sample points and weights. It must be >= 1.,x : ndarray        1-D ndarray containing the sample points.    y : ndarray        1-D ndarray containing the weights.
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,,,
poly2lag(pol):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     poly2lag(pol)    Convert a polynomial to a Laguerre series.    Convert an array representing the coefficients of a polynomial (relative    to the ""standard"" basis) ordered from lowest degree to highest, to an    array of the coefficients of the equivalent Laguerre series, ordered    from lowest to highest degree.",pol : array_like        1-D array containing the polynomial coefficients,c : ndarray        1-D array containing the coefficients of the equivalent Laguerre        series.
lag2poly(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Convert a Laguerre series to a polynomial.    Convert an array representing the coefficients of a Laguerre series,    ordered from lowest degree to highest, to an array of the coefficients    of the equivalent polynomial (relative to the ""standard"" basis) ordered    from lowest to highest degree.","c : array_like        1-D array containing the Laguerre series coefficients, ordered        from lowest order term to highest.","pol : ndarray        1-D array containing the coefficients of the equivalent polynomial        (relative to the ""standard"" basis) ordered from lowest order term        to highest."
"lagline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,     Laguerre series whose graph is a straight line.,"off, scl : scalars        The specified line is given by ``off + scl*x``.",y : ndarray        This module's representation of the Laguerre series for        ``off + scl*x``.
lagfromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Generate a Laguerre series with given roots.    The function returns the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    in Laguerre form, where the `r_n` are the roots specified in `roots`.    If a zero has multiplicity n, then it must appear in `roots` n times.    For instance, if 2 is a root of multiplicity three and 3 is a root of    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The    roots can appear in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)    The coefficient of the last term is not generally 1 for monic    polynomials in Laguerre form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of coefficients.  If all roots are real then `out` is a        real array, if some of the roots are complex, then `out` is complex        even if all the coefficients in the result are real (see Examples        below)."
"lagadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Add one Laguerre series to another.    Returns the sum of two Laguerre series `c1` + `c2`.  The arguments    are sequences of coefficients ordered from lowest order term to    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Laguerre series coefficients ordered from low to        high.",out : ndarray        Array representing the Laguerre series of their sum.
"lagsub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Subtract one Laguerre series from another.    Returns the difference of two Laguerre series `c1` - `c2`.  The    sequences of coefficients are from lowest order term to highest, i.e.,    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Laguerre series coefficients ordered from low to        high.",out : ndarray        Of Laguerre series coefficients representing their difference.
lagmulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py," Multiply a Laguerre series by x.    Multiply the Laguerre series `c` by x, where x is the independent    variable.",c : array_like        1-D array of Laguerre series coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"lagmul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Multiply one Laguerre series by another.    Returns the product of two Laguerre series `c1` * `c2`.  The arguments    are sequences of coefficients, from lowest order ""term"" to highest,    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Laguerre series coefficients ordered from low to        high.",out : ndarray        Of Laguerre series coefficients representing their product.
"lagdiv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Divide one Laguerre series by another.    Returns the quotient-with-remainder of two Laguerre series    `c1` / `c2`.  The arguments are sequences of coefficients from lowest    order ""term"" to highest, e.g., [1,2,3] represents the series    ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Laguerre series coefficients ordered from low to        high.","[quo, rem] : ndarrays        Of Laguerre series coefficients representing the quotient and        remainder."
"lagpow(c, pow, maxpower=16):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py," Raise a Laguerre series to a power.    Returns the Laguerre series `c` raised to the power `pow`. The    argument `c` is a sequence of coefficients ordered from low to high.    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``","c : array_like        1-D array of Laguerre series coefficients ordered from low to        high.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Laguerre series of power.
"lagder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Differentiate a Laguerre series.    Returns the Laguerre series coefficients `c` differentiated `m` times    along `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable). The argument    `c` is an array of coefficients from low to high degree along each    axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``    while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +    2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is    ``y``.","c : array_like        Array of Laguerre series coefficients. If `c` is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change of        variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Laguerre series of the derivative.
"lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Integrate a Laguerre series.    Returns the Laguerre series coefficients `c` integrated `m` times from    `lbnd` along `axis`. At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.)  The argument `c` is an array of    coefficients from low to high degree along each axis, e.g., [1,2,3]    represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]    represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +    2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.","c : array_like        Array of Laguerre series coefficients. If `c` is multidimensional        the different axis correspond to different variables with the        degree in each axis given by the corresponding index.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at        ``lbnd`` is the first value in the list, the value of the second        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the        default), all constants are set to zero.  If ``m == 1``, a single        scalar can be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        Laguerre series coefficients of the integral.
"lagval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Evaluate a Laguerre series at points x.    If `c` is of length `n + 1`, this function returns the value:    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, algebra_like        The shape of the return value is described above."
"lagval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Evaluate a 2-D Laguerre series at points (x, y).    This function returns the values:    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` is a 1-D array a one is implicitly appended to its shape to make    it 2-D. The shape of the result will be c.shape[2:] + x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and if it isn't an ndarray it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in ``c[i,j]``. If `c` has        dimension greater than two the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points formed with        pairs of corresponding values from `x` and `y`."
"laggrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Evaluate a 2-D Laguerre series on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape + y.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j is contained in `c[i,j]`. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional Chebyshev series at points in the        Cartesian product of `x` and `y`."
"lagval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Evaluate a 3-D Laguerre series at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimension polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"laggrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"lagvander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py," Pseudo-Vandermonde matrix of given degree.    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points    `x`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., i] = L_i(x)    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the degree of the Laguerre polynomial.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    array ``V = lagvander(x, n)``, then ``np.dot(V, c)`` and    ``lagval(x, c)`` are the same up to roundoff. This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of Laguerre series of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray        The pseudo-Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where The last index is the degree of the        corresponding Laguerre polynomial.  The dtype will be the same as        the converted `x`."
"lagvander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the degrees of    the Laguerre polynomials.    If ``V = lagvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``lagval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D Laguerre    series of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to        1-D arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"lagvander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the degrees of the Laguerre polynomials.    If ``V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and  ``np.dot(V, c.flat)`` and ``lagval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D Laguerre    series of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"lagfit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Least squares fit of Laguerre series to data.    Return the coefficients of a Laguerre series of degree `deg` that is the    least squares fit to the data values `y` given at points `x`. If `y` is    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple    fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),    where `n` is `deg`.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (M,) or (M, K)        Laguerre coefficients ordered from low to high. If `y` was 2-D,        the coefficients for the data in column k  of `y` are in column        `k`."
lagcompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Return the companion matrix of c.    The usual companion matrix of the Laguerre polynomials is already    symmetric when `c` is a basis Laguerre polynomial, so no scaling is    applied.",c : array_like        1-D array of Laguerre series coefficients ordered from low to high        degree.,"mat : ndarray        Companion matrix of dimensions (deg, deg)."
lagroots(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Compute the roots of a Laguerre series.    Return the roots (a.k.a. ""zeros"") of the polynomial    .. math:: p(x) = \\sum_i c[i] * L_i(x).",c : 1-D array_like        1-D array of coefficients.,"out : ndarray        Array of the roots of the series. If all the roots are real,        then `out` is also real, otherwise it is complex."
laggauss(deg):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/laguerre.py,"     Gauss-Laguerre quadrature.    Computes the sample points and weights for Gauss-Laguerre quadrature.    These sample points and weights will correctly integrate polynomials of    degree :math:`2*deg - 1` or less over the interval :math:`[0, \\inf]`    with the weight function :math:`f(x) = \\exp(-x)`.",deg : int        Number of sample points and weights. It must be >= 1.,x : ndarray        1-D ndarray containing the sample points.    y : ndarray        1-D ndarray containing the weights.
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,,,
poly2leg(pol):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Convert a polynomial to a Legendre series.    Convert an array representing the coefficients of a polynomial (relative    to the ""standard"" basis) ordered from lowest degree to highest, to an    array of the coefficients of the equivalent Legendre series, ordered    from lowest to highest degree.",pol : array_like        1-D array containing the polynomial coefficients,c : ndarray        1-D array containing the coefficients of the equivalent Legendre        series.
leg2poly(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Convert a Legendre series to a polynomial.    Convert an array representing the coefficients of a Legendre series,    ordered from lowest degree to highest, to an array of the coefficients    of the equivalent polynomial (relative to the ""standard"" basis) ordered    from lowest to highest degree.","c : array_like        1-D array containing the Legendre series coefficients, ordered        from lowest order term to highest.","pol : ndarray        1-D array containing the coefficients of the equivalent polynomial        (relative to the ""standard"" basis) ordered from lowest order term        to highest."
"legline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,     Legendre series whose graph is a straight line.,"off, scl : scalars        The specified line is given by ``off + scl*x``.",y : ndarray        This module's representation of the Legendre series for        ``off + scl*x``.
legfromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Generate a Legendre series with given roots.    The function returns the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    in Legendre form, where the `r_n` are the roots specified in `roots`.    If a zero has multiplicity n, then it must appear in `roots` n times.    For instance, if 2 is a root of multiplicity three and 3 is a root of    multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The    roots can appear in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)    The coefficient of the last term is not generally 1 for monic    polynomials in Legendre form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of coefficients.  If all roots are real then `out` is a        real array, if some of the roots are complex, then `out` is complex        even if all the coefficients in the result are real (see Examples        below)."
"legadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Add one Legendre series to another.    Returns the sum of two Legendre series `c1` + `c2`.  The arguments    are sequences of coefficients ordered from lowest order term to    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Legendre series coefficients ordered from low to        high.",out : ndarray        Array representing the Legendre series of their sum.
"legsub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Subtract one Legendre series from another.    Returns the difference of two Legendre series `c1` - `c2`.  The    sequences of coefficients are from lowest order term to highest, i.e.,    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Legendre series coefficients ordered from low to        high.",out : ndarray        Of Legendre series coefficients representing their difference.
legmulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py," Multiply a Legendre series by x.    Multiply the Legendre series `c` by x, where x is the independent    variable.",c : array_like        1-D array of Legendre series coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"legmul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Multiply one Legendre series by another.    Returns the product of two Legendre series `c1` * `c2`.  The arguments    are sequences of coefficients, from lowest order ""term"" to highest,    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Legendre series coefficients ordered from low to        high.",out : ndarray        Of Legendre series coefficients representing their product.
"legdiv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Divide one Legendre series by another.    Returns the quotient-with-remainder of two Legendre series    `c1` / `c2`.  The arguments are sequences of coefficients from lowest    order ""term"" to highest, e.g., [1,2,3] represents the series    ``P_0 + 2*P_1 + 3*P_2``.","c1, c2 : array_like        1-D arrays of Legendre series coefficients ordered from low to        high.","quo, rem : ndarrays        Of Legendre series coefficients representing the quotient and        remainder."
"legpow(c, pow, maxpower=16):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py," Raise a Legendre series to a power.    Returns the Legendre series `c` raised to the power `pow`. The    argument `c` is a sequence of coefficients ordered from low to high.    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``","c : array_like        1-D array of Legendre series coefficients ordered from low to        high.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Legendre series of power.
"legder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Differentiate a Legendre series.    Returns the Legendre series coefficients `c` differentiated `m` times    along `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable). The argument    `c` is an array of coefficients from low to high degree along each    axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``    while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +    2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is    ``y``.","c : array_like        Array of Legendre series coefficients. If c is multidimensional the        different axis correspond to different variables with the degree in        each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change of        variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Legendre series of the derivative.
"legint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Integrate a Legendre series.    Returns the Legendre series coefficients `c` integrated `m` times from    `lbnd` along `axis`. At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.)  The argument `c` is an array of    coefficients from low to high degree along each axis, e.g., [1,2,3]    represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]    represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +    2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.","c : array_like        Array of Legendre series coefficients. If c is multidimensional the        different axis correspond to different variables with the degree in        each axis given by the corresponding index.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at        ``lbnd`` is the first value in the list, the value of the second        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the        default), all constants are set to zero.  If ``m == 1``, a single        scalar can be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        Legendre series coefficient array of the integral.
"legval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Evaluate a Legendre series at points x.    If `c` is of length `n + 1`, this function returns the value:    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, algebra_like        The shape of the return value is described above."
"legval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Evaluate a 2-D Legendre series at points (x, y).    This function returns the values:    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` is a 1-D array a one is implicitly appended to its shape to make    it 2-D. The shape of the result will be c.shape[2:] + x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and if it isn't an ndarray it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in ``c[i,j]``. If `c` has        dimension greater than two the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional Legendre series at points formed        from pairs of corresponding values from `x` and `y`."
"leggrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Evaluate a 2-D Legendre series on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape + y.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j is contained in `c[i,j]`. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional Chebyshev series at points in the        Cartesian product of `x` and `y`."
"legval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Evaluate a 3-D Legendre series at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimensional polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"leggrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"legvander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py," Pseudo-Vandermonde matrix of given degree.    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points    `x`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., i] = L_i(x)    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the degree of the Legendre polynomial.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    array ``V = legvander(x, n)``, then ``np.dot(V, c)`` and    ``legval(x, c)`` are the same up to roundoff. This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of Legendre series of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray        The pseudo-Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where The last index is the degree of the        corresponding Legendre polynomial.  The dtype will be the same as        the converted `x`."
"legvander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the degrees of    the Legendre polynomials.    If ``V = legvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``legval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D Legendre    series of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to        1-D arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"legvander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the degrees of the Legendre polynomials.    If ``V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and ``np.dot(V, c.flat)`` and ``legval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D Legendre    series of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"legfit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Least squares fit of Legendre series to data.    Return the coefficients of a Legendre series of degree `deg` that is the    least squares fit to the data values `y` given at points `x`. If `y` is    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple    fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),    where `n` is `deg`.","x : array_like, shape (M,)        x-coordinates of the M sample points ``(x[i], y[i])``.    y : array_like, shape (M,) or (M, K)        y-coordinates of the sample points. Several data sets of sample        points sharing the same x-coordinates can be fitted at once by        passing in a 2D-array that contains one dataset per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit. Singular values smaller than        this relative to the largest singular value will be ignored. The        default value is len(x)*eps, where eps is the relative precision of        the float type, about 2e-16 in most cases.    full : bool, optional        Switch determining nature of return value. When it is False (the        default) just the coefficients are returned, when True diagnostic        information from the singular value decomposition is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (M,) or (M, K)        Legendre coefficients ordered from low to high. If `y` was        2-D, the coefficients for the data in column k of `y` are in        column `k`. If `deg` is specified as a list, coefficients for        terms not included in the fit are set equal to zero in the        returned `coef`."
legcompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py, Return the scaled companion matrix of c.    The basis polynomials are scaled so that the companion matrix is    symmetric when `c` is an Legendre basis polynomial. This provides    better eigenvalue estimates than the unscaled case and for basis    polynomials the eigenvalues are guaranteed to be real if    `numpy.linalg.eigvalsh` is used to obtain them.,c : array_like        1-D array of Legendre series coefficients ordered from low to high        degree.,"mat : ndarray        Scaled companion matrix of dimensions (deg, deg)."
legroots(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Compute the roots of a Legendre series.    Return the roots (a.k.a. ""zeros"") of the polynomial    .. math:: p(x) = \\sum_i c[i] * L_i(x).",c : 1-D array_like        1-D array of coefficients.,"out : ndarray        Array of the roots of the series. If all the roots are real,        then `out` is also real, otherwise it is complex."
leggauss(deg):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/legendre.py,"     Gauss-Legendre quadrature.    Computes the sample points and weights for Gauss-Legendre quadrature.    These sample points and weights will correctly integrate polynomials of    degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with    the weight function :math:`f(x) = 1`.",deg : int        Number of sample points and weights. It must be >= 1.,x : ndarray        1-D ndarray containing the sample points.    y : ndarray        1-D ndarray containing the weights.
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,,,
"polyline(off, scl):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,     Returns an array representing a linear polynomial.,"off, scl : scalars        The ""y-intercept"" and ""slope"" of the line, respectively.",y : ndarray        This module's representation of the linear polynomial ``off +        scl*x``.
polyfromroots(roots):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Generate a monic polynomial with given roots.    Return the coefficients of the polynomial    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),    where the `r_n` are the roots specified in `roots`.  If a zero has    multiplicity n, then it must appear in `roots` n times. For instance,    if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,    then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear    in any order.    If the returned coefficients are `c`, then    .. math:: p(x) = c_0 + c_1 * x + ... +  x^n    The coefficient of the last term is 1 for monic polynomials in this    form.",roots : array_like        Sequence containing the roots.,"out : ndarray        1-D array of the polynomial's coefficients If all the roots are        real, then `out` is also real, otherwise it is complex.  (see        Examples below)."
"polyadd(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Add one polynomial to another.    Returns the sum of two polynomials `c1` + `c2`.  The arguments are    sequences of coefficients from lowest order term to highest, i.e.,    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.","c1, c2 : array_like        1-D arrays of polynomial coefficients ordered from low to high.",out : ndarray        The coefficient array representing their sum.
"polysub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Subtract one polynomial from another.    Returns the difference of two polynomials `c1` - `c2`.  The arguments    are sequences of coefficients from lowest order term to highest, i.e.,    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.","c1, c2 : array_like        1-D arrays of polynomial coefficients ordered from low to        high.",out : ndarray        Of coefficients representing their difference.
polymulx(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py," Multiply a polynomial by x.    Multiply the polynomial `c` by x, where x is the independent    variable.",c : array_like        1-D array of polynomial coefficients ordered from low to        high.,out : ndarray        Array representing the result of the multiplication.
"polymul(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Multiply one polynomial by another.    Returns the product of two polynomials `c1` * `c2`.  The arguments are    sequences of coefficients, from lowest order term to highest, e.g.,    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``","c1, c2 : array_like        1-D arrays of coefficients representing a polynomial, relative to the        ""standard"" basis, and ordered from lowest order term to highest.",out : ndarray        Of the coefficients of their product.
"polydiv(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Divide one polynomial by another.    Returns the quotient-with-remainder of two polynomials `c1` / `c2`.    The arguments are sequences of coefficients, from lowest order term    to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.","c1, c2 : array_like        1-D arrays of polynomial coefficients ordered from low to high.","[quo, rem] : ndarrays        Of coefficient series representing the quotient and remainder."
"polypow(c, pow, maxpower=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py," Raise a polynomial to a power.    Returns the polynomial `c` raised to the power `pow`. The argument    `c` is a sequence of coefficients ordered from low to high. i.e.,    [1,2,3] is the series  ``1 + 2*x + 3*x**2.``","c : array_like        1-D array of array of series coefficients ordered from low to        high degree.    pow : integer        Power to which the series will be raised    maxpower : integer, optional        Maximum power allowed. This is mainly to limit growth of the series        to unmanageable size. Default is 16",coef : ndarray        Power series of power.
"polyder(c, m=1, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Differentiate a polynomial.    Returns the polynomial coefficients `c` differentiated `m` times along    `axis`.  At each iteration the result is multiplied by `scl` (the    scaling factor is for use in a linear change of variable).  The    argument `c` is an array of coefficients from low to high degree along    each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``    while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is    ``x`` and axis=1 is ``y``.","c : array_like        Array of polynomial coefficients. If c is multidimensional the        different axis correspond to different variables with the degree        in each axis given by the corresponding index.    m : int, optional        Number of derivatives taken, must be non-negative. (Default: 1)    scl : scalar, optional        Each differentiation is multiplied by `scl`.  The end result is        multiplication by ``scl**m``.  This is for use in a linear change        of variable. (Default: 1)    axis : int, optional        Axis over which the derivative is taken. (Default: 0).",der : ndarray        Polynomial coefficients of the derivative.
"polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Integrate a polynomial.    Returns the polynomial coefficients `c` integrated `m` times from    `lbnd` along `axis`.  At each iteration the resulting series is    **multiplied** by `scl` and an integration constant, `k`, is added.    The scaling factor is for use in a linear change of variable.  (""Buyer    beware"": note that, depending on what one is doing, one may want `scl`    to be the reciprocal of what one might expect; for more information,    see the Notes section below.) The argument `c` is an array of    coefficients, from low to high degree along each axis, e.g., [1,2,3]    represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]    represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is    ``y``.","c : array_like        1-D array of polynomial coefficients, ordered from low to high.    m : int, optional        Order of integration, must be positive. (Default: 1)    k : {[], list, scalar}, optional        Integration constant(s).  The value of the first integral at zero        is the first value in the list, the value of the second integral        at zero is the second value, etc.  If ``k == []`` (the default),        all constants are set to zero.  If ``m == 1``, a single scalar can        be given instead of a list.    lbnd : scalar, optional        The lower bound of the integral. (Default: 0)    scl : scalar, optional        Following each integration the result is *multiplied* by `scl`        before the integration constant is added. (Default: 1)    axis : int, optional        Axis over which the integral is taken. (Default: 0).",S : ndarray        Coefficient array of the integral.
"polyval(x, c, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a polynomial at points x.    If `c` is of length `n + 1`, this function returns the value    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `c`.    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If    `c` is multidimensional, then the shape of the result depends on the    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that    scalars have shape (,).    Trailing zeros in the coefficients will be used in the evaluation, so    they should be avoided if efficiency is a concern.","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `c`.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree n are contained in c[n]. If `c` is multidimensional the        remaining indices enumerate multiple polynomials. In the two        dimensional case the coefficients may be thought of as stored in        the columns of `c`.    tensor : boolean, optional        If True, the shape of the coefficient array is extended with ones        on the right, one for each dimension of `x`. Scalars have dimension 0        for this action. The result is that every column of coefficients in        `c` is evaluated for every element of `x`. If False, `x` is broadcast        over the columns of `c` for the evaluation.  This keyword is useful        when `c` is multidimensional. The default value is True.","values : ndarray, compatible object        The shape of the returned array is described above."
"polyvalfromroots(x, r, tensor=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a polynomial specified by its roots at points x.    If `r` is of length `N`, this function returns the value    .. math:: p(x) = \\prod_{n=1}^{N} (x - r_n)    The parameter `x` is converted to an array only if it is a tuple or a    list, otherwise it is treated as a scalar. In either case, either `x`    or its elements must support multiplication and addition both with    themselves and with the elements of `r`.    If `r` is a 1-D array, then `p(x)` will have the same shape as `x`.  If `r`    is multidimensional, then the shape of the result depends on the value of    `tensor`. If `tensor is ``True`` the shape will be r.shape[1:] + x.shape;    that is, each polynomial is evaluated at every value of `x`. If `tensor` is    ``False``, the shape will be r.shape[1:]; that is, each polynomial is    evaluated only for the corresponding broadcast value of `x`. Note that    scalars have shape (,).    .. versionadded:: 1.12","x : array_like, compatible object        If `x` is a list or tuple, it is converted to an ndarray, otherwise        it is left unchanged and treated as a scalar. In either case, `x`        or its elements must support addition and multiplication with        with themselves and with the elements of `r`.    r : array_like        Array of roots. If `r` is multidimensional the first index is the        root index, while the remaining indices enumerate multiple        polynomials. For instance, in the two dimensional case the roots        of each polynomial may be thought of as stored in the columns of `r`.    tensor : boolean, optional        If True, the shape of the roots array is extended with ones on the        right, one for each dimension of `x`. Scalars have dimension 0 for this        action. The result is that every column of coefficients in `r` is        evaluated for every element of `x`. If False, `x` is broadcast over the        columns of `r` for the evaluation.  This keyword is useful when `r` is        multidimensional. The default value is True.","values : ndarray, compatible object        The shape of the returned array is described above."
"polyval2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a 2-D polynomial at points (x, y).    This function returns the value    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars and they    must have the same shape after conversion. In either case, either `x`    and `y` or their elements must support multiplication and addition both    with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points `(x, y)`,        where `x` and `y` must have the same shape. If `x` or `y` is a list        or tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term        of multi-degree i,j is contained in `c[i,j]`. If `c` has        dimension greater than two the remaining indices enumerate multiple        sets of coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points formed with        pairs of corresponding values from `x` and `y`."
"polygrid2d(x, y, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a 2-D polynomial on the Cartesian product of x and y.    This function returns the values:    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j    where the points `(a, b)` consist of all pairs formed by taking    `a` from `x` and `b` from `y`. The resulting points form a grid with    `x` in the first dimension and `y` in the second.    The parameters `x` and `y` are converted to arrays only if they are    tuples or a lists, otherwise they are treated as a scalars. In either    case, either `x` and `y` or their elements must support multiplication    and addition both with themselves and with the elements of `c`.    If `c` has fewer than two dimensions, ones are implicitly appended to    its shape to make it 2-D. The shape of the result will be c.shape[2:] +    x.shape + y.shape.","x, y : array_like, compatible objects        The two dimensional series is evaluated at the points in the        Cartesian product of `x` and `y`.  If `x` or `y` is a list or        tuple, it is first converted to an ndarray, otherwise it is left        unchanged and, if it isn't an ndarray, it is treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"polyval3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a 3-D polynomial at points (x, y, z).    This function returns the values:    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k    The parameters `x`, `y`, and `z` are converted to arrays only if    they are tuples or a lists, otherwise they are treated as a scalars and    they must have the same shape after conversion. In either case, either    `x`, `y`, and `z` or their elements must support multiplication and    addition both with themselves and with the elements of `c`.    If `c` has fewer than 3 dimensions, ones are implicitly appended to its    shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape.","x, y, z : array_like, compatible object        The three dimensional series is evaluated at the points        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If        any of `x`, `y`, or `z` is a list or tuple, it is first converted        to an ndarray, otherwise it is left unchanged and if it isn't an        ndarray it is  treated as a scalar.    c : array_like        Array of coefficients ordered so that the coefficient of the term of        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension        greater than 3 the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the multidimensional polynomial on points formed with        triples of corresponding values from `x`, `y`, and `z`."
"polygrid3d(x, y, z, c):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Evaluate a 3-D polynomial on the Cartesian product of x, y and z.    This function returns the values:    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k    where the points `(a, b, c)` consist of all triples formed by taking    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form    a grid with `x` in the first dimension, `y` in the second, and `z` in    the third.    The parameters `x`, `y`, and `z` are converted to arrays only if they    are tuples or a lists, otherwise they are treated as a scalars. In    either case, either `x`, `y`, and `z` or their elements must support    multiplication and addition both with themselves and with the elements    of `c`.    If `c` has fewer than three dimensions, ones are implicitly appended to    its shape to make it 3-D. The shape of the result will be c.shape[3:] +    x.shape + y.shape + z.shape.","x, y, z : array_like, compatible objects        The three dimensional series is evaluated at the points in the        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a        list or tuple, it is first converted to an ndarray, otherwise it is        left unchanged and, if it isn't an ndarray, it is treated as a        scalar.    c : array_like        Array of coefficients ordered so that the coefficients for terms of        degree i,j are contained in ``c[i,j]``. If `c` has dimension        greater than two the remaining indices enumerate multiple sets of        coefficients.","values : ndarray, compatible object        The values of the two dimensional polynomial at points in the Cartesian        product of `x` and `y`."
"polyvander(x, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py," Vandermonde matrix of given degree.    Returns the Vandermonde matrix of degree `deg` and sample points    `x`. The Vandermonde matrix is defined by    .. math:: V[..., i] = x^i,    where `0 <= i <= deg`. The leading indices of `V` index the elements of    `x` and the last index is the power of `x`.    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the    matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and    ``polyval(x, c)`` are the same up to roundoff. This equivalence is    useful both for least squares fitting and for the evaluation of a large    number of polynomials of the same degree and sample points.",x : array_like        Array of points. The dtype is converted to float64 or complex128        depending on whether any of the elements are complex. If `x` is        scalar it is converted to a 1-D array.    deg : int        Degree of the resulting matrix.,"vander : ndarray.        The Vandermonde matrix. The shape of the returned matrix is        ``x.shape + (deg + 1,)``, where the last index is the power of `x`.        The dtype will be the same as the converted `x`."
"polyvander2d(x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y)`. The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of    `V` index the points `(x, y)` and the last index encodes the powers of    `x` and `y`.    If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`    correspond to the elements of a 2-D coefficient array `c` of shape    (xdeg + 1, ydeg + 1) in the order    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...    and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same    up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 2-D polynomials    of the same degrees and sample points.","x, y : array_like        Arrays of point coordinates, all of the same shape. The dtypes        will be converted to either float64 or complex128 depending on        whether any of the elements are complex. Scalars are converted to        1-D arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg].","vander2d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same        as the converted `x` and `y`."
"polyvander3d(x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py," Pseudo-Vandermonde matrix of given degrees.    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,    then The pseudo-Vandermonde matrix is defined by    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading    indices of `V` index the points `(x, y, z)` and the last index encodes    the powers of `x`, `y`, and `z`.    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns    of `V` correspond to the elements of a 3-D coefficient array `c` of    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the    same up to roundoff. This equivalence is useful both for least squares    fitting and for the evaluation of a large number of 3-D polynomials    of the same degrees and sample points.","x, y, z : array_like        Arrays of point coordinates, all of the same shape. The dtypes will        be converted to either float64 or complex128 depending on whether        any of the elements are complex. Scalars are converted to 1-D        arrays.    deg : list of ints        List of maximum degrees of the form [x_deg, y_deg, z_deg].","vander3d : ndarray        The shape of the returned matrix is ``x.shape + (order,)``, where        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will        be the same as the converted `x`, `y`, and `z`."
"polyfit(x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Least-squares fit of a polynomial to data.    Return the coefficients of a polynomial of degree `deg` that is the    least squares fit to the data values `y` given at points `x`. If `y` is    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple    fits are done, one for each column of `y`, and the resulting    coefficients are stored in the corresponding columns of a 2-D return.    The fitted polynomial(s) are in the form    .. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,    where `n` is `deg`.","x : array_like, shape (`M`,)        x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.    y : array_like, shape (`M`,) or (`M`, `K`)        y-coordinates of the sample points.  Several sets of sample points        sharing the same x-coordinates can be (independently) fit with one        call to `polyfit` by passing in for `y` a 2-D array that contains        one data set per column.    deg : int or 1-D array_like        Degree(s) of the fitting polynomials. If `deg` is a single integer        all terms up to and including the `deg`'th term are included in the        fit. For NumPy versions >= 1.11.0 a list of integers specifying the        degrees of the terms to include may be used instead.    rcond : float, optional        Relative condition number of the fit.  Singular values smaller        than `rcond`, relative to the largest singular value, will be        ignored.  The default value is ``len(x)*eps``, where `eps` is the        relative precision of the platform's float type, about 2e-16 in        most cases.    full : bool, optional        Switch determining the nature of the return value.  When ``False``        (the default) just the coefficients are returned; when ``True``,        diagnostic information from the singular value decomposition (used        to solve the fit's matrix equation) is also returned.    w : array_like, shape (`M`,), optional        Weights. If not None, the contribution of each point        ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the        weights are chosen so that the errors of the products ``w[i]*y[i]``        all have the same variance.  The default value is None.","coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)        Polynomial coefficients ordered from low to high.  If `y` was 2-D,        the coefficients in column `k` of `coef` represent the polynomial        fit to the data in `y`'s `k`-th column."
polycompanion(c):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polynomial.py,"     Return the companion matrix of c.    The companion matrix for power series cannot be made symmetric by    scaling the basis, so this function differs from those for the    orthogonal polynomials.",c : array_like        1-D array of polynomial coefficients ordered from low to high        degree.,"mat : ndarray        Companion matrix of dimensions (deg, deg)."
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,,,
trimseq(seq):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py, Remove small Poly series coefficients.,seq : sequence        Sequence of Poly series coefficients. This routine fails for        empty sequences.,"series : sequence        Subsequence with trailing zeros removed. If the resulting sequence        would be empty, return the first element. The returned sequence may        or may not be a view."
"as_series(alist, trim=True):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"     Return argument as a list of 1-d arrays.    The returned list contains array(s) of dtype double, complex double, or    object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of    size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays    of size ``N`` (i.e., is ""parsed by row""); and a higher dimensional array    raises a Value Error if it is not first reshaped into either a 1-d or 2-d    array.","alist : array_like        A 1- or 2-d array_like    trim : boolean, optional        When True, trailing zeros are removed from the inputs.        When False, the inputs are passed through intact.","[a1, a2,...] : list of 1-D arrays        A copy of the input data as a list of 1-d arrays."
"trimcoef(c, tol=0):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"     Remove ""small"" ""trailing"" coefficients from a polynomial.    ""Small"" means ""small in absolute value"" and is controlled by the    parameter `tol`; ""trailing"" means highest order coefficient(s), e.g., in    ``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)    both the 3-rd and 4-th order coefficients would be ""trimmed.""","c : array_like        1-d array of coefficients, ordered from lowest order to highest.    tol : number, optional        Trailing (i.e., highest order) elements with absolute value less        than or equal to `tol` (default value is zero) are removed.","trimmed : ndarray        1-d array with trailing zeros removed.  If the resulting series        would be empty, a series containing a single zero is returned."
getdomain(x):,https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Return a domain suitable for given abscissae.    Find a domain suitable for a polynomial or Chebyshev series    defined at the values supplied.,x : array_like        1-d array of abscissae whose domain will be determined.,"domain : ndarray        1-d array containing two values.  If the inputs are complex, then        the two returned points are the lower left and upper right corners        of the smallest rectangle (aligned with the axes) in the complex        plane containing the points `x`. If the inputs are real, then the        two points are the ends of the smallest interval containing the        points `x`."
"mapparms(old, new):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"     Linear map parameters between domains.    Return the parameters of the linear map ``offset + scale*x`` that maps    `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.","old, new : array_like        Domains. Each domain must (successfully) convert to a 1-d array        containing precisely two values.","offset, scale : scalars        The map ``L(x) = offset + scale*x`` maps the first domain to the        second."
"mapdomain(x, old, new):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Apply linear map to input points.    The linear map ``offset + scale*x`` that maps the domain `old` to    the domain `new` is applied to the points `x`.,"x : array_like        Points to be mapped. If `x` is a subtype of ndarray the subtype        will be preserved.    old, new : array_like        The two domains that determine the map.  Each must (successfully)        convert to 1-d arrays containing precisely two values.","x_out : ndarray        Array of points of the same shape as `x`, after application of the        linear map between the two domains."
"_vander2d(vander_f, x, y, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>vander2d`` functions.,"vander_f : function(array_like, int) -> ndarray        The 1d vander function, such as ``polyvander``    x, y, deg :        See the ``<type>vander2d`` functions for more detail """"""    degx, degy = [        _deprecate_as_int(d, ""degrees"") for d in deg    ]    x, y = np.array((x, y), copy=0) + 0.0
    vx = vander_f(x, degx)    vy = vander_f(y, degy)    v = vx[..., None]*vy[..., None,:] return v.reshape(v.shape[:-2] + (-1,))

",
"_vander3d(vander_f, x, y, z, deg):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>vander3d`` functions.,"vander_f : function(array_like, int) -> ndarray        The 1d vander function, such as ``polyvander``    x, y, z, deg :        See the ``<type>vander3d`` functions for more detail """"""    degx, degy, degz = [        _deprecate_as_int(d, ""degrees"") for d in deg    ]    x, y, z = np.array((x, y, z), copy=0) + 0.0
    vx = vander_f(x, degx)    vy = vander_f(y, degy)    vz = vander_f(z, degz)    v = vx[..., None, None]*vy[..., None,:, None]*vz[..., None, None,:] return v.reshape(v.shape[:-3] + (-1,))

",
"_fromroots(line_f, mul_f, roots):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>fromroots`` functions.,"line_f : function(float, float) -> ndarray        The ``<type>line`` function, such as ``polyline``    mul_f : function(array_like, array_like) -> ndarray        The ``<type>mul`` function, such as ``polymul``    roots :        See the ``<type>fromroots`` functions for more detail """""" if len(roots) == 0: return np.ones(1) else:        [roots] = as_series([roots], trim=False)        roots.sort()        p = [line_f(-r, 1) for r in roots]        n = len(p) while n > 1:            m, r = divmod(n, 2)            tmp = [mul_f(p[i], p[i+m]) for i in range(m)] if r:                tmp[0] = mul_f(tmp[0], p[-1])            p = tmp            n = m return p[0]

",
"_valnd(val_f, c, *args):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>val<n>d`` functions.,"val_f : function(array_like, array_like, tensor: bool) -> array_like        The ``<type>val`` function, such as ``polyval``    c, args :        See the ``<type>val<n>d`` functions for more detail """""" try:        args = tuple(np.array(args, copy=False)) except Exception: # preserve the old error message if len(args) == 2: raise ValueError('x, y, z are incompatible') elif len(args) == 3: raise ValueError('x, y are incompatible') else: raise ValueError('ordinates are incompatible')
    it = iter(args)    x0 = next(it)
 # use tensor on only the first    c = val_f(x0, c) for xi in it:        c = val_f(xi, c, tensor=False) return c

",
"_gridnd(val_f, c, *args):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>grid<n>d`` functions.,"val_f : function(array_like, array_like, tensor: bool) -> array_like        The ``<type>val`` function, such as ``polyval``    c, args :        See the ``<type>grid<n>d`` functions for more detail """""" for xi in args:        c = val_f(xi, c) return c

",
"_div(mul_f, c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"     Helper function used to implement the ``<type>div`` functions.    Implementation uses repeated subtraction of c2 multiplied by the nth basis.    For some polynomial types, a more efficient approach may be possible.","mul_f : function(array_like, array_like) -> array_like        The ``<type>mul`` function, such as ``polymul``    c1, c2 :        See the ``<type>div`` functions for more detail """""" # c1, c2 are trimmed copies    [c1, c2] = as_series([c1, c2]) if c2[-1] == 0: raise ZeroDivisionError()
    lc1 = len(c1)    lc2 = len(c2) if lc1 < lc2: return c1[:1]*0, c1 elif lc2 == 1: return c1/c2[-1], c1[:1]*0 else:        quo = np.empty(lc1 - lc2 + 1, dtype=c1.dtype)        rem = c1 for i in range(lc1 - lc2, - 1, -1):            p = mul_f([0]*i + [1], c2)            q = rem[-1]/p[-1]            rem = rem[:-1] - q*p[:-1]            quo[i] = q return quo, trimseq(rem)

",
"_add(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"  Helper function used to implement the ``<type>add`` functions.  # c1, c2 are trimmed copies    [c1, c2] = as_series([c1, c2]) if len(c1) > len(c2):        c1[:c2.size] += c2        ret = c1 else:        c2[:c1.size] += c1        ret = c2 return trimseq(ret)

",,
"_sub(c1, c2):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,"  Helper function used to implement the ``<type>sub`` functions.  # c1, c2 are trimmed copies    [c1, c2] = as_series([c1, c2]) if len(c1) > len(c2):        c1[:c2.size] -= c2        ret = c1 else:        c2 = -c2        c2[:c1.size] += c1        ret = c2 return trimseq(ret)

",,
"_fit(vander_f, x, y, deg, rcond=None, full=False, w=None):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>fit`` functions.,"vander_f : function(array_like, int) -> ndarray        The 1d vander function, such as ``polyvander``    c1, c2 :        See the ``<type>fit`` functions for more detail """"""    x = np.asarray(x) + 0.0    y = np.asarray(y) + 0.0    deg = np.asarray(deg)
 # check arguments. if deg.ndim > 1 or deg.dtype.kind not in 'iu' or deg.size == 0: raise TypeError(""deg must be an int or non-empty 1-D array of int"") if deg.min() < 0: raise ValueError(""expected deg >= 0"") if x.ndim != 1: raise TypeError(""expected 1D vector for x"") if x.size == 0: raise TypeError(""expected non-empty vector for x"") if y.ndim < 1 or y.ndim > 2: raise TypeError(""expected 1D or 2D array for y"") if len(x) != len(y): raise TypeError(""expected x and y to have same length"")
 if deg.ndim == 0:        lmax = deg        order = lmax + 1        van = vander_f(x, lmax) else:        deg = np.sort(deg)        lmax = deg[-1]        order = len(deg)        van = vander_f(x, lmax)[:, deg]
 # set up the least squares matrices in transposed form    lhs = van.T    rhs = y.T if w is not None:        w = np.asarray(w) + 0.0 if w.ndim != 1: raise TypeError(""expected 1D vector for w"") if len(x) != len(w): raise TypeError(""expected x and w to have same length"") # apply weights. Don't use inplace operations as they # can cause problems with NA.        lhs = lhs * w        rhs = rhs * w
 # set rcond if rcond is None:        rcond = len(x)*np.finfo(x.dtype).eps
 # Determine the norms of the design matrix columns. if issubclass(lhs.dtype.type, np.complexfloating):        scl = np.sqrt((np.square(lhs.real) + np.square(lhs.imag)).sum(1)) else:        scl = np.sqrt(np.square(lhs).sum(1))    scl[scl == 0] = 1
 # Solve the least squares problem.    c, resids, rank, s = np.linalg.lstsq(lhs.T/scl, rhs.T, rcond)    c = (c.T/scl).T
 # Expand c to include non-fitted coefficients which are set to zero if deg.ndim > 0: if c.ndim == 2:            cc = np.zeros((lmax+1, c.shape[1]), dtype=c.dtype) else:            cc = np.zeros(lmax+1, dtype=c.dtype)        cc[deg] = c        c = cc
 # warn on rank reduction if rank != order and not full:        msg = ""The fit may be poorly conditioned""        warnings.warn(msg, RankWarning, stacklevel=2)
 if full: return c, [resids, rank, s, rcond] else: return c

",
"_pow(mul_f, c, pow, maxpower):",https://github.com//numpy/numpy/blob/master/numpy/polynomial/polyutils.py,     Helper function used to implement the ``<type>pow`` functions.,"vander_f : function(array_like, int) -> ndarray        The 1d vander function, such as ``polyvander``    pow, maxpower :        See the ``<type>pow`` functions for more detail    mul_f : function(array_like, array_like) -> ndarray        The ``<type>mul`` function, such as ``polymul`` """""" # c is a trimmed copy    [c] = as_series([c])    power = int(pow) if power != pow or power < 0: raise ValueError(""Power must be a non-negative integer."") elif maxpower is not None and power > maxpower: raise ValueError(""Power is too large"") elif power == 0: return np.array([1], dtype=c.dtype) elif power == 1: return c else: # This can be made more efficient by using powers of two # in the usual way.        prd = c for i in range(2, power + 1):            prd = mul_f(prd, c) return prd

",
,https://github.com//numpy/numpy/blob/master/numpy/polynomial/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/examples/numba/extending.py,,,
"bounded_uint(lb, ub, state):",https://github.com//numpy/numpy/blob/master/numpy/random/examples/numba/extending.py,,,
"bounded_uints(lb, ub, n, state):",https://github.com//numpy/numpy/blob/master/numpy/random/examples/numba/extending.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/examples/numba/extending_distributions.py,"rOn *nix, execute in randomgen/src/distributionsexport PYTHON_INCLUDE=#path to Python's include folder, usually \    ${PYTHON_HOME}/include/python${PYTHON_VERSION}mexport NUMPY_INCLUDE=#path to numpy's include folder, usually \    ${PYTHON_HOME}/lib/python${PYTHON_VERSION}/site-packages/numpy/core/includegcc -shared -o libdistributions.so -fPIC distributions.c \    -I${NUMPY_INCLUDE} -I${PYTHON_INCLUDE}mv libdistributions.so ../../examples/numba/On Windowsrem PYTHON_HOME is setup dependent, this is an exampleset PYTHON_HOME=c:\Anacondacl.exe /LD .\distributions.c -DDLL_EXPORT \    -I%PYTHON_HOME%\lib\site-packages\numpy\core\include \    -I%PYTHON_HOME%\include %PYTHON_HOME%\libs\python36.libmove distributions.dll ../../examples/numba/",,
,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
"assert_state_equal(actual, target):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform32_from_uint64(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform32_from_uint53(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform32_from_uint32(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
"uniform32_from_uint(x, bits):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
"uniform_from_uint(x, bits):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform_from_uint64(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform_from_uint32(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
uniform_from_dsfmt(x):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_direct.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_generator_mt19937.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_randomstate.py,,,
int_func(request):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_randomstate.py,,,
"assert_mt19937_state_equal(a, b):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_randomstate.py,,,
test_integer_dtype(int_func):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_randomstate.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_smoke.py,,,
dtype(request):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_smoke.py,,,
params_0(f):,https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_smoke.py,,,
"params_1(f, bounded=False):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_smoke.py,,,
"comp_state(state1, state2):",https://github.com//numpy/numpy/blob/master/numpy/random/tests/test_smoke.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/random/__init__.py,"========================Random Number Generation========================Instantiate a BitGenerator and wrap it in a Generatorwhich will convert the uniform stream to a number of distributions. The ""bare""functions are kept for legacy code, they should be called with the newer APIvia ``np.random.Generator().function`` instead==================== =========================================================Utility functions-------------------- ---------------------------------------------------------random               Uniformly distributed floats over ``[0, 1)``integers             Uniformly distributed integers, replaces ``randint``bytes                Uniformly distributed random bytes.permutation          Randomly permute a sequence / generate a random sequence.shuffle              Randomly permute a sequence in place.seed                 Seed the random number generator.choice               Random sample from 1-D array.==================== ============================================================================= =========================================================Compatibilityfunctions - removedin the new API-------------------- ---------------------------------------------------------rand                 Uniformly distributed values.randn                Normally distributed values.ranf                 Uniformly distributed floating point numbers.random_integers      Uniformly distributed integers in a given range.                     (deprecated, use ``integers(..., closed=True)`` instead)random_sample        Alias for `random_sample`randint              Uniformly distributed integers in a given range==================== ============================================================================= =========================================================Univariatedistributions-------------------- ---------------------------------------------------------beta                 Beta distribution over ``[0, 1]``.binomial             Binomial distribution.chisquare            :math:`\\chi^2` distribution.exponential          Exponential distribution.f                    F (Fisher-Snedecor) distribution.gamma                Gamma distribution.geometric            Geometric distribution.gumbel               Gumbel distribution.hypergeometric       Hypergeometric distribution.laplace              Laplace distribution.logistic             Logistic distribution.lognormal            Log-normal distribution.logseries            Logarithmic series distribution.negative_binomial    Negative binomial distribution.noncentral_chisquare Non-central chi-square distribution.noncentral_f         Non-central F distribution.normal               Normal / Gaussian distribution.pareto               Pareto distribution.poisson              Poisson distribution.power                Power distribution.rayleigh             Rayleigh distribution.triangular           Triangular distribution.uniform              Uniform distribution.vonmises             Von Mises circular distribution.wald                 Wald (inverse Gaussian) distribution.weibull              Weibull distribution.zipf                 Zipf's distribution over ranked data.==================== ============================================================================= ==========================================================Multivariatedistributions-------------------- ----------------------------------------------------------dirichlet            Multivariate generalization of Beta distribution.multinomial          Multivariate generalization of the binomial distribution.multivariate_normal  Multivariate generalization of the normal distribution.==================== ============================================================================== =========================================================Standarddistributions-------------------- ---------------------------------------------------------standard_cauchy      Standard Cauchy-Lorentz distribution.standard_exponential Standard exponential distribution.standard_gamma       Standard Gamma distribution.standard_normal      Standard normal distribution.standard_t           Standard Student's t-distribution.==================== ============================================================================= =========================================================Internal functions-------------------- ---------------------------------------------------------get_state            Get tuple representing internal state of generator.set_state            Set state of generator.==================== ====================================================================================================== ===BitGenerator Streams that work with Generator--------------------------------------------- ---MT19937PCG64Philox============================================= ===",,
,https://github.com//numpy/numpy/blob/master/numpy/random/_pickle.py,,,
__generator_ctor(bit_generator_name='mt19937'):,https://github.com//numpy/numpy/blob/master/numpy/random/_pickle.py,     Pickling helper function that returns a Generator object,bit_generator_name: str        String containing the core BitGenerator,"rg: Generator        Generator using the named core BitGenerator """""" if bit_generator_name in BitGenerators:        bit_generator = BitGenerators[bit_generator_name] else: raise ValueError(str(bit_generator_name) + ' is not a known ' 'BitGenerator module.')
 return Generator(bit_generator())

"
__bit_generator_ctor(bit_generator_name='mt19937'):,https://github.com//numpy/numpy/blob/master/numpy/random/_pickle.py,     Pickling helper function that returns a bit generator object,bit_generator_name: str        String containing the name of the BitGenerator,"bit_generator: BitGenerator        BitGenerator instance """""" if bit_generator_name in BitGenerators:        bit_generator = BitGenerators[bit_generator_name] else: raise ValueError(str(bit_generator_name) + ' is not a known ' 'BitGenerator module.')
 return bit_generator()

"
,https://github.com//numpy/numpy/blob/master/numpy/random/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,"Decorators for labeling and modifying behavior of test objects.Decorators that merely return a modified version of the originalfunction object are straightforward. Decorators that return a newfunction object need to use::  nose.tools.make_decorator(original_function)(decorator)in returning the decorator, in order to preserve meta-data such asfunction name, setup and teardown functions and so on - see``nose.tools`` for more information.",,
slow(t):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,"     Label a test as 'slow'.    The exact definition of a slow test is obviously both subjective and    hardware-dependent, but in general any individual test that requires more    than a second or two should be labeled as slow (the whole suite consists of    thousands of tests, so even a second is significant).",t : callable        The test to label as slow.,t : callable        The decorated test `t`.
setastest(tf=True):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,     Signals to nose that this function is or is not a test.,"tf : bool        If True, specifies that the decorated callable is a test.        If False, specifies that the decorated callable is not a test.        Default is True.",
"skipif(skip_condition, msg=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,"     Make function raise SkipTest exception if a given condition is true.    If the condition is a callable, it is used at runtime to dynamically    make the decision. This is useful for tests that may require costly    imports, to delay the cost until the test suite is actually executed.","skip_condition : bool or callable        Flag to determine whether to skip the decorated test.    msg : str, optional        Message to give on raising a SkipTest exception. Default is None.","decorator : function        Decorator which, when applied to a function, causes SkipTest        to be raised when `skip_condition` is True, and the function        to be called normally otherwise."
"knownfailureif(fail_condition, msg=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,"     Make function raise KnownFailureException exception if given condition is true.    If the condition is a callable, it is used at runtime to dynamically    make the decision. This is useful for tests that may require costly    imports, to delay the cost until the test suite is actually executed.","fail_condition : bool or callable        Flag to determine whether to mark the decorated test as a known        failure (if True) or not (if False).    msg : str, optional        Message to give on raising a KnownFailureException exception.        Default is None.","decorator : function        Decorator, which, when applied to a function, causes        KnownFailureException to be raised when `fail_condition` is True,        and the function to be called normally otherwise."
deprecated(conditional=True):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/decorators.py,"     Filter deprecation warnings while running the test suite.    This decorator can be used to filter DeprecationWarning's, to avoid    printing them during the test suite run, while checking that the test    actually raises a DeprecationWarning.","conditional : bool or callable, optional        Flag to determine whether to mark test as deprecated or not. If the        condition is a callable, it is used at runtime to dynamically make the        decision. Default is True.",decorator : function        The `deprecated` decorator itself.
,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/nosetester.py,,,
get_package_name(filepath):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/nosetester.py,"     Given a path where a package is installed, determine its name.","filepath : str        Path to a file. If the determination fails, ""numpy"" is returned.",
"run_module_suite(file_to_run=None, argv=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/nosetester.py,     Run a test module.    Equivalent to calling ``$ nosetests <argv> <file_to_run>`` from    the command line,"file_to_run : str, optional        Path to test module, or None.        By default, run the module from which this function is called.    argv : list of strings        Arguments to be passed to the nose test runner. ``argv[0]`` is        ignored. All command line arguments accepted by ``nosetests``        will work. If it is the default value None, sys.argv is used.package : module, str or None, optional        The package to test. If a string, this should be the full path to        the package. If None (default), `package` is set to the module from        which `NoseTester` is initialized.    raise_warnings : None, str or sequence of warnings, optional        This specifies which warnings to configure as 'raise' instead        of being shown once during the test execution.  Valid strings are:",
,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py,"tl;dr: all code code is licensed under simplified BSD, unless stated otherwise.Unless stated otherwise in the source files, all code is copyright 2010 DavidWolever <david@wolever.net>. All rights reserved.Redistribution and use in source and binary forms, with or withoutmodification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND ANY EXPRESS ORIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NOEVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OFLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCEOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IFADVISED OF THE POSSIBILITY OF SUCH DAMAGE.The views and conclusions contained in the software and documentation are thoseof the authors and should not be interpreted as representing official policies,either expressed or implied, of David Wolever.",,
"parameterized_argument_value_pairs(func, p):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py," Return tuples of parameterized arguments and their values.        This is useful if you are writing your own doc_func        function and need to know the values for each parameter name:: >>> def func(a, foo=None, bar=42, **kwargs): pass >>> p = param(1, foo=7, extra=99) >>> parameterized_argument_value_pairs(func, p)            [(""a"", 1), (""foo"", 7), (""bar"", 42), (""**kwargs"", {""extra"": 99})]        If the function's first argument is named ``self`` then it will be        ignored:: >>> def func(self, a): pass >>> p = param(1) >>> parameterized_argument_value_pairs(func, p)            [(""a"", 1)]        Additionally, empty ``*args`` or ``**kwargs`` will be ignored:: >>> def func(foo, *args): pass >>> p = param(1) >>> parameterized_argument_value_pairs(func, p)            [(""foo"", 1)] >>> p = param(1, 16) >>> parameterized_argument_value_pairs(func, p)            [(""foo"", 1), (""*args"", (16, ))]",,
"short_repr(x, n=64):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py,"  A shortened repr of ``x`` which is guaranteed to be ``unicode``:: >>> short_repr(""foo"")            u""foo"" >>> short_repr(""123456789"", n=4)            u""12...89""",,
"default_doc_func(func, num, p):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py,,,
"default_name_func(func, num, p):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py,,,
set_test_runner(name):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/parameterized.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
import_nose():,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,  Import nose only when needed.,,
"assert_(val, msg=''):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Assert that works in release mode.    Accepts callable msg to allow deferring evaluation until failure.    The Python built-in ``assert`` does not work when executing code in    optimized mode (the ``-O`` flag) - no byte-code is generated for it.    For documentation on usage, refer to the Python documentation.",,
gisnan(x):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," like isnan, but always raise an error if type not supported instead of    returning a TypeError object.    Notes    -----    isnan and other ufunc sometimes return a NotImplementedType object instead    of raising any exception. This function is a wrapper to make sure an    exception is always raised.",,
gisfinite(x):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," like isfinite, but always raise an error if type not supported instead of    returning a TypeError object.    Notes    -----    isfinite and other ufunc sometimes return a NotImplementedType object instead    of raising any exception. This function is a wrapper to make sure an    exception is always raised.",,
gisinf(x):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," like isinf, but always raise an error if type not supported instead of    returning a TypeError object.    Notes    -----    isinf and other ufunc sometimes return a NotImplementedType object instead    of raising any exception. This function is a wrapper to make sure an    exception is always raised.",,
rand(*args):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," Returns an array of random numbers with the given shape.    This only uses the standard library, so it is useful for testing purposes.",,
"build_err_msg(arrays, err_msg, header='Items are not equal:',",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
"assert_equal(actual, desired, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two objects are not equal.    Given two objects (scalars, lists, tuples, dictionaries or numpy arrays),    check that all elements of these objects are equal. An exception is raised    at the first conflicting values.    This function handles NaN comparisons as if NaN was a ""normal"" number.    That is, no assertion is raised if both objects have NaNs in the same    positions.  This is in contrast to the IEEE standard on NaNs, which says    that NaN compared to anything must return False.","actual : array_like        The object to check.    desired : array_like        The expected object.    err_msg : str, optional        The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"print_assert_equal(test_string, actual, desired):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Test if two objects are equal, and print an error message if test fails.    The test is performed with ``actual == desired``.",test_string : str        The message supplied to AssertionError.    actual : object        The object to test for equality against `desired`.    desired : object        The expected result.,
"assert_almost_equal(actual,desired,decimal=7,err_msg='',verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two items are not equal up to desired    precision.    .. note:: It is recommended to use one of `assert_allclose`,              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`              instead of this function for more consistent floating point              comparisons.    The test verifies that the elements of ``actual`` and ``desired`` satisfy.        ``abs(desired-actual) < 1.5 * 10**(-decimal)``    That is a looser test than originally documented, but agrees with what the    actual implementation in `assert_array_almost_equal` did up to rounding    vagaries. An exception is raised at conflicting values. For ndarrays this    delegates to assert_array_almost_equal","actual : array_like        The object to check.    desired : array_like        The expected object.    decimal : int, optional        Desired precision, default is 7.    err_msg : str, optional        The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two items are not equal up to significant    digits.    .. note:: It is recommended to use one of `assert_allclose`,              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`              instead of this function for more consistent floating point              comparisons.    Given two numbers, check that they are approximately equal.    Approximately equal is defined as the number of significant digits    that agree.","actual : scalar        The object to check.    desired : scalar        The expected object.    significant : int, optional        Desired precision, default is 7.    err_msg : str, optional        The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"assert_array_compare(comparison, x, y, err_msg='', verbose=True,",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," Handling nan/inf.        Combine results of running func on x and y, checking that they are True        at the same locations.",,
"assert_array_equal(x, y, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two array_like objects are not equal.    Given two array_like objects, check that the shape is equal and all    elements of these objects are equal. An exception is raised at    shape mismatch or conflicting values. In contrast to the standard usage    in numpy, NaNs are compared like numbers, no assertion is raised if    both objects have NaNs in the same positions.    The usual caution for verifying equality with floating point numbers is    advised.","x : array_like        The actual object to check.    y : array_like        The desired, expected object.    err_msg : str, optional        The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two objects are not equal up to desired    precision.    .. note:: It is recommended to use one of `assert_allclose`,              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`              instead of this function for more consistent floating point              comparisons.    The test verifies identical shapes and that the elements of ``actual`` and    ``desired`` satisfy.        ``abs(desired-actual) < 1.5 * 10**(-decimal)``    That is a looser test than originally documented, but agrees with what the    actual implementation did up to rounding vagaries. An exception is raised    at shape mismatch or conflicting values. In contrast to the standard usage    in numpy, NaNs are compared like numbers, no assertion is raised if both    objects have NaNs in the same positions.","x : array_like        The actual object to check.    y : array_like        The desired, expected object.    decimal : int, optional        Desired precision, default is 6.    err_msg : str, optional      The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"assert_array_less(x, y, err_msg='', verbose=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two array_like objects are not ordered by less    than.    Given two array_like objects, check that the shape is equal and all    elements of the first object are strictly smaller than those of the    second object. An exception is raised at shape mismatch or incorrectly    ordered values. Shape mismatch does not raise if an object has zero    dimension. In contrast to the standard usage in numpy, NaNs are    compared, no assertion is raised if both objects have NaNs in the same    positions.","x : array_like      The smaller object to check.    y : array_like      The larger object to compare.    err_msg : string      The error message to be printed in case of failure.    verbose : bool        If True, the conflicting values are appended to the error message.",
"runstring(astr, dict):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
"assert_string_equal(actual, desired):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Test if two strings are equal.    If the given strings are equal, `assert_string_equal` does nothing.    If they are not equal, an AssertionError is raised, and the diff    between the strings is shown.",actual : str        The string to test for equality against the expected string.    desired : str        The expected string.,
"rundocs(filename=None, raise_on_error=True):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,     Run doctests found in the given file.    By default `rundocs` raises an AssertionError on failure.,filename : str        The path to the file for which the doctests are run.    raise_on_error : bool        Whether to raise an AssertionError when a doctest fails. Default is        True.,
raises(*args):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," Decorator to check for raised exceptions.    The decorated test function must raise one of the passed exceptions to    pass.  If you want to test many assertions about exceptions in a single    test, you may want to use `assert_raises` instead.    .. warning::       This decorator is nose specific, do not use it if you are using a       different test framework.",args : exceptions        The test passes if any of the passed exceptions is raised.,
"assert_raises(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     assert_raises(exception_class, callable, *args, **kwargs)    assert_raises(exception_class)    Fail unless an exception of class exception_class is thrown    by callable when invoked with arguments args and keyword    arguments kwargs. If a different type of exception is    thrown, it will not be caught, and the test case will be    deemed to have suffered an error, exactly as for an    unexpected exception.    Alternatively, `assert_raises` can be used as a context manager: >>> from numpy.testing import assert_raises >>> with assert_raises(ZeroDivisionError): ...     1 / 0    is equivalent to >>> def div(x, y): ...     return x / y >>> assert_raises(ZeroDivisionError, div, 1, 0)",,
"assert_raises_regex(exception_class, expected_regexp, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     assert_raises_regex(exception_class, expected_regexp, callable, *args,                        **kwargs)    assert_raises_regex(exception_class, expected_regexp)    Fail unless an exception of class exception_class and with message that    matches expected_regexp is thrown by callable when invoked with arguments    args and keyword arguments kwargs.    Alternatively, can be used as a context manager like `assert_raises`.    Name of this function adheres to Python 3.2+ reference, but should work in    all versions down to 2.6.    Notes    -----    .. versionadded:: 1.9.0",,
"decorate_methods(cls, decorator, testmatch=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Apply a decorator to all methods in a class matching a regular expression.    The given decorator is applied to all public methods of `cls` that are    matched by the regular expression `testmatch`    (``testmatch.search(methodname)``). Methods that are private, i.e. start    with an underscore, are ignored.","cls : class        Class whose methods to decorate.    decorator : function        Decorator to apply to methods    testmatch : compiled regexp or str, optional        The regular expression. Default value is None, in which case the        nose default (``re.compile(r'(?:^|[\\b_\\.%s-])[Tt]est' % os.sep)``)        is used.        If `testmatch` is a string, it is compiled to a regular expression        first.",
"measure(code_str, times=1, label=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Return elapsed time for executing code in the namespace of the caller.    The supplied code string is compiled with the Python builtin ``compile``.    The precision of the timing is 10 milli-seconds. If the code will execute    fast on this timescale, it can be executed many times to get reasonable    timing accuracy.","code_str : str        The code to be timed.    times : int, optional        The number of times the code is executed. Default is 1. The code is        only compiled once.    label : str, optional        A label to identify `code_str` with. This is passed into ``compile``        as the second argument (for run-time error messages).",elapsed : float        Total elapsed time in seconds for executing `code_str` `times` times.
_assert_valid_refcount(op):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,     Check that ufuncs don't mishandle refcount of object `1`.    Used in a few regression tests.,,
"assert_allclose(actual, desired, rtol=1e-7, atol=0, equal_nan=True,",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Raises an AssertionError if two objects are not equal up to desired    tolerance.    The test is equivalent to ``allclose(actual, desired, rtol, atol)`` (note    that ``allclose`` has different default values). It compares the difference    between `actual` and `desired` to ``atol + rtol * abs(desired)``.    .. versionadded:: 1.5.0","actual : array_like        Array obtained.    desired : array_like        Array desired.    rtol : float, optional        Relative tolerance.    atol : float, optional        Absolute tolerance.    equal_nan : bool, optional.        If True, NaNs will compare equal.    err_msg : str, optional        The error message to be printed in case of failure.    verbose : bool, optional        If True, the conflicting values are appended to the error message.",
"assert_array_almost_equal_nulp(x, y, nulp=1):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,     Compare two arrays relatively to their spacing.    This is a relatively robust method to compare two arrays whose amplitude    is variable.,"x, y : array_like        Input arrays.    nulp : int, optional        The maximum number of unit in the last place for tolerance (see Notes).        Default is 1.",None
"assert_array_max_ulp(a, b, maxulp=1, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,     Check that all items of arrays differ in at most N Units in the Last Place.,"a, b : array_like        Input arrays to be compared.    maxulp : int, optional        The maximum number of units in the last place that elements of `a` and        `b` can differ. Default is 1.    dtype : dtype, optional        Data-type to convert `a` and `b` to if given. Default is None.",ret : ndarray        Array containing number of representable floating point numbers between        items in `a` and `b`.
"nulp_diff(x, y, dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," For each item in x and y, return the number of representable floating    points between them.","x : array_like        first input array    y : array_like        second input array    dtype : dtype, optional        Data-type to convert `x` and `y` to if given. Default is None.",nulp : array_like        number of representable floating point numbers between each item in x        and y.
"_integer_repr(x, vdt, comp):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
integer_repr(x):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py, Return the signed-magnitude interpretation of the binary representation of,,
"_assert_warns_context(warning_class, name=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
"assert_warns(warning_class, *args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Fail unless the given callable throws the specified warning.    A warning of class warning_class should be thrown by the callable when    invoked with arguments args and keyword arguments kwargs.    If a different type of warning is thrown, it will not be caught.    If called with all arguments other than the warning class omitted, may be    used as a context manager:        with assert_warns(SomeWarning):            do_something()    The ability to be used as a context manager is new in NumPy v1.11.0.    .. versionadded:: 1.4.0",warning_class : class        The class defining the warning that `func` is expected to throw.    func : callable        The callable to test. \\*args : Arguments        Arguments passed to `func`. \\*\\*kwargs : Kwargs        Keyword arguments passed to `func`.,The value returned by `func`.
_assert_no_warnings_context(name=None):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
"assert_no_warnings(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Fail if the given callable produces any warnings.    If called with all arguments omitted, may be used as a context manager:        with assert_no_warnings():            do_something()    The ability to be used as a context manager is new in NumPy v1.11.0.    .. versionadded:: 1.7.0",func : callable        The callable to test. \\*args : Arguments        Arguments passed to `func`. \\*\\*kwargs : Kwargs        Keyword arguments passed to `func`.,The value returned by `func`.
"_gen_alignment_data(dtype=float32, type='binary', max_size=24):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,     generator producing data with different alignment and offsets    to test simd vectorization,"dtype : dtype        data type to produce    type : string        'unary': create data for unary operations, creates one input                 and output array        'binary': create data for unary operations, creates two input                 and output array    max_size : integer        maximum size of data to produce","if type is 'unary' yields one output, one input array and a message    containing information on the data    if type is 'binary' yields one output array, two input array and a message    containing information on the data"
"tempdir(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py, Context manager to provide a temporary test folder.    All arguments are passed as this to the underlying tempfile.mkdtemp    function.,,
"temppath(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py," Context manager for temporary files.    Context manager that returns the path to a closed temporary file. Its    parameters are the same as for tempfile.mkstemp and are passed directly    to that function. The underlying file is removed when the context is    exited, so it should be closed at that time.    Windows does not allow a temporary file to be opened if it is already    open, so the underlying file must be closed after opening before it    can be opened again.","record : bool, optional        Specifies whether warnings should be captured by a custom        implementation of ``warnings.showwarning()`` and be appended to a list        returned by the context manager. Otherwise None is returned by the        context manager. The objects appended to the list are arguments whose        attributes mirror the arguments to ``showwarning()``.    modules : sequence, optional        Sequence of modules for which to reset warnings registry on entry and        restore on exit. To work correctly, all 'ignore' filters should        filter by one of these modules.forwarding_rule : str, optional        One of ""always"", ""once"", ""module"", or ""location"". Analogous to        the usual warnings module filter mode, it is useful to reduce        noise mostly on the outmost level. Unsuppressed and unrecorded        warnings will be forwarded based on this rule. Defaults to ""always"".        ""location"" is equivalent to the warnings ""default"", match by exact        location the warning warning originated from.",
_assert_no_gc_cycles_context(name=None):,https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,,,
"assert_no_gc_cycles(*args, **kwargs):",https://github.com//numpy/numpy/blob/master/numpy/testing/_private/utils.py,"     Fail if the given callable produces any reference cycles.    If called with all arguments omitted, may be used as a context manager:        with assert_no_gc_cycles():            do_something()    .. versionadded:: 1.15.0",func : callable        The callable to test. \\*args : Arguments        Arguments passed to `func`. \\*\\*kwargs : Kwargs        Keyword arguments passed to `func`.,Nothing. The result is deliberately discarded to ensure that all cycles    are found.
,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_doctesting.py,,,
check_random_directive():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_doctesting.py,,,
check_implicit_np():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_doctesting.py,,,
check_whitespace_enabled():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_doctesting.py,,,
check_empty_output():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_doctesting.py,  Check that no output does not cause an error.    This is related to nose bug 445; the numpy plugin changed the    doctest-result-variable default and therefore hit this bug:    http://code.google.com/p/python-nose/issues/detail?id=445 >>> a = 10,,
,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
"assert_warn_len_equal(mod, n_in_context, py34=None, py37=None):",https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_warn_len_equal_call_scenarios():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
_get_fresh_mod():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_clear_and_catch_warnings():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_suppress_warnings_module():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_suppress_warnings_type():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_suppress_warnings_decorate_no_record():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_suppress_warnings_record():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_suppress_warnings_forwarding():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_tempdir():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
test_temppath():,https://github.com//numpy/numpy/blob/master/numpy/testing/tests/test_utils.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/testing/print_coercion_tables.py,,,
print_cancast_table(ntypes):,https://github.com//numpy/numpy/blob/master/numpy/testing/print_coercion_tables.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/testing/setup.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_empty():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_ones():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_zeros():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_identity():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_eye():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_rand():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
test_randn():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_matlib.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/tests/test_numpy_version.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/tests/test_public_api.py,,,
"check_dir(module, module_name=None):",https://github.com//numpy/numpy/blob/master/numpy/tests/test_public_api.py," Returns a mapping of all objects with the wrong __module__ attribute. if module_name is None:        module_name = module.__name__    results = {} for name in dir(module):        item = getattr(module, name) if (hasattr(item, '__module__') and hasattr(item, '__name__') and item.__module__ != module_name):            results[name] = item.__module__ + '.' + item.__name__ return results

@pytest.mark.skipif(    sys.version_info[0] < 3, reason=""NumPy exposes slightly different functions on Python 2"")",,
test_numpy_namespace():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_public_api.py,,,
test_numpy_linalg():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_public_api.py,,,
test_numpy_fft():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_public_api.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/tests/test_reloading.py,,,
test_numpy_reloading():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_reloading.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/tests/test_scripts.py, Test scriptsTest that we can run executable scripts that have been installed with numpy.,,
find_f2py_commands():,https://github.com//numpy/numpy/blob/master/numpy/tests/test_scripts.py,,,
test_f2py(f2py_cmd):,https://github.com//numpy/numpy/blob/master/numpy/tests/test_scripts.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/_pytesttester.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/conftest.py,,,
pytest_configure(config):,https://github.com//numpy/numpy/blob/master/numpy/conftest.py,,,
pytest_itemcollected(item):,https://github.com//numpy/numpy/blob/master/numpy/conftest.py,"     Check FPU precision mode was not changed during test collection.    The clumsy way we do it here is mainly necessary because numpy    still uses yield tests, which can execute code at test collection    time.",,
check_fpu_mode(request):,https://github.com//numpy/numpy/blob/master/numpy/conftest.py,     Check FPU precision mode was not changed during the test.,,
,https://github.com//numpy/numpy/blob/master/numpy/ctypeslib.py,"============================``ctypes`` Utility Functions============================See Also---------load_library : Load a C library.ndpointer : Array restype/argtype with verification.as_ctypes : Create a ctypes array from an ndarray.as_array : Create an ndarray from a ctypes array.References----------.. [1] ""SciPy Cookbook: ctypes"", https://scipy-cookbook.readthedocs.io/items/Ctypes.htmlExamples--------Load the C library:>>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIPOur result type, an ndarray that must be of type double, be 1-dimensionaland is C-contiguous in memory:>>> array_1d_double = np.ctypeslib.ndpointer(...                          dtype=np.double,...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIPOur C-function typically takes an array and updates its valuesin-place.  For example::    void foo_func(double* x, int length)    {        int i;        for (i = 0; i < length; i++) {            x[i] = i*i;        }    }We wrap it using:>>> _lib.foo_func.restype = None                      #doctest: +SKIP>>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIPThen, we're ready to call ``foo_func``:>>> out = np.empty(15, dtype=np.double)>>> _lib.foo_func(out, len(out))                #doctest: +SKIP",,
_num_fromflags(flaglist):,https://github.com//numpy/numpy/blob/master/numpy/ctypeslib.py,,,
_flags_fromnum(num):,https://github.com//numpy/numpy/blob/master/numpy/ctypeslib.py,"     Like _ndptr, but with `_shape_` and `_dtype_` specified.    Notably, this means the pointer has enough information to reconstruct    the array, which is not generally true.",,
,https://github.com//numpy/numpy/blob/master/numpy/dual.py,,,
"register_func(name, func):",https://github.com//numpy/numpy/blob/master/numpy/dual.py,,,
restore_func(name):,https://github.com//numpy/numpy/blob/master/numpy/dual.py,,,
,https://github.com//numpy/numpy/blob/master/numpy/matlib.py,,,
"empty(shape, dtype=None, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/matlib.py," Return a new matrix of given shape and type, without initializing entries.","shape : int or tuple of int        Shape of the empty matrix.    dtype : data-type, optional        Desired output data-type.    order : {'C', 'F'}, optional        Whether to store multi-dimensional data in row-major        (C-style) or column-major (Fortran-style) order in        memory.",
"ones(shape, dtype=None, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/matlib.py,"     Matrix of ones.    Return a matrix of given shape and type, filled with ones.","shape : {sequence of ints, int}        Shape of the matrix    dtype : data-type, optional        The desired data-type for the matrix, default is np.float64.    order : {'C', 'F'}, optional        Whether to store matrix in C- or Fortran-contiguous order,        default is 'C'.","out : matrix        Matrix of ones of given shape, dtype, and order."
"zeros(shape, dtype=None, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/matlib.py,"     Return a matrix of given shape and type, filled with zeros.","shape : int or sequence of ints        Shape of the matrix    dtype : data-type, optional        The desired data-type for the matrix, default is float.    order : {'C', 'F'}, optional        Whether to store the result in C- or Fortran-contiguous order,        default is 'C'.","out : matrix        Zero matrix of given shape, dtype, and order."
"identity(n,dtype=None):",https://github.com//numpy/numpy/blob/master/numpy/matlib.py,     Returns the square identity matrix of given size.,"n : int        Size of the returned identity matrix.    dtype : data-type, optional        Data-type of the output. Defaults to ``float``.","out : matrix        `n` x `n` matrix with its main diagonal set to one,        and all other elements zero."
"eye(n,M=None, k=0, dtype=float, order='C'):",https://github.com//numpy/numpy/blob/master/numpy/matlib.py,     Return a matrix with ones on the diagonal and zeros elsewhere.,"n : int        Number of rows in the output.    M : int, optional        Number of columns in the output, defaults to `n`.    k : int, optional        Index of the diagonal: 0 refers to the main diagonal,        a positive value refers to an upper diagonal,        and a negative value to a lower diagonal.    dtype : dtype, optional        Data-type of the returned matrix.    order : {'C', 'F'}, optional        Whether the output should be stored in row-major (C-style) or        column-major (Fortran-style) order in memory.","I : matrix        A `n` x `M` matrix where all elements are equal to zero,        except for the `k`-th diagonal, whose values are equal to one."
rand(*args):,https://github.com//numpy/numpy/blob/master/numpy/matlib.py,"     Return a matrix of random values with given shape.    Create a matrix of the given shape and propagate it with    random samples from a uniform distribution over ``[0, 1)``.","    Parameters    ---------- \\*args : Arguments        Shape of the output.        If given as N integers, each integer specifies the size of one        dimension.        If given as a tuple, this tuple gives the complete shape.",out : ndarray        The matrix of random values with shape given by `\\*args`.
randn(*args):,https://github.com//numpy/numpy/blob/master/numpy/matlib.py,"     Return a random matrix with data from the ""standard normal"" distribution.    `randn` generates a matrix filled with random floats sampled from a    univariate ""normal"" (Gaussian) distribution of mean 0 and variance 1.","    Parameters    ---------- \\*args : Arguments        Shape of the output.        If given as N integers, each integer specifies the size of one        dimension. If given as a tuple, this tuple gives the complete shape.",Z : matrix of floats        A matrix of floating-point samples drawn from the standard normal        distribution.
,https://github.com//numpy/numpy/blob/master/numpy/setup.py,,,
